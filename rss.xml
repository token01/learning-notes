<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://bytecodes.tech/rss.xml" rel="self" type="application/rss+xml"/>
    <title>凤凰涅槃进阶之路</title>
    <link>https://bytecodes.tech/</link>
    <description>开源工具、效率方法、心理学探索的自我提升笔记，记录并输出一切能让自己提升的知识。</description>
    <language>zh-CN</language>
    <pubDate>Wed, 11 Jan 2023 05:20:24 GMT</pubDate>
    <lastBuildDate>Wed, 11 Jan 2023 05:20:24 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>go</category>
    <item>
      <title>3个月从零开始养成Machine Learning / AI 达人</title>
      <link>https://bytecodes.tech/self/good-article/%E6%9C%AA%E5%91%BD%E5%90%8D.html</link>
      <guid>https://bytecodes.tech/self/good-article/%E6%9C%AA%E5%91%BD%E5%90%8D.html</guid>
      <source url="https://bytecodes.tech/rss.xml">3个月从零开始养成Machine Learning / AI 达人</source>
      <pubDate>Wed, 11 Jan 2023 03:59:03 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_3个月从零开始养成machine-learning-ai-达人" tabindex="-1"> 3个月从零开始养成Machine Learning / AI 达人</h1>
<p><img src="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/1.jpeg" alt="">
今年无疑是AI爆火的一年，ChatGPT的横空出世，可能是2022年下半年最引人注目的AI突破，虽然可能不是技术含量最高的。为了更好的了解新技术的爆火，本文的目的单纯想加速从零开始转换AI领域的时间. 希望按表操课的人可以以最高效率， 在三个月内具备以下AI技能.</p>
<ul>
<li>了解Machine Learning 基本算法</li>
<li>会用Matlab / Octave / python建构Machine Learning</li>
<li>熟悉Anaconda、jupyter等功能及环境介面</li>
<li>了解Deep Learning Framework（ 如Tensorflow、keras、PyTorch 等）</li>
</ul>
<p>建议菜单序</p>
<ul>
<li>
<ol>
<li>网络课程（视频课程）</li>
</ol>
</li>
<li>a. <a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener noreferrer">Coursera的Machine Learning</a>（=CS229a， less math， run @ matlab/octave）</li>
<li>b. <a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener noreferrer">Coursera的Deep Learning specialization</a>（=CS230， less math， run @ python/tensorflow）</li>
<li>c. <a href="https://www.youtube.com/playlist?list=PLoROMvodv4rMiGQp3WXShtMGgzqpfVfbU" target="_blank" rel="noopener noreferrer">Stanford的CS229</a> （Machine Learning， more math， run @ matlab/octave）</li>
<li>d. <a href="https://www.youtube.com/playlist?list=PLC1qU-LWwrF64f4QKQT-Vg5Wr4qEE1Zxk" target="_blank" rel="noopener noreferrer">Stanford的CS231n</a> (Convolutional Neural Networks for Visual Recognition)</li>
<li>
<ol start="2">
<li>开发工具（工具/环境）</li>
</ol>
</li>
<li>
<ol start="3">
<li>应用实战（Kaggle）</li>
</ol>
</li>
</ul>
<p>课程菜单 ：</p>
<h2 id="_1-a-coursera的machine-learning-大约需要3周左右完成" tabindex="-1"> 1.a Coursera的Machine Learning （大约需要3周左右完成）</h2>
<p>其实这就是Stanford的229a， 建议直接到Coursera参加课程， 作为0基础者的入门是非常浅显易懂的， Coding部分只用了matlat/octave， 对没有python经验的新人来说， 真的是进入Machine Learning的方便之门， 这也是最花时间的部分，完成这个阶段算是对Machine Learning有基本的了解， 从Linear、Non-linear、Logistic 一直到 Nueral Network、Recommend system等等， 也有能力自己写一些小程序练习， 完成此课程后对这个<a href="https://playground.tensorflow.org/" target="_blank" rel="noopener noreferrer">playground</a>的小接口大概可以有些感觉</p>
<h3 id="_1-b-coursera-的deep-learning-specialization-course-1-5" tabindex="-1"> 1.b Coursera 的Deep Learning Specialization （Course 1 ~ 5）</h3>
<p>Course.1 <a href="https://www.coursera.org/learn/neural-networks-deep-learning?specialization=deep-learning" target="_blank" rel="noopener noreferrer">Neural Networks and Deep Learning</a> （大约可以4天左右完成）</p>
<ul>
<li>内容都是跟cs229a基本一样， 相当于用jupyter python复习一次<br>
Course.2 <a href="https://www.coursera.org/learn/deep-neural-network?specialization=deep-learning" target="_blank" rel="noopener noreferrer">Improving Deep Neural Networks</a> （大约可以7天左右完成）</li>
<li>主要介绍各种提高准确度或提高效率的求解优化技巧<br>
Course.3 <a href="https://www.coursera.org/learn/machine-learning-projects?specialization=deep-learning" target="_blank" rel="noopener noreferrer">Structuring Machine Learning Projects</a> （大约可以1–2天左右完成）<br>
Course.4 <a href="https://www.coursera.org/learn/convolutional-neural-networks?specialization=deep-learning" target="_blank" rel="noopener noreferrer">Convolutional Neural Networks</a> （大约可以6-7天左右完成）<br>
Course.5 <a href="https://www.coursera.org/learn/nlp-sequence-models" target="_blank" rel="noopener noreferrer">Recurrent Neural Network</a> （大约可以6– 7天左右完成）<br>
以上课程在Coursera上都只有7天免费， 但是网络上还是其他地方可以找到完整视频， 所以建议先到这些地方看完再决定要不要花钱买证书啰， 如Andrew说明， 虽然有些内容是重叠的， 但是说明的方式不太一样， 另外CS3230主要是走jupyter ipython的， 个人觉得这个考量不错， 根据课程设计及需求， 并搭配业界主流工具来选择课程上的coding环境.<br>
我的作法是在免费平台看完， 然后登入Coursera全力做quiz &amp; assignment，这样你可以在7天内完成课程喔， 我已经把空白的assignment整理好， 只要下载（<a href="https://github.com/doing-great-events/Coursera-Deep-Learning-Specialization.git" target="_blank" rel="noopener noreferrer">下载链接</a> ）后放到jupyter文件夹即可， 所以完全可以依课程进度在单机作业， 完成每个课程后再去coursera冲assignment/quize提交， 这样可以确保每一门课的完成时间（<a href="https://medium.com/@patient_shadows_eagle_388/%E6%88%91%E6%8A%8Aai%E8%AA%AA%E7%99%BD%E4%BA%86-%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E6%90%9E%E5%AE%9Aanoconda-jupyter-76c81a4687b?source=friends_link&amp;sk=6bf6dedbc4e3248c0e1bb18dadf39a4d" target="_blank" rel="noopener noreferrer">jupyter安装看这边</a>）.<br>
完成这个阶段算是对Deep Learning有一定了解了， 可以说出ML/DL差异的个人看法、熟悉jupyter能写点python、知道tensor flow/keras等等frameworks.</li>
</ul>
<h3 id="_1-c-stanford的cs229" tabindex="-1"> 1.c Stanford的CS229</h3>
<p>Youtube可以找到完整课程， 229 &amp; 229a的差别在于CS229 比较着重数学推导说明， CS229a着重在实用知识， 就手应用技巧， 数学说明较少<br>
Andrew Ng个人建议是， 因为229是挑战性较高的课程， 如果你担心你还没准备好， 可以先考虑229a， 我个人建议是看229a就好， 因为Andrew会提醒你这部分的数学推导我跳过啰， 如果你有兴趣的话你会尝试自己推导验证. 所以看完229a你会知道你对229有没有兴趣， 如果你对数学有特殊爱好当然也可以直接看229， 看完就真的不用看229a了.<br>
个人认为最大的帮助是， 最短时间内你确实踏实的修了一门algorithm的概念课程， 这类帮助在平常几乎是看不出来（或者说需要有点能力，才能辨别出来）， 但是在很多小细节的思维逻辑及讨论过程就能看出水平的差异， 在很多领域都有类似的状况， 就像很多机构工程师连应力都不会算一样， 但还是可以混得下去的.</p>
<h3 id="_1-d-stanford的cs231n" tabindex="-1"> 1.d Stanford的CS231n</h3>
<p>一般来说是因为算法特性的关系，<br>
CNN特别适合用在影像AI （2D/3D data）， RNN特别适合用在音频AI（1D sequence data）， 231n是专门讲CNN的课程， 尤其因为飞飞的关系， 在强国被奉为大陆影像AI第一人， 所以她的课程光是大陆人的流量就爆冲了.</p>
<p>上述课程的难易度一般来说是<br>
coursera Machine Learning &lt; cousera Deep Learning &lt; CS231 &lt; CS229<br>
ps. 虽然很多课程是重复的， 不过有些东西还是可以花点时间看一下， 例如YouTube上的cs230 autumn 2018 L8， Andrew分享了一些他怎么读 paper的方式， 以及他个人看过这么多Stanford学生的求学/求职模式后， 他觉得各种模式的优缺比较. 听听看Standford名师课堂上对Stanford学生的建议与分享， 我觉得也是不错的.<br>
另外1.25x播放是非常不错的方式， 可以很大程度帮助各位提高效率并节省很多时间， 我到第二个月才发现这个方式， 我个人建议是如果能快的时候可以尽量快， 该慢的时候要步步踏实， 例如我在做assignment的时候， 除了完成作业， 我会把他们的code看懂（因为我很久没有写程序啦）， 卡关的时候切忌不要上网找答案， 像我在第一次assignment的时候， 卡在simutaneously update就卡了1个小时多才发现问题， 再回头对比程序及教材或数学式时， 我会对数学式或Andrew再三强调的simutaneously update很有感觉.</p>
<h2 id="_2-开发工具-工具-环境" tabindex="-1"> 2. 开发工具（工具/环境）</h2>
<p>如果依上述菜单进行的话， 你会依以下流程习惯这些工作环境 ：<br>
Octave/Matlab（cs229a） -&gt; <a href="https://medium.com/@patient_shadows_eagle_388/%E6%88%91%E6%8A%8Aai%E8%AA%AA%E7%99%BD%E4%BA%86-%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E6%90%9E%E5%AE%9Aanoconda-jupyter-76c81a4687b?source=friends_link&amp;sk=6bf6dedbc4e3248c0e1bb18dadf39a4d" target="_blank" rel="noopener noreferrer">jupyter python</a>（cs230 / cs231n） -&gt; <a href="https://medium.com/@patient_shadows_eagle_388/%E6%88%91%E6%8A%8Aai%E8%AA%AA%E7%99%BD%E4%BA%86-tensorflow%E6%98%AF%E4%BB%80%E9%BA%BC-%E6%88%91%E8%A9%B2%E6%80%8E%E9%BA%BC%E8%A3%9D%E6%9C%80%E5%A5%BD-68e30826e975?source=friends_link&amp;sk=f065a2311b6839ba2a4d19b606e40f86" target="_blank" rel="noopener noreferrer">tensor flow</a>（cs230） -&gt; Google Colab<br>
使用python时， 千万不要单独安装python以及各种package， 建议要务必利用<a href="https://medium.com/@patient_shadows_eagle_388/%E6%88%91%E6%8A%8Aai%E8%AA%AA%E7%99%BD%E4%BA%86-%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E6%90%9E%E5%AE%9Aanoconda-jupyter-76c81a4687b?source=friends_link&amp;sk=6bf6dedbc4e3248c0e1bb18dadf39a4d" target="_blank" rel="noopener noreferrer">Anaconda</a>作为python版本及众多package的管理界面. 可以节省大量时间而且省心省力好上手.<br>
另外建议要熟悉一下github界面， 因为cs230的assignment， 我当时是在GitHub上东拼西凑整理出来， 未来要做项目免不了team work模式， 所以GitHub的界面使用还是有必要了解一下的， 只是为了协助各位最短时间吃完以上菜单， 所以我直接把<a href="https://github.com/doing-great-events/Coursera-Deep-Learning-Specialization.git" target="_blank" rel="noopener noreferrer">cs230 assignment的空白卷</a> 也一并整理出来让大家效率更高.<br>
完成这个阶段， 原则上你已经是具备AI的一切技能了， 差的只是提升实战经验了.</p>
<h2 id="_3-应用实战-kaggle" tabindex="-1"> 3. 应用实战（<a href="https://www.kaggle.com/" target="_blank" rel="noopener noreferrer">Kaggle</a>）</h2>
<p>大概在完成1b. Course 2开始接触Kaggle， 觉得这个切入的时机点不错， 因为这个阶段已经算对ML/DL有一定认识， 只是coding技能尚未纯熟， 问题思考角度与经验尚待补强， 这时候进到Kaggle最大的好处是， 它有很多很多很多的题目， 所以绝对足够练习. 另外Kaggle也有一些免费课程， 这边的课程我觉得就不用上了， 直接透过Competetion题目实作学习比较快. 一般来说Knowledge类的题目都是不错的练习题， Kaggle也会告诉你Titanic是它们建议的第一题， 再来House Prices、Digital Recognition等等， 第一次感受完后， 可以看看其他人的思考过程分享文（<a href="https://github.com/doing-great-events/Kaggle/blob/main/Titanic_competition/Titanic_Top2.5%25.ipynb" target="_blank" rel="noopener noreferrer">我的结果Top 2.5%， code在GitHub这边</a>）.<br>
Titanic的分享文很多， 英文不错的话建议看这两篇<br>
- <a href="https://www.kaggle.com/themlphdstudent/titanic-survive-prediction-tutorial-for-beginners" target="_blank" rel="noopener noreferrer">Titanic Survive Prediction Tutorial for Beginners</a><br>
- <a href="https://www.kaggle.com/soham1024/titanic-data-science-eda-with-meme-solution" target="_blank" rel="noopener noreferrer">Titanic Data Science EDA with meme+Solution</a><br>
中文建议这篇<br>
-<a href="https://medium.com/@yulongtsai/https-medium-com-yulongtsai-titanic-top3-8e64741cc11f" target="_blank" rel="noopener noreferrer">泰坦尼克号生存预测（Top 3%）</a></p>
<p><img src="https://miro.medium.com/max/1400/1*_Jmlki3sk42GQQTR2SzZ3g.png" alt=""></p>
<p>搞了3天 总算达成自定义目标 （rank TOP 3% up &amp; score 0.8 up）， 非常适合新手练习的题目</p>
<p>Deep CNN Task ： 上完Coursera Deep Learning专项课程后， 应该有能力作一些稍微复杂的模型， 我个人练习了重现facenet模型（Facenet = MTCNN + ResNET embedding+ Triplet classifier）， 下图为我在<a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fdoing-great-events%2FMTCNN_inside_jupyter%2Fblob%2Fmain%2FMTCNN_inside_jupyter%2Fjypyter_MTCNN_upload.ipynb%3Ffbclid%3DIwAR1QcipPXUyOLj4nmu5RSMI46uB5Jqtd3PP-tS_SK12w4MYdWxB_n5EUkg0&amp;h=AT0B5vxVeWJriwH-cm4RZRPdNZaVEFDNRbUgh1-Tzv4nYL4tcCZXeI3UcREaIvMC5y9e8TMZvhtolG6sM_pCBSVJErXzV9LYXf03couIiQ5gimzmLbKJYi6NCN8b_zJu3BJB&amp;__tn__=R%5D-R&amp;c%5B0%5D=AT2vjRjltRa9vUA4v8RiH0joNP2WJMb_TmN4nvK_2gXwHypDosibS3fSSsYlob06isUq9rjW_P9PvBIeDaU0ZJUjAxtQb9_U8kEiyim4fyp3cT4GFfbVKyMVA6KldkfDB19RdcxDNVwSKJFdTDiMkjrPCg" target="_blank" rel="noopener noreferrer">jupyter重现MTCNN的结果</a>.</p>
<p><img src="https://miro.medium.com/max/3324/1*8_Prcmpuq23zIFl-qP4OPw.png" alt=""></p>
<p><img src="https://miro.medium.com/max/3836/1*cu9pxh9DY9JNdo0inkscdQ.png" alt=""></p>
<p>左边为MTCNN 3阶段产出， 右边为即时影像脸部侦测</p>
<p>Deep CNN Task ： 重现<a href="https://github.com/doing-great-events/FACENET_inside_jupyter" target="_blank" rel="noopener noreferrer">Facenet 即时人脸辨识</a></p>
<p><img src="https://miro.medium.com/max/1400/1*miVebjWjOlg-wdS78KDxyA.png" alt=""></p>
<p>Other Resources<br>
<a href="https://developers.google.com/machine-learning/" target="_blank" rel="noopener noreferrer">Machine Learning Crash Course</a> ： Google 提供的ML在线教育资源<br>
<a href="https://leetcode.com/" target="_blank" rel="noopener noreferrer">https://leetcode.com/</a> ： 写程序必须谨记“高效”， 彻底改变你对写程序的认知</p>
]]></content:encoded>
      <enclosure url="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/1.jpeg" type="image/jpeg"/>
    </item>
    <item>
      <title>go语言-基础知识</title>
      <link>https://bytecodes.tech/language/go/01.base/</link>
      <guid>https://bytecodes.tech/language/go/01.base/</guid>
      <source url="https://bytecodes.tech/rss.xml">go语言-基础知识</source>
      <category>go</category>
      <pubDate>Fri, 06 Jan 2023 14:36:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="目录" tabindex="-1"> 目录</h1>
<p>TODO</p>
]]></content:encoded>
    </item>
    <item>
      <title>go语言-web</title>
      <link>https://bytecodes.tech/language/go/02.web/</link>
      <guid>https://bytecodes.tech/language/go/02.web/</guid>
      <source url="https://bytecodes.tech/rss.xml">go语言-web</source>
      <category>go</category>
      <pubDate>Fri, 06 Jan 2023 14:36:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="目录" tabindex="-1"> 目录</h1>
<p>TODO</p>
]]></content:encoded>
    </item>
    <item>
      <title>go语言-orm</title>
      <link>https://bytecodes.tech/language/go/03.orm/</link>
      <guid>https://bytecodes.tech/language/go/03.orm/</guid>
      <source url="https://bytecodes.tech/rss.xml">go语言-orm</source>
      <category>go</category>
      <pubDate>Fri, 06 Jan 2023 14:36:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="目录" tabindex="-1"> 目录</h1>
<p>TODO</p>
]]></content:encoded>
    </item>
    <item>
      <title>01.go日常开发代码片段</title>
      <link>https://bytecodes.tech/language/go/04.skills/01.go%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5.html</link>
      <guid>https://bytecodes.tech/language/go/04.skills/01.go%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5.html</guid>
      <source url="https://bytecodes.tech/rss.xml">01.go日常开发代码片段</source>
      <pubDate>Fri, 06 Jan 2023 14:36:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_01-go日常开发代码片段" tabindex="-1"> 01.go日常开发代码片段</h1>
<h2 id="获取终端输入" tabindex="-1"> 获取终端输入</h2>
<p>一般情况下，我们使用fmt包的scan方法来获取终端输入内容，但是这可能会有一个问题，如果输入内容有空格或者换行，就不适用了，因此，可以通过bufio来实现获取输入的功能。</p>
<div><pre><code><span>package</span> main

<span>import</span> <span>(</span>
 <span>"bufio"</span>
 <span>"fmt"</span>
 <span>"os"</span>
<span>)</span>

<span>func</span> <span>input1</span><span>(</span><span>)</span> <span>{</span>
 <span>var</span> s <span>string</span>
 fmt<span>.</span><span>Print</span><span>(</span><span>"请输入内容："</span><span>)</span>
 fmt<span>.</span><span>Scanln</span><span>(</span><span>&amp;</span>s<span>)</span>
 fmt<span>.</span><span>Printf</span><span>(</span><span>"输入的内容为：%s\n"</span><span>,</span> s<span>)</span>
<span>}</span>

<span>func</span> <span>input2</span><span>(</span><span>)</span> <span>{</span>
 <span>var</span> s <span>string</span>
 reader <span>:=</span> bufio<span>.</span><span>NewReader</span><span>(</span>os<span>.</span>Stdin<span>)</span>
 s<span>,</span> <span>_</span> <span>=</span> reader<span>.</span><span>ReadString</span><span>(</span><span>'\n'</span><span>)</span> <span>//指定获取输入时的分隔标识</span>
 fmt<span>.</span><span>Printf</span><span>(</span><span>"输入的内容为:%s\n"</span><span>,</span> s<span>)</span>

<span>}</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
 <span>//问题在于，当用户输入内容为  a b c时，程序获取到的只有a，亦即空格即被截断</span>
 <span>// input1()</span>
 <span>input2</span><span>(</span><span>)</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="生成一个随机数" tabindex="-1"> 生成一个随机数</h2>
<div><pre><code><span>package</span> main

<span>import</span> <span>(</span>
 <span>"fmt"</span>
 <span>"math/rand"</span>
 <span>"time"</span>
<span>)</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
 <span>// 设置一个时间种子</span>
 rand<span>.</span><span>Seed</span><span>(</span>time<span>.</span><span>Now</span><span>(</span><span>)</span><span>.</span><span>UnixNano</span><span>(</span><span>)</span><span>)</span>
 <span>// 表示随机返回一个0到100之间的数字</span>
 s <span>:=</span> rand<span>.</span><span>Intn</span><span>(</span><span>100</span><span>)</span>
 fmt<span>.</span><span>Println</span><span>(</span>s<span>)</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="获取主机ip" tabindex="-1"> 获取主机IP</h2>
<div><pre><code><span>package</span> main

<span>import</span> <span>(</span>
 <span>"fmt"</span>
 <span>"net"</span>
 <span>"strings"</span>
<span>)</span>

<span>func</span> <span>GetOutboundIP</span><span>(</span><span>)</span> <span>(</span>ip <span>string</span><span>,</span> err <span>error</span><span>)</span> <span>{</span>
 conn<span>,</span> err <span>:=</span> net<span>.</span><span>Dial</span><span>(</span><span>"udp"</span><span>,</span> <span>"8.8.8.8:80"</span><span>)</span>
 <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
  <span>return</span>
 <span>}</span>
 <span>defer</span> conn<span>.</span><span>Close</span><span>(</span><span>)</span>
 localAddr <span>:=</span> conn<span>.</span><span>LocalAddr</span><span>(</span><span>)</span><span>.</span><span>(</span><span>*</span>net<span>.</span>UDPAddr<span>)</span>
 <span>//fmt.Println(localAddr.String())</span>
 ip <span>=</span> strings<span>.</span><span>Split</span><span>(</span>localAddr<span>.</span>IP<span>.</span><span>String</span><span>(</span><span>)</span><span>,</span> <span>":"</span><span>)</span><span>[</span><span>0</span><span>]</span>
 <span>return</span>
<span>}</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
 ip<span>,</span> err <span>:=</span> <span>GetOutboundIP</span><span>(</span><span>)</span>
 <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
  fmt<span>.</span><span>Println</span><span>(</span>err<span>)</span>
 <span>}</span>
 fmt<span>.</span><span>Println</span><span>(</span>ip<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行效果如下：</p>
<div><pre><code><span>[</span>root@ops<span>-</span>eryajf<span>-</span>test<span>-</span><span>1</span> test<span>]</span>$<span>go</span> run main<span>.</span><span>go</span>
<span>10.3</span><span>.0</span><span>.41</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="如何获取一周前-一天前的时间" tabindex="-1"> 如何获取一周前,一天前的时间</h2>
<p>获取一天前或者一周前应该是日常当中经常遇到的场景，这里说一下go当中的实现方式：</p>
<div><pre><code><span>package</span> main
<span>import</span> <span>(</span>
  <span>"fmt"</span>
  <span>"time"</span>
<span>)</span>
<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
<span>//Add方法和Sub方法是相反的，获取t0和t1的时间距离d是使用Sub</span>
<span>//将t0加d获取t1就是使用Add方法</span>
  k <span>:=</span> time<span>.</span><span>Now</span><span>(</span><span>)</span>
  <span>//一天之前</span>
  d<span>,</span> <span>_</span> <span>:=</span> time<span>.</span><span>ParseDuration</span><span>(</span><span>"-24h"</span><span>)</span>
  fmt<span>.</span><span>Println</span><span>(</span>k<span>.</span><span>Add</span><span>(</span>d<span>)</span><span>)</span>
  <span>//一周之前</span>
  fmt<span>.</span><span>Println</span><span>(</span>k<span>.</span><span>Add</span><span>(</span>d <span>*</span> <span>7</span><span>)</span><span>)</span>
  <span>//一月之前</span>
  fmt<span>.</span><span>Println</span><span>(</span>k<span>.</span><span>Add</span><span>(</span>d <span>*</span> <span>30</span><span>)</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上边例子比较有意义的是一周之前，一天之前或者一月之前的算法，更多用如下方式：</p>
<div><pre><code>t <span>:=</span> time<span>.</span><span>Now</span><span>(</span><span>)</span>
<span>// 计算前一天, 当前时间加上0年，0月，-1天</span>
t1 <span>:=</span> t<span>.</span><span>AddDate</span><span>(</span><span>0</span><span>,</span><span>0</span><span>,</span><span>-</span><span>1</span><span>)</span>
 
<span>// 计算上一个月时间,当前时间加上0年，-1月，0天</span>
t1 <span>:=</span> t<span>.</span><span>AddDate</span><span>(</span><span>0</span><span>,</span><span>-</span><span>1</span><span>,</span><span>0</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="如何判断一个字符串是否在切片列表里" tabindex="-1"> 如何判断一个字符串是否在切片列表里</h2>
<p>有时候我们会通过遍历拿到数据，但是这些数据当中的部分内容是我们特别关心的，这个时候就出现了一个场景：遍历的时候如何判断字符串是否在自己关心的列表当中？</p>
<div><pre><code><span>func</span> <span>Find</span><span>(</span>slice <span>[</span><span>]</span><span>string</span><span>,</span> val <span>string</span><span>)</span> <span>(</span><span>int</span><span>,</span> <span>bool</span><span>)</span> <span>{</span>
    <span>for</span> i<span>,</span> item <span>:=</span> <span>range</span> slice <span>{</span>
        <span>if</span> item <span>==</span> val <span>{</span>
            <span>return</span> i<span>,</span> <span>true</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>-</span><span>1</span><span>,</span> <span>false</span>
<span>}</span>
 
<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
　　dataList <span>:=</span> <span>[</span><span>]</span><span>string</span><span>{</span><span>"test1"</span><span>,</span> <span>"test2"</span><span>}</span>
　　
　　dataStr <span>:=</span> <span>"test1"</span>　　
　　<span>// 传入切片 和 要查找的字符串</span>
　　<span>_</span><span>,</span> flag <span>:=</span> <span>Find</span><span>(</span>dataList<span>,</span> dataStr<span>)</span>
　　<span>if</span> flag <span>{</span>
　　　　fmt<span>.</span><span>Println</span><span>(</span><span>"存在 -> "</span><span>,</span> dataStr<span>)</span>
　　<span>}</span> <span>else</span> <span>{</span>
　　　　fmt<span>.</span><span>Println</span><span>(</span><span>"不存在 -> "</span><span>,</span> dataStr<span>)</span>
　　<span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个时候我们就可以借助于上边的这个小工具来快速过滤或者判断对应的字符串是否是自己想要的了。</p>
]]></content:encoded>
    </item>
    <item>
      <title>02.golang交叉编译</title>
      <link>https://bytecodes.tech/language/go/04.skills/02.golang%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91.html</link>
      <guid>https://bytecodes.tech/language/go/04.skills/02.golang%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91.html</guid>
      <source url="https://bytecodes.tech/rss.xml">02.golang交叉编译</source>
      <pubDate>Fri, 06 Jan 2023 14:36:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_02-golang交叉编译" tabindex="-1"> 02.golang交叉编译</h1>
<p>Golang支持交叉编译程序，交叉编译的意思就是在Mac电脑上可以编译出能在Windows上，Linux上运行的程序，同理其他环境也可以。</p>
<p>方法也特别简单，这里做一下记录。</p>
<h2 id="_1-mac电脑上编译" tabindex="-1"> 1，Mac电脑上编译</h2>
<p><code>Linux</code></p>
<div><pre><code>CGO_ENABLED<span>=</span><span>0</span> GOOS<span>=</span>linux GOARCH<span>=</span>amd64 <span>go</span> build main<span>.</span><span>go</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>Windows</code></p>
<div><pre><code>CGO_ENABLED<span>=</span><span>0</span> GOOS<span>=</span>windows GOARCH<span>=</span>amd64 <span>go</span> build main<span>.</span><span>go</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="_2-linux环境编译" tabindex="-1"> 2，Linux环境编译</h2>
<p><code>Mac</code></p>
<div><pre><code>CGO_ENABLED<span>=</span><span>0</span> GOOS<span>=</span>darwin GOARCH<span>=</span>amd64 <span>go</span> build main<span>.</span><span>go</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>Windows</code></p>
<div><pre><code>CGO_ENABLED<span>=</span><span>0</span> GOOS<span>=</span>windows GOARCH<span>=</span>amd64 <span>go</span> build main<span>.</span><span>go</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="_3-windows电脑上编译" tabindex="-1"> 3，Windows电脑上编译</h2>
<p><code>Mac</code></p>
<div><pre><code>SET CGO_ENABLED<span>=</span><span>0</span>
SET GOOS<span>=</span>darwin
SET GOARCH<span>=</span>amd64
<span>go</span> build main<span>.</span><span>go</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><code>Linux</code></p>
<div><pre><code>SET CGO_ENABLED<span>=</span><span>0</span>
SET GOOS<span>=</span>linux
SET GOARCH<span>=</span>amd64
<span>go</span> build main<span>.</span><span>go</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>03.两个切片内容相减的几种方法</title>
      <link>https://bytecodes.tech/language/go/04.skills/03.%E4%B8%A4%E4%B8%AA%E5%88%87%E7%89%87%E5%86%85%E5%AE%B9%E7%9B%B8%E5%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95.html</link>
      <guid>https://bytecodes.tech/language/go/04.skills/03.%E4%B8%A4%E4%B8%AA%E5%88%87%E7%89%87%E5%86%85%E5%AE%B9%E7%9B%B8%E5%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95.html</guid>
      <source url="https://bytecodes.tech/rss.xml">03.两个切片内容相减的几种方法</source>
      <pubDate>Fri, 06 Jan 2023 14:36:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_03-两个切片内容相减的几种方法" tabindex="-1"> 03.两个切片内容相减的几种方法</h1>
<ul>
<li>
<p>问题</p>
<div><pre><code>已知： 
 <span>var</span> a <span>[</span><span>]</span><span>string</span> <span>=</span> <span>[</span><span>]</span><span>string</span><span>{</span><span>"11"</span><span>,</span> <span>"33"</span><span>,</span> <span>"22"</span><span>,</span> <span>"44"</span><span>}</span>
 <span>var</span> b <span>[</span><span>]</span><span>string</span> <span>=</span> <span>[</span><span>]</span><span>string</span><span>{</span><span>"11"</span><span>,</span> <span>"22"</span><span>}</span>
 <span>var</span> b <span>[</span><span>]</span><span>string</span>

预期：
 c <span>=</span> <span>[</span><span>]</span><span>string</span><span>{</span><span>"11"</span><span>,</span> <span>"22"</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ul>
<h2 id="_1-运维的思路" tabindex="-1"> 1，运维的思路</h2>
<h3 id="方法一" tabindex="-1"> 方法一</h3>
<div><pre><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
 <span>var</span> <span>(</span>
  weightInstanceList <span>[</span><span>]</span><span>string</span> <span>=</span> <span>[</span><span>]</span><span>string</span><span>{</span><span>"11"</span><span>,</span> <span>"22"</span><span>,</span> <span>"33"</span><span>,</span> <span>"44"</span><span>}</span>
  RelateInstance     <span>[</span><span>]</span><span>string</span> <span>=</span> <span>[</span><span>]</span><span>string</span><span>{</span><span>"11"</span><span>,</span> <span>"22"</span><span>}</span>
  a                  <span>[</span><span>]</span><span>string</span> <span>// 期望：22,33,44</span>
 <span>)</span>

 fmt<span>.</span><span>Println</span><span>(</span>weightInstanceList<span>,</span> RelateInstance<span>)</span>

 <span>// 循环老的</span>
 <span>for</span> <span>_</span><span>,</span> instance <span>:=</span> <span>range</span> weightInstanceList <span>{</span>
  <span>// 传入待删除IP切片 老的IP 进行判断 是否相等 相等表示待删除 反之加入更新jenkinsFile列表</span>
  isOk <span>:=</span> <span>IsContain</span><span>(</span>RelateInstance<span>,</span> instance<span>)</span>
  <span>if</span> <span>!</span>isOk <span>{</span>
   a <span>=</span> <span>append</span><span>(</span>a<span>,</span> instance<span>)</span>
  <span>}</span>

 <span>}</span>

 fmt<span>.</span><span>Println</span><span>(</span><span>"最后结果："</span><span>,</span> a<span>)</span> <span>// a=["11","11","11"]</span>

<span>}</span>

<span>func</span> <span>IsContain</span><span>(</span>items <span>[</span><span>]</span><span>string</span><span>,</span> item <span>string</span><span>)</span> <span>bool</span> <span>{</span>
 <span>for</span> <span>_</span><span>,</span> eachItem <span>:=</span> <span>range</span> items <span>{</span>
  <span>if</span> eachItem <span>==</span> item <span>{</span>
   <span>return</span> <span>true</span>
  <span>}</span>
 <span>}</span>
 <span>return</span> <span>false</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="方法二" tabindex="-1"> 方法二</h3>
<div><pre><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
 <span>var</span> <span>(</span>
  weightInstanceList <span>[</span><span>]</span><span>string</span> <span>=</span> <span>[</span><span>]</span><span>string</span><span>{</span><span>"11"</span><span>,</span> <span>"33"</span><span>,</span> <span>"22"</span><span>,</span> <span>"44"</span><span>}</span>
  RelateInstance     <span>[</span><span>]</span><span>string</span> <span>=</span> <span>[</span><span>]</span><span>string</span><span>{</span><span>"11"</span><span>,</span> <span>"22"</span><span>}</span>
 <span>)</span>
 fmt<span>.</span><span>Println</span><span>(</span>weightInstanceList<span>[</span><span>1</span><span>:</span><span>]</span><span>)</span>
 <span>for</span> <span>_</span><span>,</span> instance <span>:=</span> <span>range</span> weightInstanceList <span>{</span>
  <span>for</span> <span>_</span><span>,</span> item <span>:=</span> <span>range</span> RelateInstance <span>{</span>
   <span>if</span> instance <span>==</span> item <span>{</span>
    weightInstanceList <span>=</span> <span>RemoveParam</span><span>(</span>weightInstanceList<span>,</span> instance<span>)</span>
   <span>}</span>

  <span>}</span>
 <span>}</span>
 fmt<span>.</span><span>Println</span><span>(</span><span>"最后结果："</span><span>,</span> weightInstanceList<span>)</span> <span>// a=["11","11","11"]</span>
<span>}</span>

<span>func</span> <span>RemoveParam</span><span>(</span>sli <span>[</span><span>]</span><span>string</span><span>,</span> n <span>string</span><span>)</span> <span>[</span><span>]</span><span>string</span> <span>{</span>
 <span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>len</span><span>(</span>sli<span>)</span><span>;</span> i<span>++</span> <span>{</span>
  <span>if</span> sli<span>[</span>i<span>]</span> <span>==</span> n <span>{</span>
   <span>if</span> i <span>==</span> <span>0</span> <span>{</span>
    sli <span>=</span> sli<span>[</span><span>1</span><span>:</span><span>]</span>
   <span>}</span> <span>else</span> <span>if</span> i <span>==</span> <span>len</span><span>(</span>sli<span>)</span><span>-</span><span>1</span> <span>{</span>
    sli <span>=</span> sli<span>[</span><span>:</span>i<span>]</span>
   <span>}</span> <span>else</span> <span>{</span>
    sli <span>=</span> <span>append</span><span>(</span>sli<span>[</span><span>:</span>i<span>]</span><span>,</span> sli<span>[</span>i<span>+</span><span>1</span><span>:</span><span>]</span><span>...</span><span>)</span>
   <span>}</span>
   i<span>--</span> <span>// 如果索引i被去掉后，原来索引i+1的会移动到索引i</span>
  <span>}</span>
 <span>}</span>
 <span>return</span> sli
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_2开发的思路" tabindex="-1"> 2开发的思路</h2>
<h3 id="方法一-1" tabindex="-1"> 方法一</h3>
<div><pre><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
 <span>var</span> <span>(</span>
  weightInstanceList <span>[</span><span>]</span><span>string</span> <span>=</span> <span>[</span><span>]</span><span>string</span><span>{</span><span>"11"</span><span>,</span> <span>"33"</span><span>,</span> <span>"22"</span><span>,</span> <span>"44"</span><span>}</span>
  RelateInstance     <span>[</span><span>]</span><span>string</span> <span>=</span> <span>[</span><span>]</span><span>string</span><span>{</span><span>"11"</span><span>,</span> <span>"22"</span><span>}</span>
 <span>)</span>
 fmt<span>.</span><span>Println</span><span>(</span><span>diff</span><span>(</span>weightInstanceList<span>,</span> RelateInstance<span>)</span><span>)</span>
<span>}</span>
<span>func</span> <span>diff</span><span>(</span>a<span>,</span> b <span>[</span><span>]</span><span>string</span><span>)</span> <span>[</span><span>]</span><span>string</span> <span>{</span>
 <span>var</span> <span>(</span>
  r <span>[</span><span>]</span><span>string</span>
  m <span>=</span> <span>make</span><span>(</span><span>map</span><span>[</span><span>string</span><span>]</span><span>struct</span><span>{</span><span>}</span><span>,</span> <span>len</span><span>(</span>a<span>)</span><span>)</span>
 <span>)</span>

 <span>for</span> <span>_</span><span>,</span> v <span>:=</span> <span>range</span> b <span>{</span>
  m<span>[</span>v<span>]</span> <span>=</span> <span>struct</span><span>{</span><span>}</span><span>{</span><span>}</span>
 <span>}</span>

 <span>for</span> <span>_</span><span>,</span> v <span>:=</span> <span>range</span> a <span>{</span>
  <span>if</span> <span>_</span><span>,</span> ok <span>:=</span> m<span>[</span>v<span>]</span><span>;</span> <span>!</span>ok <span>{</span>
   r <span>=</span> <span>append</span><span>(</span>r<span>,</span> v<span>)</span>
  <span>}</span>
 <span>}</span>

 <span>return</span> r
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="方法二-1" tabindex="-1"> 方法二</h3>
<div><pre><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
 <span>var</span> <span>(</span>
  weightInstanceList <span>[</span><span>]</span><span>string</span> <span>=</span> <span>[</span><span>]</span><span>string</span><span>{</span><span>"11"</span><span>,</span> <span>"33"</span><span>,</span> <span>"22"</span><span>,</span> <span>"44"</span><span>}</span>
  RelateInstance     <span>[</span><span>]</span><span>string</span> <span>=</span> <span>[</span><span>]</span><span>string</span><span>{</span><span>"11"</span><span>,</span> <span>"22"</span><span>}</span>
 <span>)</span>
 fmt<span>.</span><span>Println</span><span>(</span><span>diff</span><span>(</span>weightInstanceList<span>,</span> RelateInstance<span>)</span><span>)</span>
<span>}</span>
<span>func</span> <span>diff</span><span>(</span>a<span>,</span> b <span>[</span><span>]</span><span>string</span><span>)</span> <span>[</span><span>]</span><span>string</span> <span>{</span>
 <span>var</span> <span>(</span>
  r <span>[</span><span>]</span><span>string</span>
  m <span>=</span> <span>make</span><span>(</span><span>map</span><span>[</span><span>string</span><span>]</span><span>struct</span><span>{</span><span>}</span><span>,</span> <span>len</span><span>(</span>a<span>)</span><span>)</span>
 <span>)</span>

 <span>for</span> <span>_</span><span>,</span> v <span>:=</span> <span>range</span> a <span>{</span>
  m<span>[</span>v<span>]</span> <span>=</span> <span>struct</span><span>{</span><span>}</span><span>{</span><span>}</span>
 <span>}</span>

 <span>for</span> <span>_</span><span>,</span> v <span>:=</span> <span>range</span> b <span>{</span>
  <span>delete</span><span>(</span>m<span>,</span> v<span>)</span>
 <span>}</span>

 <span>for</span> k<span>,</span> <span>_</span> <span>:=</span> <span>range</span> m <span>{</span>
  r <span>=</span> <span>append</span><span>(</span>r<span>,</span> k<span>)</span>
 <span>}</span>

 <span>return</span> r
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看出，运维处理该问题时思路会困在当前类型中予以实现，不如开发对数据结构以及特性掌握的牢固，运用起来也就不够灵活了。</p>
]]></content:encoded>
    </item>
    <item>
      <title>04.golang以结构体中某个字段进行排序</title>
      <link>https://bytecodes.tech/language/go/04.skills/04.golang%E4%BB%A5%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F.html</link>
      <guid>https://bytecodes.tech/language/go/04.skills/04.golang%E4%BB%A5%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F.html</guid>
      <source url="https://bytecodes.tech/rss.xml">04.golang以结构体中某个字段进行排序</source>
      <pubDate>Fri, 06 Jan 2023 14:36:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_04-golang以结构体中某个字段进行排序" tabindex="-1"> 04.golang以结构体中某个字段进行排序</h1>
<p>我写了一个脚本获取项目在harbor中的tag列表，经过一些curl测试之后，很快就完成了这个脚本的编写。</p>
<p>接下来需要做一些优化方面的考量。</p>
<p>首先一个问题是，返回的结果的顺序好像是随机的，这不是我想要的，通常，当我利用此脚本查项目可用的tag时，我的诉求可能更倾向于获取它最新push的tag，于是，就有了一个在内存中对列表排序的需求。</p>
<p>经过一番搜索，发现官方提供的sort包，直接使用能够对简单的列表进行排序，如果是结构体中的某个字段，则可以用如下方式定义方法：</p>
<div><pre><code><span>// Tags harbor项目tag的对象</span>
<span>type</span> Tags <span>struct</span> <span>{</span>
 Digest        <span>string</span>    <span>`json:"digest"`</span>
 Name          <span>string</span>    <span>`json:"name"`</span>
 Size          <span>int</span>       <span>`json:"size"`</span>
 Architecture  <span>string</span>    <span>`json:"architecture"`</span>
 Os            <span>string</span>    <span>`json:"os"`</span>
 OsVersion     <span>string</span>    <span>`json:"os.version"`</span>
 DockerVersion <span>string</span>    <span>`json:"docker_version"`</span>
 Author        <span>string</span>    <span>`json:"author"`</span>
 Created       time<span>.</span>Time <span>`json:"created"`</span>
 Config        <span>struct</span> <span>{</span>
  Labels <span>interface</span><span>{</span><span>}</span> <span>`json:"labels"`</span>
 <span>}</span> <span>`json:"config"`</span>
 Signature <span>interface</span><span>{</span><span>}</span>   <span>`json:"signature"`</span>
 Labels    <span>[</span><span>]</span><span>interface</span><span>{</span><span>}</span> <span>`json:"labels"`</span>
 PushTime  time<span>.</span>Time     <span>`json:"push_time"`</span>
 PullTime  time<span>.</span>Time     <span>`json:"pull_time"`</span>
<span>}</span>

<span>// 基于时间字段进行排序功能</span>
<span>type</span> tags <span>[</span><span>]</span>Tags

<span>func</span> <span>(</span>s tags<span>)</span> <span>Len</span><span>(</span><span>)</span> <span>int</span> <span>{</span>
 <span>return</span> <span>len</span><span>(</span>s<span>)</span>
<span>}</span>
<span>func</span> <span>(</span>s tags<span>)</span> <span>Swap</span><span>(</span>i<span>,</span> j <span>int</span><span>)</span> <span>{</span>
 s<span>[</span>i<span>]</span><span>,</span> s<span>[</span>j<span>]</span> <span>=</span> s<span>[</span>j<span>]</span><span>,</span> s<span>[</span>i<span>]</span>
<span>}</span>

<span>type</span> ByTime <span>struct</span> <span>{</span>
 tags
<span>}</span>

<span>func</span> <span>(</span>b ByTime<span>)</span> <span>Less</span><span>(</span>i<span>,</span> j <span>int</span><span>)</span> <span>bool</span> <span>{</span>
 <span>return</span> b<span>.</span>tags<span>[</span>i<span>]</span><span>.</span>Created<span>.</span><span>Before</span><span>(</span>b<span>.</span>tags<span>[</span>j<span>]</span><span>.</span>Created<span>)</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在结果返回的地方，直接调用此方法即可实现按时间排序：</p>
<div><pre><code>sort<span>.</span><span>Sort</span><span>(</span>ByTime<span>{</span>data<span>}</span><span>)</span> <span>// 基于创建时间字段进行排序</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>网上的文章，如果字段是int类型时的排序方式：<a href="https://segmentfault.com/a/1190000008062661" target="_blank" rel="noopener noreferrer">golang对自定义类型排序</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>05.vscode开发golang报黄提示composite literal uses unkeyed fields</title>
      <link>https://bytecodes.tech/language/go/04.skills/05.vscode%E5%BC%80%E5%8F%91golang%E6%8A%A5%E9%BB%84%E6%8F%90%E7%A4%BAcomposite%20literal%20uses%20unkeyed%20fields.html</link>
      <guid>https://bytecodes.tech/language/go/04.skills/05.vscode%E5%BC%80%E5%8F%91golang%E6%8A%A5%E9%BB%84%E6%8F%90%E7%A4%BAcomposite%20literal%20uses%20unkeyed%20fields.html</guid>
      <source url="https://bytecodes.tech/rss.xml">05.vscode开发golang报黄提示composite literal uses unkeyed fields</source>
      <pubDate>Fri, 06 Jan 2023 14:36:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_05-vscode开发golang报黄提示composite-literal-uses-unkeyed-fields" tabindex="-1"> 05.vscode开发golang报黄提示composite literal uses unkeyed fields</h1>
<p>Golang 中使用 Mongo 时经常会写</p>
<p>:::
<code>bson.D{{&quot;key&quot;, &quot;value&quot;}}</code> 这种内容，然后 VS Code 中就会得到大量PROBLEMS，并且老有波浪线的提示，有两种方式能够解决，一种是将结构体补全，一种是禁用掉这种检测。</p>
<h2 id="补全结构体" tabindex="-1"> 补全结构体</h2>
<p>补全结构体就是将如上的bson写成如下方式就不会报了：</p>
<div><pre><code>bson<span>.</span>D<span>{</span><span>{</span>Key<span>:</span> <span>"key"</span><span>,</span> Value<span>:</span> <span>"value"</span><span>}</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>:::</p>
<p>这种写法固然可以，不过当嵌套多的时候，写起来会比较费劲儿，因此这里推荐第二种方式。</p>
<h2 id="关闭检测" tabindex="-1"> 关闭检测</h2>
<p>通过命令行打开<code>setting.json</code>：</p>
<p><img src="http://t.eryajf.net/imgs/2022/01/d6fa4a9f2f285f91.png" alt="imags"></p>
<p>然后添加如下内容：</p>
<div><pre><code> <span>"gopls"</span><span>:</span> <span>{</span>
        <span>"analyses"</span><span>:</span> <span>{</span> <span>"composites"</span><span>:</span> <span>false</span> <span>}</span> <span>// 关闭MongoDB的composites分析</span>
    <span>}</span><span>,</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>然后再回来看检测就不会有这个提示了。</p>
<ul>
<li>参考：
<ul>
<li><a href="https://blog.51cto.com/u_15310543/4753519" target="_blank" rel="noopener noreferrer">https://blog.51cto.com/u_15310543/4753519</a></li>
<li><a href="https://stackoverflow.com/questions/54548441/composite-literal-uses-unkeyed-fields" target="_blank" rel="noopener noreferrer">Composite literal uses unkeyed fields</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="http://t.eryajf.net/imgs/2022/01/d6fa4a9f2f285f91.png" type="image/png"/>
    </item>
    <item>
      <title>06.golang使用$in或$nin查询MongoDB是否在数组内的数据</title>
      <link>https://bytecodes.tech/language/go/04.skills/06.golang%E4%BD%BF%E7%94%A8$in%E6%88%96$nin%E6%9F%A5%E8%AF%A2MongoDB%E6%98%AF%E5%90%A6%E5%9C%A8%E6%95%B0%E7%BB%84%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE.html</link>
      <guid>https://bytecodes.tech/language/go/04.skills/06.golang%E4%BD%BF%E7%94%A8$in%E6%88%96$nin%E6%9F%A5%E8%AF%A2MongoDB%E6%98%AF%E5%90%A6%E5%9C%A8%E6%95%B0%E7%BB%84%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE.html</guid>
      <source url="https://bytecodes.tech/rss.xml">06.golang使用$in或$nin查询MongoDB是否在数组内的数据</source>
      <pubDate>Fri, 06 Jan 2023 14:36:39 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_06-golang使用-in或-nin查询mongodb是否在数组内的数据" tabindex="-1"> 06.golang使用$in或$nin查询MongoDB是否在数组内的数据</h1>
<h2 id="前言" tabindex="-1"> 前言</h2>
<p>开发cmdb系统的时候，有一个场景是A对象数据关联B对象的数据，此时有一个接口需要透出已经在(或者不在)A对象某条数据关联列表的B对象的数据。</p>
<p>因为两边都是一个列表对象，如果单纯使用代码的思路来解决，大概会是下边这样：</p>
<ol>
<li>首先查询A对象这条数，能够拿到关联的B对象的数据ID。</li>
<li>然后查询B对象对应的所有数据，遍历这数据，判断是否已经在A绑定的列表中。</li>
</ol>
<p>这个思路虽然能够解题，但是不够优雅，后来看到MongoDB有一个<code>$in</code>和<code>$nin</code>的方法，能够很方便的满足这个需求。</p>
<ul>
<li><code>$in</code>:相当于关系型数据库中的<code>in()</code>查询，但<code>$in</code>操作符指定查询对象是一个数组。</li>
<li><code>$nin</code>:与<code>$in</code>一样，只不过是取反的意思。</li>
</ul>
<h2 id="实践" tabindex="-1"> 实践</h2>
<h3 id="原始语句" tabindex="-1"> 原始语句</h3>
<p>首先准备三条B对象的数据：</p>
<div><pre><code>db<span>.</span>users<span>.</span><span>insert</span><span>(</span><span>[</span>{<span>"name"</span>:<span>"aaa"</span><span>,</span><span>"age"</span>:<span>20</span>}<span>,</span>{<span>"name"</span>:<span>"bbb"</span><span>,</span><span>"age"</span>:<span>2</span>}<span>,</span>{<span>"name"</span>:<span>"ccc"</span><span>,</span><span>"age"</span>:<span>30</span>}<span>]</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>插入之后三条数据如下：</p>
<div><pre><code><span>/* 1 */</span>
<span>{</span>
    <span>"_id"</span> <span>:</span> ObjectId(<span>"6219c18d6e5030b4a6caa42b"</span>)<span>,</span>
    <span>"name"</span> <span>:</span> <span>"aaa"</span><span>,</span>
    <span>"age"</span> <span>:</span> <span>20.0</span>
<span>}</span>

<span>/* 2 */</span>
<span>{</span>
    <span>"_id"</span> <span>:</span> ObjectId(<span>"6219c18d6e5030b4a6caa42c"</span>)<span>,</span>
    <span>"name"</span> <span>:</span> <span>"bbb"</span><span>,</span>
    <span>"age"</span> <span>:</span> <span>2.0</span>
<span>}</span>

<span>/* 3 */</span>
<span>{</span>
    <span>"_id"</span> <span>:</span> ObjectId(<span>"6219c2016e5030b4a6caa42d"</span>)<span>,</span>
    <span>"name"</span> <span>:</span> <span>"ccc"</span><span>,</span>
    <span>"age"</span> <span>:</span> <span>30.0</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后插入一条A对象的数据：</p>
<div><pre><code>db<span>.</span>groups<span>.</span><span>insert</span><span>(</span><span>[</span>{<span>"name"</span>:<span>"ops"</span><span>,</span><span>"nick_name"</span>:<span>"运维"</span><span>,</span><span>"users"</span>:<span>[</span><span>]</span>}<span>]</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>输入插入之后如下：</p>
<div><pre><code><span>/* 1 */</span>
<span>{</span>
    <span>"_id"</span> <span>:</span> ObjectId(<span>"6219c27c6e5030b4a6caa42e"</span>)<span>,</span>
    <span>"name"</span> <span>:</span> <span>"ops"</span><span>,</span>
    <span>"nick_name"</span> <span>:</span> <span>"运维"</span><span>,</span>
    <span>"users"</span> <span>:</span> <span>[</span><span>]</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个时候我们可以看到在ops组里的用户为空，那么在我们将用户往组里添加的时候，需要获取到不在这个组内的用户，可以使用如下语句：</p>
<div><pre><code>$ db<span>.</span>getCollection<span>(</span><span>'users'</span><span>)</span><span>.</span>find<span>(</span>{<span>"_id"</span>: {<span>"$nin"</span>: <span>[</span><span>]</span>}}<span>)</span>

<span>/* 1 */</span>
{
    <span>"_id"</span> : ObjectId<span>(</span><span>"6219c18d6e5030b4a6caa42b"</span><span>)</span><span>,</span>
    <span>"name"</span> : <span>"aaa"</span><span>,</span>
    <span>"age"</span> : <span>20.0</span>
}

<span>/* 2 */</span>
{
    <span>"_id"</span> : ObjectId<span>(</span><span>"6219c18d6e5030b4a6caa42c"</span><span>)</span><span>,</span>
    <span>"name"</span> : <span>"bbb"</span><span>,</span>
    <span>"age"</span> : <span>2.0</span>
}

<span>/* 3 */</span>
{
    <span>"_id"</span> : ObjectId<span>(</span><span>"6219c2016e5030b4a6caa42d"</span><span>)</span><span>,</span>
    <span>"name"</span> : <span>"ccc"</span><span>,</span>
    <span>"age"</span> : <span>30.0</span>
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>同理如果直接将$nin改掉，则可以看到获取到的数据为空：</p>
<div><pre><code>$ db<span>.</span>getCollection<span>(</span><span>'users'</span><span>)</span><span>.</span>find<span>(</span>{<span>"_id"</span>: {<span>"$in"</span>: <span>[</span><span>]</span>}}<span>)</span>
Fetched <span>0</span> record<span>(</span>s<span>)</span> <span>in</span> <span>3</span>ms
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h3 id="golang代码" tabindex="-1"> golang代码</h3>
<p>接着我们将如上的查询转换成golang代码，这里仅展示主要查询的思路代码：</p>
<div><pre><code><span>type</span> Group <span>struct</span> <span>{</span>
 Name     <span>string</span>   <span>`json:"name" bson:"name"`</span>
 NickName <span>string</span>   <span>`json:"nick_name" bson:"nick_name"`</span>
 Users    <span>[</span><span>]</span><span>string</span> <span>`json:"users" bson:"users"`</span>
<span>}</span>

<span>type</span> User <span>struct</span> <span>{</span>
 Name <span>string</span> <span>`json:"name" bson:"name"`</span>
 Age  <span>int</span>    <span>`json:"age" bson:"age"`</span>
<span>}</span>

<span>func</span> <span>FindTest</span><span>(</span><span>)</span> <span>{</span>
 <span>var</span> group Group
 table <span>:=</span> DB<span>.</span><span>Collection</span><span>(</span><span>"groups"</span><span>)</span>
 res <span>:=</span> table<span>.</span><span>FindOne</span><span>(</span>ctx<span>,</span> bson<span>.</span>M<span>{</span><span>"name"</span><span>:</span> <span>"ops"</span><span>}</span><span>)</span>
 <span>if</span> err <span>:=</span> res<span>.</span><span>Err</span><span>(</span><span>)</span><span>;</span> err <span>!=</span> <span>nil</span> <span>{</span>
  fmt<span>.</span><span>Printf</span><span>(</span><span>"find data failed: %v\n"</span><span>,</span> err<span>)</span>
 <span>}</span>
 <span>if</span> err <span>:=</span> res<span>.</span><span>Decode</span><span>(</span><span>&amp;</span>group<span>)</span><span>;</span> err <span>!=</span> <span>nil</span> <span>{</span>
  fmt<span>.</span><span>Printf</span><span>(</span><span>"decode data failed: %v\n"</span><span>,</span> err<span>)</span>
 <span>}</span>

 <span>var</span> alreadyLinks <span>[</span><span>]</span>primitive<span>.</span>ObjectID
 <span>for</span> <span>_</span><span>,</span> v <span>:=</span> <span>range</span> group<span>.</span>Users <span>{</span>
  objid<span>,</span> err <span>:=</span> primitive<span>.</span><span>ObjectIDFromHex</span><span>(</span>v<span>)</span>
  <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
   fmt<span>.</span><span>Printf</span><span>(</span><span>"%v\n"</span><span>,</span> err<span>)</span>
  <span>}</span>
  alreadyLinks <span>=</span> <span>append</span><span>(</span>alreadyLinks<span>,</span> objid<span>)</span>
 <span>}</span>

 filter <span>:=</span> bson<span>.</span>D<span>{</span><span>}</span>
 filter <span>=</span> <span>append</span><span>(</span>filter<span>,</span> bson<span>.</span>E<span>{</span>Key<span>:</span> <span>"_id"</span><span>,</span> Value<span>:</span> bson<span>.</span>M<span>{</span><span>"$in"</span><span>:</span> alreadyLinks<span>}</span><span>}</span><span>)</span>
 users<span>,</span> err <span>:=</span> <span>ListUser</span><span>(</span>filter<span>,</span> options<span>.</span>FindOptions<span>{</span><span>}</span><span>)</span>
 <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
  fmt<span>.</span><span>Printf</span><span>(</span><span>"get data failed: %v\n"</span><span>,</span> err<span>)</span>
 <span>}</span>
 <span>for</span> <span>_</span><span>,</span> v <span>:=</span> <span>range</span> users <span>{</span>
  fmt<span>.</span><span>Printf</span><span>(</span><span>"用户名: %v 年龄: %v\n"</span><span>,</span> v<span>.</span>Name<span>,</span> v<span>.</span>Age<span>)</span>
 <span>}</span>
<span>}</span>

<span>// ListUser 获取用户列表</span>
<span>func</span> <span>ListUser</span><span>(</span>filter bson<span>.</span>D<span>,</span> options options<span>.</span>FindOptions<span>)</span> <span>(</span><span>[</span><span>]</span><span>*</span>User<span>,</span> <span>error</span><span>)</span> <span>{</span>
 table <span>:=</span> DB<span>.</span><span>Collection</span><span>(</span><span>"users"</span><span>)</span>
 cus<span>,</span> err <span>:=</span> table<span>.</span><span>Find</span><span>(</span>ctx<span>,</span> filter<span>,</span> <span>&amp;</span>options<span>)</span>
 <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
  fmt<span>.</span><span>Printf</span><span>(</span><span>"find data failed: %v\n"</span><span>,</span> err<span>)</span>
 <span>}</span>
 <span>defer</span> <span>func</span><span>(</span>cus <span>*</span>mongo<span>.</span>Cursor<span>,</span> ctx context<span>.</span>Context<span>)</span> <span>{</span>
  err <span>:=</span> cus<span>.</span><span>Close</span><span>(</span>ctx<span>)</span>
  <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
   <span>return</span>
  <span>}</span>
 <span>}</span><span>(</span>cus<span>,</span> ctx<span>)</span>

 list <span>:=</span> <span>make</span><span>(</span><span>[</span><span>]</span><span>*</span>User<span>,</span> <span>0</span><span>)</span>
 <span>for</span> cus<span>.</span><span>Next</span><span>(</span>ctx<span>)</span> <span>{</span>
  user <span>:=</span> <span>new</span><span>(</span>User<span>)</span>
  err <span>:=</span> cus<span>.</span><span>Decode</span><span>(</span><span>&amp;</span>user<span>)</span>
  <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
   fmt<span>.</span><span>Printf</span><span>(</span><span>"decode data failed: %v\n"</span><span>,</span> err<span>)</span>
  <span>}</span>
  list <span>=</span> <span>append</span><span>(</span>list<span>,</span> user<span>)</span>
 <span>}</span>

 <span>return</span> list<span>,</span> <span>nil</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>此时运行代码，会报一个错误：<code>find data failed: (BadValue) $nin needs an array</code>。</p>
<p>当我们使用这个方法的时候，MongoDB要求数组里边至少有一个值，如果没有值，则可以塞一个空的值进去用于聚合，因此加入下边的判断代码：</p>
<div><pre><code> <span>//如果数组为空,则需要为其填充一个空的ID,否则会报错  $nin needs an array</span>
 <span>if</span> <span>len</span><span>(</span>alreadyLinks<span>)</span> <span>==</span> <span>0</span> <span>{</span> 
  alreadyLinks <span>=</span> <span>append</span><span>(</span>alreadyLinks<span>,</span> primitive<span>.</span>NilObjectID<span>)</span>
 <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>此时再次运行，可以得到如下结果：</p>
<div><pre><code>$ go run main.go
用户名：aaa 年龄：20
用户名：bbb 年龄：2
用户名：ccc 年龄：30
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>可以看到跟我们用sql查询的结果是一致的。</p>
<h3 id="再验证" tabindex="-1"> 再验证</h3>
<p>此时我们将aaa用户的ID塞进ops组内，数据如下：</p>
<div><pre><code>$ db<span>.</span>getCollection<span>(</span><span>'groups'</span><span>)</span><span>.</span>find<span>(</span>{}<span>)</span>
<span>/* 1 */</span>
{
    <span>"_id"</span> : ObjectId<span>(</span><span>"6219c2c46e5030b4a6caa42f"</span><span>)</span><span>,</span>
    <span>"name"</span> : <span>"ops"</span><span>,</span>
    <span>"nick_name"</span> : <span>"运维"</span><span>,</span>
    <span>"users"</span> : <span>[</span> 
        <span>"6219c18d6e5030b4a6caa42b"</span>
    <span>]</span>
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后查询已经在组内的用户：</p>
<div><pre><code>$ db<span>.</span>getCollection<span>(</span><span>'users'</span><span>)</span><span>.</span>find<span>(</span>{<span>"_id"</span>: {<span>"$in"</span>: <span>[</span>ObjectId<span>(</span><span>"6219c18d6e5030b4a6caa42b"</span><span>)</span><span>]</span>}}<span>)</span>

<span>/* 1 */</span>
{
    <span>"_id"</span> : ObjectId<span>(</span><span>"6219c18d6e5030b4a6caa42b"</span><span>)</span><span>,</span>
    <span>"name"</span> : <span>"aaa"</span><span>,</span>
    <span>"age"</span> : <span>20.0</span>
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>查询不在组内的用户：</p>
<div><pre><code>$ db<span>.</span>getCollection<span>(</span><span>'users'</span><span>)</span><span>.</span>find<span>(</span>{<span>"_id"</span>: {<span>"$nin"</span>: <span>[</span>ObjectId<span>(</span><span>"6219c18d6e5030b4a6caa42b"</span><span>)</span><span>]</span>}}<span>)</span>

<span>/* 1 */</span>
{
    <span>"_id"</span> : ObjectId<span>(</span><span>"6219c18d6e5030b4a6caa42c"</span><span>)</span><span>,</span>
    <span>"name"</span> : <span>"bbb"</span><span>,</span>
    <span>"age"</span> : <span>2.0</span>
}

<span>/* 2 */</span>
{
    <span>"_id"</span> : ObjectId<span>(</span><span>"6219c2016e5030b4a6caa42d"</span><span>)</span><span>,</span>
    <span>"name"</span> : <span>"ccc"</span><span>,</span>
    <span>"age"</span> : <span>30.0</span>
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>此时运行我们的代码，可以看到相同的想要的结果：</p>
<div><pre><code>$ go run main.go
用户名: bbb 年龄: <span>2</span>
用户名: ccc 年龄: <span>30</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这个例子就是结合MongoDB提供的方法，来解决实际场景中的问题的，能够更加优雅地解决问题，也能节约一定的资源开销。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>