<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://bytecodes.tech/rss.xml" rel="self" type="application/rss+xml"/>
    <title>凤凰涅槃进阶之路</title>
    <link>https://bytecodes.tech/</link>
    <description>开源工具、效率方法、心理学探索的自我提升笔记，记录并输出一切能让自己提升的知识。</description>
    <language>zh-CN</language>
    <pubDate>Mon, 26 Dec 2022 09:02:34 GMT</pubDate>
    <lastBuildDate>Mon, 26 Dec 2022 09:02:34 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>go</category>
    <category>rust</category>
    <category>区块链</category>
    <category>区块链学习</category>
    <item>
      <title>go</title>
      <link>https://bytecodes.tech/language/go/</link>
      <guid>https://bytecodes.tech/language/go/</guid>
      <source url="https://bytecodes.tech/rss.xml">go</source>
      <category>go</category>
      <pubDate>Mon, 26 Dec 2022 08:43:06 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="目录" tabindex="-1"> 目录</h1>
<p>TODO</p>
]]></content:encoded>
    </item>
    <item>
      <title>rust</title>
      <link>https://bytecodes.tech/language/rust/</link>
      <guid>https://bytecodes.tech/language/rust/</guid>
      <source url="https://bytecodes.tech/rss.xml">rust</source>
      <category>rust</category>
      <pubDate>Mon, 26 Dec 2022 08:43:06 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="目录" tabindex="-1"> 目录</h1>
<p>TODO</p>
]]></content:encoded>
    </item>
    <item>
      <title>区块链与随机数</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/Block_chain_and_random_Numbers.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/Block_chain_and_random_Numbers.html</guid>
      <source url="https://bytecodes.tech/rss.xml">区块链与随机数</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="计算机的随机数" tabindex="-1"> 计算机的随机数</h2>
<p>理论上计算机是无法真正生成随机数的，给它相同的输入，它都应该是同样的输出。<br>
为了生成随机数(Random numbers)，计算机将依赖于 seed (种子)：用于获取输出的输入 (input)。<br>
种子可以是:<br>
<strong>屏幕上鼠标光标的移动的像素位置</strong> (在500万像素屏幕中，需要重复完全一样的鼠标运动轨迹，这种任务对于人类完成度几乎是不可能的);
大气的噪音、宇宙背景辐射、放射物的衰变期、量子塌缩现象熔岩灯。<br>
在种子之上，计算机将执行数学运算并最终得出一个人类无法预测的数字。</p>
<blockquote>
<p><a href="https://www.bitaddress.org/" target="_blank" rel="noopener noreferrer">BitAddress</a> 一个开源的比特币钱包工具，他的 seed 值就是采集鼠标轨迹来完成<br>
<a href="https://www.random.org/" target="_blank" rel="noopener noreferrer">random.org</a>大气噪音生成随机数,他用录音设备获得大气中的声波，再检测其细微变化作为生成随机数的熵源<br>
<a href="https://gizmodo.com/one-of-the-secrets-guarding-the-secure-internet-is-a-wa-1820188866" target="_blank" rel="noopener noreferrer">Cloudflare</a> 内部不定形状的蜡滴的缓慢流动。<a href="https://www.cloudflare.com/zh-cn/learning/ssl/lava-lamp-encryption/" target="_blank" rel="noopener noreferrer">Cloudflare</a> 利用摄像头监视熔岩灯，拍摄视频和照片，然后将其转变成无法预测的随机比特流，再用它生成密钥</p>
</blockquote>
<p>区块链中没有鼠标、传感器或者运动比赛结果预测。更重要的是，即使一个节点到达某个随机数，但该随机数必须与区块链的所有其他节点的随机数相同(必须产生具有一致性的随机性)，不然无法验证。</p>
<h2 id="区块链中的随机数" tabindex="-1"> 区块链中的随机数</h2>
<blockquote>
<p>区块链中随机数的应用场景：</p>
<ul>
<li>公平的决定出块权力，维持一致性共识。部分PoW与PoS机制下，依靠随机数选定出块者或者出块组的，包括DPoS机制下的循环出块的顺序，也是依靠随机数决定</li>
<li>私钥的生成。目前私钥只要由各钱包自定随机数方法生成，存在较大安全隐患</li>
<li>链上应用的随机数源。保证博彩、游戏、抽奖、分发、调查等应用的公平公正，此类容易被黑客攻击</li>
<li>数据加密。链上数据因为是公开审查的，需要强度较高的加密，通过足够强的随机数确保链上数据的隐私与安全</li>
</ul>
</blockquote>
<h3 id="区块哈希" tabindex="-1"> 区块哈希</h3>
<p>依赖区块哈希 (block hash) 来处理随机性。因为哈希值是未知的、随机的，但在所有节点上都是相同的，所以对于基本可证明公平的赌博来说，哈希值可以作为随机性的来源。</p>
<p>但是如果操作区块 hash 的利益大于旷工挖到区块后的奖励，那么旷工完全就有动机进行恶意行为。更严重的是，在权益证明 (PoS) 系统中，由于生成一个区块几乎不需要计算时间或能量，矿工 (验证者) 可以很容易地继续生成数千个区块，直到获得一个他们喜欢的哈希值，并将这个哈希值进行提交。<br>
这也适用于验证者的选择。如果当前负责生产某个区块的验证者能够通过某种方式进行操纵，使得该区块哈希成为一个能够再次选中该验证者 (或者由该验证控制的另一个验证者客户端) 的种子，使该验证者继续成为提议区块的验证者，那么该验证者就可以一直提议区块，将其他的验证者挡在主要的利润之外！</p>
<h3 id="可验证随机函数-vrf" tabindex="-1"> 可验证随机函数 VRF</h3>
<p>Verifiable Random Function</p>
<blockquote>
<p>生成一对公私钥，分别为pri_key和pub_key<br>
计算hash_value=VRF_HASH(pri_key, message)<br>
计算proof_value=VRF_PROOF(pri_key, message)<br>
现在将hash_value和proof_value提供给验证者<br>
验证者拿到hash_value和proof_value计算hash_value=VRF_P2H(proof_value)<br>
如果成功，则验证者计算VRF_VERIFY(pub_key, message, proof)<br>
如果返回true则表示验证通过，否则验证失败</p>
</blockquote>
<p>就是在不暴露私钥的情况下，验证hash_value和message是否匹配</p>
<h4 id="案例分析" tabindex="-1"> 案例分析</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s/6v-PCIEpspfUX8sqS6mq6w" target="_blank" rel="noopener noreferrer">可信预言机Truora VRF</a></li>
</ul>
<ul>
<li><a href="https://mp.weixin.qq.com/s/5ZYKv0BBX1j18H6AAePZaQ" target="_blank" rel="noopener noreferrer">可信预言机Truora</a></li>
<li><a href="https://truora.readthedocs.io/" target="_blank" rel="noopener noreferrer">Truora</a></li>
<li><a href="https://github.com/WeBankBlockchain/Truora-Service" target="_blank" rel="noopener noreferrer">Truora Github</a></li>
</ul>
<h3 id="eth2-0-方案-randao-vdf" tabindex="-1"> ETH2.0 方案 RANDAO + VDF</h3>
<p><strong>RANDAO</strong> 是一个基于以太坊的项目，可以理解是一个智能合约，简单理解一下：当用户通过储存质押（m个ETH）成为验证者之，该用户将选择一个由自己选择的随机数。当需要为某个区块公布其随机数时，将系统中所有随机数加起来就可以得到一个全新的随机数。<br>
但即使在这种情况下，最后公布的数字对最终的随机数也会有一定程度的影响。房间里的最后一个人会记住之前每个人公布的数字，如此一来，就可以知道加上 (或者不加上) 他提供的数字之后的最终随机数的结果。<br>
这里只是快速了解<code>randao</code>项目，他其中还包含有经济惩罚等的各种措施保证，更具体的设计可以找白皮书。</p>
<p><strong>VDF</strong> (可验证延迟函数) Verifiable Delay Function<br>
它具有几个特性：</p>
<ul>
<li>串行性，抗矿池，任务不可分配。矿池将任务合理的分配给每个加入矿池的旷工，以达到并行计算的能力，大大提高解题速度。而VDF，如果要计算出第三级结果，那就必须先计算出第一级和第二级的结果，无法在多台计算机上并行地进行此计算，因为每个新的输入都依赖于之前的输出。</li>
<li>计算难度高，结果有延迟，预先确定的计算时间。每个输出都需要预先确定的计算时间。以太坊2.0阶段，这个 VDF 被定义为102分钟，通过引入这种延迟，并使计算的时间要长于验证者可以通过影响某个随机数而获得利益的时间，我们就可以消除最后一级的随机性偏差。</li>
<li>验证简单。VDF的运行过程可以是困难且耗时的，但是检验结果时是足够快的</li>
</ul>
<h3 id="其他随机数项目" tabindex="-1"> 其他随机数项目</h3>
<ul>
<li>Algorand</li>
</ul>
<ul>
<li>Cardano</li>
<li>Dfinity</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>区块链介绍</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/Block_chain_concept.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/Block_chain_concept.html</guid>
      <source url="https://bytecodes.tech/rss.xml">区块链介绍</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<p>区块链是由多个学科交叉组合形成的一门技术。
区块链是由分布式架构与分布式存储、块链式数据结构、点对点网络、共识算法、密码学算法、博弈论、智能合约等多种信息技术共同组成的整体解决方案。</p>
<p>区块链是<strong>最慢的分布式数据库</strong>？</p>
<blockquote>
<p>像比特币的TPS就是7（笔/秒），以太坊大概是10+。联盟链（FISCO BCOS）单链TPS目前是两万左右。</p>
</blockquote>
<p>分布式这么慢，它还有什么<strong>价值</strong>？</p>
<blockquote>
<p>它的价值就在于<strong>多方协作</strong>。</p>
</blockquote>
<p>区块链的灵魂与核心是什么？</p>
<blockquote>
<p><strong>共识</strong>。没有多方智能合约与共识算法来达成透明、高效、可信的合作，那它就只是个分布式数据库。那多方合作是为了什么？肯定是为了资产交易，数据分享。计算和数据共享基于智能合约透明的规则，大家共同执行，这就是区块链。</p>
</blockquote>
<h2 id="基础名词" tabindex="-1"> 基础名词</h2>
<h3 id="钱包" tabindex="-1"> 钱包</h3>
<p>钱包(Wallet)是一个管理私钥的工具</p>
<h4 id="冷钱包" tabindex="-1"> 冷钱包</h4>
<p>冷钱包(Cold Wallet)是一种脱离网络连接的离线钱包，将数字货币进行离线储存的钱包。使用者在一台离线的钱包上面生成数字货币地址和私钥，再将其保存起来。冷钱包是在不需要任何网络的情况下进行数字货币的储存，因此黑客是很难进入钱包获得私钥的，但它也不是绝对安全的，随机数不安全也会导致这个冷钱包不安全，此外硬件损坏、丢失也有可能造成数字货币的损失，因此需要做好密钥的备份。<br>
也成硬件钱包。可以简单理解成一个usb硬盘。</p>
<h4 id="热钱包" tabindex="-1"> 热钱包</h4>
<p>热钱包(Hot Wallet)是一种需要网络连接的在线钱包，在使用上更加方便。
但由于热钱包一般需要在线使用，个人的电子设备有可能因误点钓鱼网站被黑客盗取钱包文件、捕获钱包密码或是破解加密私钥，而部分中心化管理钱包也并非绝对安全。<br>
具有代表的交易所中心化钱包（甚至不需要你管理私钥）,被认为相对安全的开源产品Metamask</p>
<h3 id="节点" tabindex="-1"> 节点</h3>
<p>由于区块链是去中心化的分布式数据库，是由千千万万个“小服务器”组成。区块链网络中的每一个节点，就相当于存储所有区块数据的每一台电脑或者服务器。
所有新区块的生产，以及交易的验证与记帐，并将其广播给全网同步，都由节点来完成。<br>
节点分为“全节点”和“轻节点”，全节点就是拥有全网所有的交易数据的节点，那么轻节点就是只拥有和自己相关的交易数据节点（手机钱包APP）。由于每一个全节点都保留着全网数据，这意味着，其中一个节点出现问题，整个区块链网络世界也依旧能够安全运行，这也是去中心化的魅力所在。</p>
<h3 id="智能合约" tabindex="-1"> 智能合约</h3>
<p>智能合约本质可以说是一段运行在区块链网络中的代码，它以计算机指令的方式实现了传统合约的自动化处理，完成用户所赋予的业务逻辑<br>
早在 1995 年就由跨领域法律学者 Nick Szabo 提出：智能合约是一套以数字形式定义的承诺(Promises)，包括合约参与方可以在上面执行这些承诺的协议</p>
<h3 id="分叉" tabindex="-1"> 分叉</h3>
<p>分叉一般由区块链系统升级导致</p>
<h4 id="软分叉" tabindex="-1"> 软分叉</h4>
<p>软分叉(Soft-fork)更多情况下是一种协议升级，当新共识规则发布后，没有升级的旧节点并不会意识到代码已经发生改变，而继续生产不合法的区块，就会产生临时性分叉，但新节点可以兼容旧节点，即新旧节点始终在同一条链上工作。</p>
<h4 id="硬分叉" tabindex="-1"> 硬分叉</h4>
<p>硬分叉(Hard-fork)是区块链发生永久性分歧，在新共识规则发布后，已经升级的节点无法验证未升级节点产生的区块，未升级节点也无法验证已经升级的节点产生的区块，即新旧节点互不兼容，通常硬分叉就会发生，原有正常的一条链被分成了两条链（已升级的一条链和未升级的一条链，且这两条链互不兼容）。</p>
<h3 id="tps" tabindex="-1"> TPS</h3>
<blockquote>
<p>系统每秒钟能够处理的业务数量<br>
系统的吞吐量<br>
TPS = 并发数/平均响应时间</p>
</blockquote>
<blockquote>
<p>公链的TPS计算公式为：
TPS = 一个区块内包含的交易数量 / 区块产生时间 = 一个区块内包含的交易数量 / （共识算法运行的时间 + 广播并验证打包的时间 ）<br>
由此算式我们可知，要想提高TPS，有两种途径：<br>
1.对区块进行扩容，这样每个区块包含的交易数量就会提高；<br>
2.缩短区块产生的时间。</p>
</blockquote>
<ul>
<li>比特币: 7</li>
<li>以太坊: 10-20</li>
<li>EOS: 3000-4000 但宣称可以到100万</li>
</ul>
<blockquote>
<p>支付宝双十一 20W+</p>
</blockquote>
<h2 id="共识" tabindex="-1"> 共识</h2>
<p>区块链系统本身作为一个超大规模的分布式系统，但又与传统的分布式系统存在明显区别。由于它不依赖于任何一个中央权威，系统建立在去中心化的点对点网络基础之上，因此分散的节点需要就交易的有效与否达成一致，这就是共识算法发挥作用的地方，即确保所有节点都遵守协议规则并保证所有交易都以可靠的方式进行。由共识算法实现在分散的节点间对交易的处理顺序达成一致，这是共识算法在区块链系统中起到的最主要作用。</p>
<h3 id="共识算法" tabindex="-1"> 共识算法</h3>
<ul>
<li>PBFT(Practical Byzantine Fault Tolerance) 拜占庭容错技术
<blockquote>
<p>应用代表: 联盟链. fabric; fisco-bcos;</p>
</blockquote>
</li>
<li>POW(Proof of Work) 工作量证明
<blockquote>
<p>Bitcoin(比特币); Ethereum(以太访)</p>
</blockquote>
</li>
<li>POS(Proof of Stake) 股权证明
<blockquote>
<p>Peercoin(点点币); 日后以太坊逐渐替换使用</p>
</blockquote>
</li>
<li>DPOS(Delegated Proof of Stake) 委任权益证明
<blockquote>
<p>EOS; Bitshare(比特股)</p>
</blockquote>
</li>
<li>Paxos Raft</li>
<li>Ripple 瑞波</li>
</ul>
<h2 id="隐私保护" tabindex="-1"> 隐私保护</h2>
<p>数据脱敏，业务隔离,系统物理隔离等方式控制数据分发范围
或引入</p>
<h3 id="隐私保护算法" tabindex="-1"> 隐私保护算法</h3>
<ul>
<li>
<p>同态加密</p>
<blockquote>
<p>无需对加密数据进行提前解密就可以执行计算的方法。通过使用同态加密技术在区块链上存储数据可以达到一种完美的平衡，不会对区块链属性造成任何重大的改变。也就是说，区块链仍旧是公有区块链，但区块链上的数据将会被加密。</p>
</blockquote>
<blockquote>
<p>现在同态一般是用于加法计算，乘法计算的速度比较慢。另外，同态的数据量如果是比较大，那么其数据膨胀和运算速度降低就会非常明显</p>
</blockquote>
</li>
<li>
<p>零知识证明</p>
<blockquote>
<p>一种密码学技术，是一种在无需泄露数据本身情况下证明某些数据运算的一种零知识证明，允许两方（证明者和验证者）来证明某个提议是真实的，而且无需泄露除了它是真实的之外的任何信息。在密码学货币和区块链中，这通常是指交易信息数据。</p>
</blockquote>
<blockquote>
<p>重点在于证明一个事物的有效性，而不在于运算，但用户的账目、风控模型都涉及计算。</p>
</blockquote>
</li>
<li>
<p>群签名</p>
<blockquote>
<p>只有群中成员能够代表群体签名（群特性）；接收者可以用公钥验证群签名（验证简单性）；接收者不能知道由群体中哪个成员所签（无条件匿名保护）；发生争议时，群体中的成员或可信赖机构可以识别签名者（可追查性）。</p>
</blockquote>
</li>
<li>
<p>环签名</p>
<blockquote>
<p>环中一个成员利用他的私钥和其他成员的公钥进行签名，但却不需要征得其他成员的允许，而验证者只知道签名来自这个环，但不知到谁是真正的签名者。这个方式解决了对签名者完全匿名的问题，允许一个成员代表一组人进行签名而不泄漏签名者的信息。</p>
</blockquote>
<blockquote>
<p>群/环签名，它很轻也有不错的性能，但主要面向身份，不面向数据。</p>
</blockquote>
</li>
<li>
<p>盲签名</p>
<blockquote>
<p>盲签名因签名的人看不到所签署文件的具体内容而闻名，它有两个显著的特点：一是签名者对消息的内容是不可见的 ;二是签名被公开后，签名者不能追踪签名。</p>
</blockquote>
</li>
<li>
<p>门限签名</p>
<ul>
<li>基于 ECDSA 的门限签名方案</li>
<li>基于 BLS 的门限签名方案</li>
<li>基于 RSA 的 Shoup 门限签名方案</li>
<li>基于 Elgamal 的 Harn 门限签名方案</li>
</ul>
</li>
<li>
<p>混币原理</p>
</li>
<li>
<p>MPC</p>
<blockquote>
<p>Secure Multi-Party Computation Secure Multi-Party Computation</p>
</blockquote>
<blockquote>
<p>安全多方计算是可以用于联合计算，但现在它处在从两方向多方发展的阶段，多方安全解决起来比较困难，牵涉成本、计算量、复杂度。</p>
</blockquote>
</li>
<li>
<p>HMAC</p>
<blockquote>
<p>Hash-based Message Authentication Code 基于 Hash 的消息认证码</p>
</blockquote>
</li>
</ul>
<h2 id="区块链产品" tabindex="-1"> 区块链产品</h2>
<h3 id="ethereum-eth" tabindex="-1"> Ethereum (ETH)</h3>
<ul>
<li>EIP (Ethereum Improvement Protocol)</li>
</ul>
<blockquote>
<p>以太坊改进方案。用以改进方案中包括协议规范和合约标准</p>
</blockquote>
<ul>
<li>ERC (Ethereum Request for Comment)</li>
</ul>
<blockquote>
<p>Ethereum版的意见征求稿，用以记录以太坊上应用级的各种开发标准和协议(application-level standards and conventions)<br>
<a href="https://github.com/ethereum/EIPs" target="_blank" rel="noopener noreferrer">EIP</a>通过后就是ERC了</p>
</blockquote>
<ul>
<li>最典型的Token标准(<a href="https://eips.ethereum.org/EIPS/eip-20" target="_blank" rel="noopener noreferrer">ERC20</a>, <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md" target="_blank" rel="noopener noreferrer">ERC721</a>, <a href="https://github.com/ethereum/EIPs/issues/223" target="_blank" rel="noopener noreferrer">ERC223</a>)</li>
<li>名字注册(ERC26, ERC13)</li>
<li>URI范式(ERC67)</li>
<li>Library/Package格式(EIP82)</li>
<li>钱包格式(EIP75,EIP85)</li>
</ul>
<h2 id="攻击" tabindex="-1"> 攻击</h2>
<h3 id="恶意挖矿攻击" tabindex="-1"> 恶意挖矿攻击</h3>
<p>恶意挖矿攻击(Cryptojacking)是一种恶意行为，指未经授权的情况下劫持用户设备挖掘加密货币。通常，攻击者会劫持受害者设备(个人 PC 或服务器)的处理能力和带宽，由于加密货币挖掘需要大量算力，攻击者会尝试同时感染多个设备，这样他们能够收集到足够的算力来执行这种低风险和低成本的挖矿活动。</p>
<h3 id="无利益攻击" tabindex="-1"> 无利益攻击</h3>
<p>当PoS共识系统出现分叉(Fork)时，出块节点可以在“不受任何损失”的前提下，同时在两个分叉上出块；无论哪一个分叉后面被公认为主链，该节点都可以获得“所有收益”且不会有任何成本损失。这就很容易给某些节点一种动力去产生新的分叉，支持或发起不合法交易，其他逐利的出块节点会同时在多条链(窗口)上排队出块支持新的分叉。随着时间的推移，分叉越来越多，非法交易，作恶猖狂</p>
<h3 id="双花攻击" tabindex="-1"> 双花攻击</h3>
<p>双花攻击(Double Spend Attack)即一笔钱花了两次，双重支付，利用货币的数字特性两次或多次使用“同一笔钱”完成支付。双花不会产生新的 Token，但能把自己花出去的钱重新拿回来。简单说就是，攻击者将一笔 Token 转到另外一个地址，通常是转到交易所进行套现，然后再利用一些攻击手法对转账交易进行回滚。</p>
<h4 id="控制矿工费" tabindex="-1"> 控制矿工费</h4>
<p>Race Attack 这种攻击主要通过控制矿工费来实现双花。攻击者同时向网络中发送两笔交易，一笔交易发给自己(为了提高攻击成功的概率，他给这笔交易增加了足够的矿工费)，一笔交易发给商家。由于发送给自己的交易中含有较高的手续费，会被矿工优先打包进区块的概率比较高。这时候这笔交易就会先于发给商家的那笔交易，那么发给商家的交易就会被回滚。对于攻击者来说，通过控制矿工费，就实现了同一笔 Token 的“双花”。</p>
<h4 id="控制区块的广播时间" tabindex="-1"> 控制区块的广播时间</h4>
<p>Finney Attack  攻击者主要通过控制区块的广播时间来实现双花，攻击对象针对的是接受 0 确认的商家。假设攻击者挖到区块，该区块中包含着一个交易，即 A 向 B 转了一定数量的 Token，其中 A 和 B 都是攻击者的地址。但是攻击者并不广播这个区块，而是立即找到一个愿意接受 0 确认交易的商家向他购买一个物品，向商家发一笔交易，用 A 向商家的地址 C 支付，发给商家的交易广播出去后，攻击者再把自己之前挖到的区块广播出去，由于发给自己的交易先于发给商家的交易，对于攻击者来说，通过控制区块的广播时间，就实现了同一笔 Token 的“双花”。</p>
<h4 id="一次确认攻击" tabindex="-1"> 一次确认攻击</h4>
<p>Vector76 Attack 又称“一次确认攻击”，也就是交易确认一次后仍然可以回滚，是 Finney Attack 和 Race Attack 的组合。<br>
攻击者创建两个节点，节点 A 连接到商家节点，节点 B 连接到区块链网络中的其他节点。接着，攻击者用同一笔 Token 发起两笔交易，一笔交易发送给商家地址，我们称为交易 1；一笔交易发送给自己的钱包地址，我们称为交易 2。与上面说的 Race Attack 一样，攻击者对交易 2 添加了较高的矿工费从而提高了矿工的打包概率，此时，攻击者并没有把这两笔交易广播到网络中去。<br>
接着，攻击者开始在交易 1 所在的分支上进行挖矿，这条分支我们命名为分支 1。攻击者挖到区块后，并没有广播出去，而是同时做了两件事：在节点 A 上发送交易 1，在节点 B 上发送交易 2。<br>
由于节点 A 只连接了商家节点，所以当商家节点想把交易 1 传给其它对等节点时，连接了更多节点的节点 B，已经把交易 2 广播给了网络中的大部分节点。于是，从概率上来讲，交易 2 就更有可能被网络认定为是有效的，交易 1 被认定为无效。<br>
交易 2 被认为有效后，攻击者立即把自己之前在分支 1 上挖到的区块，广播到网络中。这时候，这个接受一次确认就支付的商家，会确认交易成功，然后攻击者就可以立即变现并转移资产。
同时，由于分支 2 连接的更多节点，所以矿工在这个分支上挖出了另一个区块，也就是分支 2 的链长大于分支 1 的链长。于是，分支 1 上的交易就会回滚，商家之前支付给攻击者的交易信息就会被清除，但是攻击者早已经取款，实现了双花。</p>
<h4 id="_51-攻击" tabindex="-1"> 51% 攻击</h4>
<p>攻击者占有超过全网 50% 的算力，在攻击者控制算力的这段时间，他可以创造一条高度大于原来链的新链。那么旧链中的交易会被回滚，攻击者可以使用同一笔 Token 发送一笔新的交易到新链上。</p>
<h3 id="异形攻击" tabindex="-1"> 异形攻击</h3>
<p>异形攻击(Alien Attack)实际上是一个所有公链都可能面临的问题，又称地址池污染，是指诱使同类链的节点互相侵入和污染的一种攻击手法，漏洞的主要原因是同类链系统在通信协议上没有对不同链的节点做识别。<br>
这种攻击在一些参考以太坊通信协议实现的公链上得到了复现：以太坊同类链，由于使用了兼容的握手协议，无法区分节点是否属于同个链，利用这一点，攻击者先对以太坊节点地址进行收集并进行恶意握手操作，通过跟节点握手达成污染地址池的目的，使得不同链的节点互相握手并把各自地址池里已知的节点推送给了对方，导致更多的节点互相污染，最终扩散致整个网络。遭受异形攻击的节点通常会通信性能下降，最终造成节点阻塞、主网异常等现象。相关公链需要注意持续保持主网健康状态监测，以免出现影响主网稳定的攻击事件出现。</p>
<h3 id="供应链攻击" tabindex="-1"> 供应链攻击</h3>
<p>供应链攻击(Supply Chain Attack)是一种非常可怕的攻击方式，防御上很难做到完美规避，由于现在的软件工程，各种包/模块的依赖十分频繁、常见，而开发者们很难做到一一检查，默认都过于信任市面上流通的包管理器，这就导致了供应链攻击几乎已经成为必选攻击之一。把这种攻击称成为供应链攻击，是为了形象说明这种攻击是一种依赖关系，一个链条，任意环节被感染都会导致链条之后的所有环节出问题。</p>
<h3 id="交易回滚攻击" tabindex="-1"> 交易回滚攻击</h3>
<p>交易回滚攻击(Roll Back Attack)，故名思义，指的是能对交易的状态进行回滚。回滚具体是什么意思呢？回滚具体指的是将已经发生的状态恢复成它未发生时候的样子。那么，交易回滚的意思就是将已经发生的交易变成未发生的状态。即攻击者本来已经发生了支付动作，但是通过某些手段，让转账流程发生错误，从而回滚整个交易流程，达到交易回滚的目的，这种攻击手法多发于区块链上的的智能合约游戏当中，当用户的下注动作和合约的开奖动作在一个交易内的时候，即内联交易。攻击者就可以通过交易发生时检测智能合约的某些状态，获知开奖信息，根据开奖信息选择是否对下注交易进行回滚。<br>
建议开发者们不要将用户的下注与开奖放在同一个交易内，防止攻击者通过检测智能合约中的开奖状态实现交易回滚攻击。</p>
<h3 id="交易排挤攻击" tabindex="-1"> 交易排挤攻击</h3>
<p>交易排挤攻击(Transaction Congestion Attack)是针对 EOS 上的使用 defer 进行开奖的游戏合约的一种攻击手法，攻击者可以通过某些手段，在游戏合约的 defer 开奖交易前发送大量的 defer 交易，恶意侵占区块内的 CPU 资源，使得智能合约内本应在指定区块内执行的 defer 开奖交易因资源不足无法执行，只能去到下一个区块才执行。由于很多 EOS 上的游戏智能合约使用区块信息作为智能合约本身的随机数，同一个 defer 开奖交易在不同区块内的执行结果是不一样的。通过这样的方式，攻击者在获知无法中奖的时候，就通过发送大量的 defer 交易，强行让智能合约重新开奖，从而达到攻击目的。<br>
建议智能合约开发者对在不同区块内执行结果不同的关键的操作不要采用 defer 交易的方式，降低合约被攻击的风险。</p>
<h3 id="随机数攻击" tabindex="-1"> 随机数攻击</h3>
<p>随机数攻击(Random Number Attack)，就是针对智能合约的随机数生成算法进行攻击，预测智能合约的随机数。目前区块链上很多游戏都是采用的链上信息（如区块时间，未来区块哈希等）作为游戏合约的随机数源，也称随机数种子。使用这种随机数种子生成的随机数被称为伪随机数。伪随机数不是真的随机数，存在被预测的可能。当使用可被预测的随机数种子生成随机数的时候，一旦随机数生成的算法被攻击者猜测到或通过逆向等其他方式拿到，攻击者就可以根据随机数的生成算法预测游戏即将出现的随机数，实现随机数预测，达到攻击目的。</p>
<h3 id="hard-fail状态攻击" tabindex="-1"> hard_fail状态攻击</h3>
<p>hard_fail是什么呢？简单来说就是出现错误但是没有使用错误处理器(error handler)处理错误，比方说使用onerror捕获处理，如果说没有onerror捕获，就会hard_fail。EOS 上的交易状态记录分为  executed,soft_fail, hard_fail, delayed 和 expired 这 5 种状态，通常在链上大部分人观察到的交易，都是 executed 的，或者 delayed 的，而没有失败的交易，这就导致大部分开发者误以为 EOS 链上没有失败的交易记录，从而忽略了对交易状态的检查。攻击者利用这个细节，针对链上游戏或交易所进行攻击，构造执行状态为hard_fail的交易，欺骗链上游戏或交易所进行假充值攻击，从而获利。<br>
在此提醒交易所和 EOS DApp游戏开发者在处理转账交易的时候需要严格校验交易状态，确保交易执行状态为 executed。</p>
<h3 id="重放攻击" tabindex="-1"> 重放攻击</h3>
<p>重放攻击(Replay Attack)，是针对区块链上的交易信息进行重放，一般来说，区块链为了保证不可篡改和防止双花攻击的发生，会对交易进行各种验证，包括交易的时间戳，nonce，交易 id 等，但是随着各种去中心化交易所的兴起，在智能合约中验证用户交易的场景越来越多。这种场景一般是需要用户对某一条消息进行签名后上传给智能合约，然后在合约内部进行验签。但由于用户的签名信息是会上链的，也就是说每个人都能拿到用户的签名信息，当在合约中校验用户签名的时候，如果被签名的消息不存在随着交易次数变化的变量，如时间戳，nonce 等，攻击者就可以拿着用户的签名，伪造用户发起交易，从而获利。<br>
这是一种最早出现于DApp生态初期的攻击形态，由于开发者设计的开奖随机算法存在严重缺陷，使得攻击者可利用合约漏洞重复开奖，属于开发者较为容易忽略的错误。因此，开发者们在链上进行验签操作的时候，需要对被签名消息加上各种可变因子，防止攻击者对链上签名进行重放，造成资产损失。</p>
<h3 id="重入攻击" tabindex="-1"> 重入攻击</h3>
<p>重入攻击(Reentrancy Attack)首次出现于以太坊，对应的真实攻击为 The DAO 攻击，此次攻击还导致了原来的以太坊分叉成以太经典(ETC)和现在的以太坊(ETH)。由于项目方采用的转账模型为先给用户发送转账然后才对用户的余额状态进行修改，导致恶意用户可以构造恶意合约，在接受转账的同时再次调用项目方的转账函数。利用这样的方法，导致用户的余额状态一直没有被改变，却能一直提取项目方资金，最终导致项目方资金被耗光。<br>
提醒智能合约开发者在进行智能合约开发时，在处理转账等关键操作的时候，如果智能合约中存储了用户的资金状态，要先对资金状态进行修改，然后再进行实际的资金转账，避免重入攻击。</p>
<h3 id="短地址攻击" tabindex="-1"> 短地址攻击</h3>
<p>短地址攻击(Short Address Attack)是针对以太坊上 ERC20 智能合约的一种攻击形式，利用的是 EVM 中的对于输入字节码的自动补全机制进行攻击。<br>
一般而言，针对 ERC20 合约中的 transfer 函数的调用，输入的字节码位数都是 136 字节的。当调用 ERC20 中的 transfer 函数进行 ERC20 Token 转账时，如果攻击者提供的地址后有一个或多个 0，那么攻击者就可以把地址后的零省去，提供一个缺位的地址。当对这个地址转账的时候，比方说转账 100 的 A Token，然后输入的地址是攻击者提供的缺位地址，这时候，经过编码输入的数据是 134 字节，比正常的数据少了 2 字节，在这种情况下，EVM 就会对缺失的字节位在编码数据的末尾进行补 0 凑成 136 字节，这样本来地址段缺失的 0 被数据段的 0 补齐了，而由于给地址段补 0，数据段会少 0，而数据段缺失的 0 由 EVM 自动补齐，这就像数据段向地址段移动补齐地址段缺失字节位，然后数据段缺失的字节位由 EVM 用 0 补齐。这种情况下，转账金额就会由 100 变成 100 * 16 的 n 次方，n 是地址缺失的 0 的个数。通过这种方式，攻击者就能对交易所或钱包进行攻击，盗窃交易所和钱包的资产。<br>
建议交易所和钱包在处理转账的时候，要对转账地址进行严格的校验，防止短地址攻击的发生。</p>
<h3 id="整型溢出攻击" tabindex="-1"> 整型溢出攻击</h3>
<p>数据的存储是区块链上重要的一环。但是每个数据类型本身是存在边界的，例如以太坊中 uint8 类型的变量就只能存储 0～255 大小的数据，超过了就存不下了。那么如果要放一个超过数据类型大小的数字会怎样呢？例如把 256 存进 uint8 的数据类型中，数据显示出来会变成 1，而不是其他数值，也不会报错，因为 uint8 本身能存一个 8 位二进制数字，最大值为 11111111，如果这个时候加 1，这个二进制数就变成了 100000001，而因为数据边界的关系，只能拿到后 8 位，也就是 00000001，那么数字的大小就变成 1 了，这种情况我们称为上溢。有上就有下，下溢的意思就是一个值为 0 的 uint8 数据，如果这个时候对它进行减 1 操作，结果会变成该数据类型所能存储的最大值加 1 减去被减数，在这个例子中是 255，也就是该数据类型所能存储的最大值。那么如果上述两种情况发生在智能合约当中的话，恶意用户通过下溢的操作，操纵自己的帐号向其他帐号发送超过自己余额数量的代币，如果合约内没有对余额进行检查，恶意用户的余额就会下溢出变成一个超大的值，这个时候攻击者如果大量抛售这些代币，就能瞬间破坏整个代币的价值系统。<br>
建议所有的智能合约开发者在智能合约中对数据进行操作的时候，要严格校验数据边界，防止整形溢出攻击的发生。</p>
<h3 id="条件竞争攻击" tabindex="-1"> 条件竞争攻击</h3>
<p>条件竞争(Race Condition)攻击的方式很多样，但是核心的本质无非是对某个条件的状态修改的竞争。条件竞争的例子：著名的 Edgeware 锁仓合约的拒绝服务漏洞，这个漏洞问题的本质在于对新建的锁仓合约的余额的这个条件进行竞争。攻击者可以监控所有链上的锁仓请求，提前计算出锁仓合约的地址，然后向合约地址转账，造成锁仓失败。在官方没有修复之前，要防止这种攻击，只能使用比攻击者更高的手续费让自己的锁仓交易先行打包，从而与攻击者形成竞争避免攻击。最后，官方修复方案为不对锁仓合约的余额进行强制性的相等检查，而是采用大于等于的形式，避免了攻击的发生。<br>
建议智能合约的开发者在智能合约中对某些状态进行修改的时候，要根据实际情况充分考虑条件竞争的风险，防止遭受条件竞争攻击。</p>
<h3 id="越权访问攻击" tabindex="-1"> 越权访问攻击</h3>
<p>和传统安全的定义一样，越权指的是访问或执行超出当前账户权限的操作，如本来有些操作只能是合约管理员执行的，但是由于限制做得不严谨，导致关键操作也能被合约管理员以外的人执行，导致不可预测的风险，这种攻击在以太坊和 EOS 上都曾出现过多次。<br>
以 EOS 上著名的BetDice游戏为例，由于在游戏合约内的路由(EOS 内可自定义的事件转发器)中没有对来源账号进行严格的校验，导致普通用户能通过 push action 的方式访问到合约中的关键操作 transfer 函数，直接绕过转账流程进行下注，从而发生了越权攻击，事后虽然BetDice官方紧急修复了代码，并严格限制了来源账号，但这个漏洞已经让攻击者几乎无成本薅走BetDice奖池内将近 5 万 EOS。又如在以太坊使用 solidity 版本为 0.4.x 进行合约开发的时候，很多合约开发者在对关键函数编写的时候不仅没有加上权限校验，也没有指定函数可见性，在这种情况下，函数的默认可见性为 public，恶意用户可以通过这些没有进行限制的关键函数对合约进行攻击。<br>
建议智能合约开发者们在进行合约开发的时候要注意对关键函数进行权限校验，防止关键函数被非法调用造成合约被攻击。</p>
<h3 id="交易顺序依赖攻击" tabindex="-1"> 交易顺序依赖攻击</h3>
<p>在区块链的世界当中，一笔交易内可能含有多个不同的交易，而这些交易执行的顺序会影响最终的交易的执行结果，由于在挖矿机制的区块链中，交易未被打包前都处于一种待打包的 pending 状态，如果能事先知道交易里面执行了哪些其他交易，恶意用户就能通过增加矿工费的形式，发起一笔交易，让交易中的其中一笔交易先行打包，扰乱交易顺序，造成非预期内的执行结果，达成攻击。以以太坊为例，假如存在一个 Token 交易平台，这个平台上的手续费是通过调控合约中的参数实现的，假如某天平台项目方通过一笔交易请求调高交易手续费用，这笔交易被打包后的所有买卖Token的交易手续费都要提升，正确的逻辑应该是从这笔交易开始往后所有的 Token 买卖交易的手续费都要提升，但是由于交易从发出到被打包存在一定的延时，请求修改交易手续费的交易不是立即生效的，那么这时恶意用户就可以以更高的手续费让自己的交易先行打包，避免支付更高的手续费。<br>
建议智能合约开发者在进行合约开发的时候要注意交易顺序对交易结果产生的影响，避免合约因交易顺序的不同遭受攻击。</p>
<h3 id="女巫攻击" tabindex="-1"> 女巫攻击</h3>
<p>传闻中女巫是一个会魔法的人，一个人可以幻化出多个自己，令受害人以为有多人，但其实只有一个人。在区块链世界中，女巫攻击(Sybil Attack)是针对服务器节点的攻击。攻击发生时候，通过某种方式，某个恶意节点可以伪装成多个节点，对被攻击节点发出链接请求，达到节点的最大链接请求，导致节点没办法接受其他节点的请求，造成节点拒绝服务攻击。<br>
建议在搭建全节点的情况下，服务器需要在系统层面上对网络连接情况进行监控，一旦发现某个IP连接异常就调用脚本配置 iptables 规则屏蔽异常的 IP，同时链开发者在进行公链开发时应该在 P2P 模块中对单 IP 节点连接数量添加控制。</p>
<h3 id="假错误通知攻击" tabindex="-1"> 假错误通知攻击</h3>
<p>EOS 上存在各种各样的通知，只要在 action 中添加require_recipient命令，就能对指定的帐号通知该 action，在 EOS 上某些智能合约中，为了用户体验或其他原因，一般会对onerror通知进行某些处理。如果这个时候没有对onerror通知的来源合约是否是eosio进行检验的话，就能使用和假转账通知同样的手法对合约进行攻击，触发合约中对onerror的处理，从而导致被攻击合约资产遭受损失。
建议智能合约开发者在进行智能合约开发的时候需要对onerror的来源合约进行校验，确保合约帐号为eosio帐号，防止假错误通知攻击。</p>
<h3 id="粉尘攻击" tabindex="-1"> 粉尘攻击</h3>
<p>粉尘攻击(Dusting Attack)最早发生于比特币网络当中，所谓粉尘，指的是交易中的交易金额相对于正常交易而言十分地小，可以视作微不足道的粉尘。通常这些粉尘在余额中不会被注意到，许多持币者也很容易忽略这些余额。但是由于比特币或基于比特币模型的区块链系统的账本模型是采用 UTXO 模型作为账户资金系统，即用户的每一笔交易金额，都是通过消费之前未消费的资金来产生新的资金。别有用意的用户，就能通过这种机制，给大量的账户发送这些粉尘金额，令交易粉尘化，然后再通过追踪这些粉尘交易，关联出该地址的其他关联地址，通过对这些关联地址进行行为分析，就可以分析一个地址背后的公司或个人，破坏比特币本身的匿名性。除此之外，由于比特币网络区块容量大小的限制，大量的粉尘交易会造成区块的拥堵，从而使得交易手续费提升，进而产生大量待打包交易，降低系统本身的运行效率。<br>
对于如何避免粉尘攻击，可以在构造交易的过程中，根据交易的类型，计算出交易的最低金额，同时对每个输出进行判断，如果低于该金额，则不能继续构造该笔交易。特别的，如果这个输出刚好发生在找零上，且金额对于你来说不太大，则可以通过舍弃该部分的粉尘输出，以充作交易手续费来避免构造出粉尘交易。其次，为了保护隐私性，建议可以在构造交易时把那些金额极小的 UTXO 舍弃掉，使用大额的 UTXO 组成交易。</p>
<h3 id="命令执行与控制-c2" tabindex="-1"> 命令执行与控制 C2</h3>
<p>C2 全称 Command and Control，翻译过来就是命令执行与控制，在传统的网络攻击中，在通过各种漏洞进入到目标服务器后，受限于空间，通常通过网络拉取二段 exploit 进行驻留，实现后渗透流程。所以，C2 架构也就可以理解为，恶意软件通过什么样的方式获取资源和命令，以及通过什么样的方式将数据回传给攻击者。在传统的攻击手法中，攻击者一般通过远程服务器拉取命令到本地执行，但是这种方式也有很明显的缺点，就是一旦远程服务器被发现，后续渗透活动就无法正常进行。但是区块链网络提供了一个天然且不可篡改的大型数据库，攻击者通过把攻击荷载(payload)写进交易中，并通过发送交易把该命令永久的刻在区块链数据库中。通过这种方法，即使攻击命令被发现，也无法篡改链上数据，无需担心服务器被发现然后下线的风险。
新技术不断发展，旧有的攻击手法也在随着新技术的变换而不断迭代更新。在区块链的世界中只有在各方面都做好防范，才能避免来自各方面的安全攻击。</p>
]]></content:encoded>
    </item>
    <item>
      <title>区块链与P2P网络</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/Chain_block_design.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/Chain_block_design.html</guid>
      <source url="https://bytecodes.tech/rss.xml">区块链与P2P网络</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识 P2P网络</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="p2p网络" tabindex="-1"> P2P网络</h2>
<p><strong>早期的P2P网络</strong>，P2P 网络需要解决的一个最重要的问题就是, 如何知道用户请求的资源位于哪个节点上. 在第一代 P2P 网络中, 人们设置了一台中央服务器来管理资源所处的位置. 当一个用户想要发布资源, 他需要告诉中央服务器它发布的资源信息和自己的节点信息; 当其他用户请求资源的时候, 需要先请求中央服务器以获取资源发布者的节点信息, 再向资源发布者请求资源.<br>
这种 P2P 网络的好处是效率高, 只需要请求一次中央服务器就可以发布或获取资源. 然而它的缺点也很明显: 中央服务器是这个网络系统最脆弱的地方, 它需要存储所有资源的信息, 处理所有节点的请求; 一旦中央服务器失效, 整个网络就无法使用.
另外一种 P2P 网络采取了不同的策略, 它不设置中央服务器; 当用户请求资源时, 它会请求它所有的邻接节点, 邻接节点再依次请求各自的邻接节点, 并使用一些策略防止重复请求, 直到找到拥有资源的节点. 也就是说, 这是一种泛洪搜索(Flooding Search).<br>
这种 P2P 网络去除了中央服务器, 它的稳定性就强多了. 然而它太慢了. 一次查找可能会产生大量的请求, 可能会有大量的节点卷入其中. 一旦整个系统中的的节点过多, 性能就会变得很差.</p>
<h3 id="分布式哈希表" tabindex="-1"> 分布式哈希表</h3>
<p>DHT（Distributed Hash Table）<br>
全网维护一个巨大的文件索引哈希表，这个哈希表的条目形如（key，value）。这里key通常是文件的哈希值，而value则是存储文件的IP地址。根据key就能找到存储到节点地址并返回给查询节点。这个表是按照一定规则分割存储到全网各个节点上。</p>
<ul>
<li>Kademlia</li>
<li>Chord</li>
</ul>
<h2 id="共识算法" tabindex="-1"> 共识算法</h2>
<ul>
<li>PBFT(Practical Byzantine Fault Tolerance) 拜占庭容错技术
<blockquote>
<p>应用代表: 联盟链. fabric; fisco-bcos;</p>
</blockquote>
</li>
<li>POW(Proof of Work) 工作量证明
<blockquote>
<p>Bitcoin(比特币); Ethereum(以太访)</p>
</blockquote>
</li>
<li>POS(Proof of Stake) 股权证明
<blockquote>
<p>Peercoin(点点币); 日后以太坊逐渐替换使用</p>
</blockquote>
</li>
<li>DPOS(Delegated Proof of Stake) 委任权益证明
<blockquote>
<p>EOS; Bitshare(比特股)</p>
</blockquote>
</li>
<li>Paxos Raft</li>
<li>Ripple 瑞波</li>
</ul>
<h3 id="pbft" tabindex="-1"> PBFT</h3>
<blockquote>
<p>f: 无效或恶意节点数<br>
R: 总节点数<br>
s: 正常节点数<br>
v: 系统的view编号，每次选举是触发 view change ,view number++</p>
</blockquote>
<p>前提 f &lt;= (R-1)/3  或  s &gt;= 2f+1 或 R = 3f + 1<br>
通俗讲就是可以容忍<strong>小于1/3的节点无效或恶意节点</strong></p>
<h4 id="leader-选举" tabindex="-1"> leader 选举</h4>
<div><pre><code>leader_idx = (block_number + current_view) % consensus_node_num
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>前三轮共识： node0、node1、node2为leader，且非恶意节点数目等于2<em>f+1，节点正常出块共识；<br>
第四轮共识：node3为leader，但node3为拜占庭节点，node0-node2在给定时间内未收到node3打包的区块，触发视图切换，试图切换到view_new=view+1的新视图，并相互间广播viewchange包，节点收集满在视图view_new上的(2</em>f+1)个viewchange包后，将自己的view切换为view_new，并计算出新leader；<br>
为第五轮共识：node0为leader，继续打包出块。</p>
</blockquote>
<p>采用PBFT共识算法的系统，节点规模在百级左右，再增加就会导致TPS下降，确认时延增加。目前业界有通过随机数算法选择记账组的共识机制，可以改善这个问题。</p>
<blockquote>
<p>RPBFT(rotating PBFT)就是其中的一个解决方案目的是将共识算法网络复杂度与共识节点规模解耦，提升区块链系统的可扩展性。在大节点规模下，随机选取部分节点作为“共识委员节点”参与每轮PBFT共识，由于共识委员节点数目固定、与节点规模无关，因此RPBFT共识算法可扩展性更强。<br>
epoch_sealer_num：每轮共识过程中参与共识的节点数目。<br>
epoch_block_num: 共识节点替换周期，为防止选取的共识节点联合作恶，RPBFT每出epoch_block_num个区块，会替换若干个共识委员节点。<br>
引入VRF可验证随机数算法来实现私密、随机、非交互式的共识委员节点选取方法。</p>
</blockquote>
<h4 id="角色" tabindex="-1"> 角色</h4>
<ul>
<li>replica 副本节点，备份节点,共识节点,所有参与的节点，接收并检查主节点的排序信息，如果主节点作恶可以进行换选。总数：R</li>
<li>primary 主节点，共识节点,负责将client的请求排序，发给所有的备份节点。负责将交易打包成区块和区块共识，每轮共识过程中有且仅有一个leader，为了防止leader伪造区块，每轮PBFT共识后，均会切换leader。</li>
<li>Observer 观察者节点，负责从共识节点或副本节点获取最新区块，执行并验证区块执行结果后，将产生的区块上链。</li>
</ul>
<blockquote>
<p>主节点选举：p = v 求余 R</p>
</blockquote>
<h4 id="共识流程" tabindex="-1"> 共识流程</h4>
<p>PBFT共识主要包括Pre-prepare、Prepare和Commit三个阶段。</p>
<p>PBFT共识算法中，共识节点轮流出块，每一轮共识仅有一个leader打包区块。节点计算当前leader索引与自己索引相同后，就开始</p>
<h5 id="打包区块-生成prepare" tabindex="-1"> 打包区块 生成Prepare</h5>
<blockquote>
<p><strong>产生新的空块</strong>: 通过区块链(BlockChain)获取当前最高块，并基于最高块产生新空块(将新区块父哈希置为最高块哈希，时间戳置为当前时间，交易清空)；<br>
<strong>从交易池打包交易</strong>: 产生新空块后，从交易池中获取交易，并将获取的交易插入到产生的新区块中；<br>
<strong>组装新区块</strong>: Sealer线程打包到交易后，将新区块的打包者(Sealer字段)置为自己索引，并根据打包的交易计算出所有交易的transactionRoot；<br>
<strong>产生Prepare包</strong>: 将组装的新区块编码到Prepare包内，广播给组内所有共识节点，其他共识节点收到Prepare包后，开始进行三阶段共识。</p>
</blockquote>
<h5 id="pre-prepare" tabindex="-1"> Pre-prepare</h5>
<p>共识节点收到Prepare包后，进入pre-prepare阶段，此阶段的主要工作流程包括：</p>
<blockquote>
<p><strong>Prepare包合法性判断</strong>：主要判断是否是重复的Prepare包、Prepare请求中包含的区块父哈希是否是当前节点最高块哈希(防止分叉)、Prepare请求中包含区块的块高是否等于最高块高加一；<br>
<strong>缓存合法的Prepare包</strong>: 若Prepare请求合法，则将其缓存到本地，用于过滤重复的Prepare请求；<br>
<strong>空块判断</strong>：若Prepare请求包含的区块中交易数目是0，则触发空块视图切换，将当前视图加一，并向所有其他节点广播视图切换请求；<br>
<strong>执行区块并缓存区块执行结果</strong>: 若Prepare请求包含的区块中交易数目大于0，则调用BlockVerifier区块执行器执行区块，并缓存执行后的区块；<br>
<strong>产生并广播签名包</strong>：基于执行后的区块哈希，产生并广播签名包，表明本节点已经完成区块执行和验证。</p>
</blockquote>
<h5 id="prepare" tabindex="-1"> Prepare</h5>
<p>共识节点收到签名包后，进入Prepare阶段，此阶段的主要工作流程包括：</p>
<blockquote>
<p><strong>签名包合法性判断</strong>：主要判断签名包的哈希与pre-prepare阶段缓存的执行后的区块哈希相同，若不相同，则继续判断该请求是否属于未来块签名请求(产生未来块的原因是本节点处理性能低于其他节点，还在进行上一轮共识，判断未来块的条件是：签名包的height字段大于本地最高块高加一)，若请求也非未来块，则是非法的签名请求，节点直接拒绝该签名请求；<br>
<strong>缓存合法的签名包</strong>：节点会缓存合法的签名包；
<strong>判断pre-prepare阶段缓存的区块对应的签名包缓存是否达到2*f+1，若收集满签名包，广播Commit包</strong>：若pre-prepare阶段缓存的区块哈希对应的签名包数目超过2<em>f+1，则说明大多数节点均执行了该区块，并且执行结果一致，说明本节点已经达到可以提交区块的状态，开始广播Commit包；<br>
<strong>若收集满签名包，备份pre-prepare阶段缓存的Prepare包落盘</strong>：为了防止Commit阶段区块未提交到数据库之前超过2</em>f+1个节点宕机，这些节点启动后重新出块，导致区块链分叉(剩余的节点最新区块与这些节点最高区块不同)，还需要备份pre-prepare阶段缓存的Prepare包到数据库，节点重启后，优先处理备份的Prepare包。</p>
</blockquote>
<h5 id="commit" tabindex="-1"> Commit</h5>
<p>共识节点收到Commit包后，进入Commit阶段，此阶段工作流程包括：</p>
<blockquote>
<p><strong>Commit包合法性判断</strong>：主要判断Commit包的哈希与pre-prepare阶段缓存的执行后的区块哈希相同，若不相同，则继续判断该请求是否属于未来块Commit请求(产生未来块的原因是本节点处理性能低于其他节点，还在进行上一轮共识，判断未来块的条件是：Commit的height字段大于本地最高块高加一)，若请求也非未来块，则是非法的Commit请求，节点直接拒绝该请求；<br>
<strong>缓存合法的Commit包</strong>：节点缓存合法的Commit包；<br>
<strong>判断pre-prepare阶段缓存的区块对应的Commit包缓存是否达到2*f+1，若收集满Commit包，则将新区块落盘</strong>：若pre-prepare阶段缓存的区块哈希对应的Commit请求数目超过2*f+1，则说明大多数节点达到了可提交该区块状态，且执行结果一致，则调用BlockChain模块将pre-prepare阶段缓存的区块写入数据库；</p>
</blockquote>
<h5 id="viewchange" tabindex="-1"> ViewChange</h5>
<p>当PBFT三阶段共识超时或节点收到空块时，PBFTe会试图切换到更高的视图(将要切换到的视图toView加一)，并触发ViewChange处理流程；节点收到ViewChange包时，也会触发ViewChange处理流程：</p>
<blockquote>
<p><strong>判断ViewChange包是否有效</strong>: 有效的ViewChange请求中带有的块高值必须不小于当前节点最高块高，视图必须大于当前节点视图；<br>
<strong>缓存有效ViewChange包</strong>： 防止相同的ViewChange请求被处理多次，也作为判断节点是否可以切换视图的统计依据；<br>
<strong>收集ViewChange包</strong>：若收到的ViewChange包中附带的view等于本节点的即将切换到的视图toView且本节点收集满2*f+1来自不同节点view等于toView的ViewChange包，则说明超过三分之二的节点要切换到toView视图，切换当前视图到toView。</p>
</blockquote>
<h2 id="轻节点" tabindex="-1"> 轻节点</h2>
<h3 id="默克尔树-merkle-tree" tabindex="-1"> 默克尔树 Merkle tree</h3>
<blockquote>
<p>在比特币的白皮书中提到了轻节点也就是简易支付验证(Simplified Payment Verification,SPV)，它正是基于默克尔可信树利用区块中的所有交易 hash 生成的一个默克尔根节点，保存至区块头，可用于验证交易是否打包到某区块中。</p>
</blockquote>
<p><img src="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/bc-merkle-tree.png" alt="image"></p>
<p>每个块都会有一个Merkle树,它从叶子节点(树的底部)开始,一个叶子节点就是一个交易哈希,叶子节点的数量必须是双数(如果区块里交易数是单数，就复制最后一份凑成双数)。从下往上,两两成对,连接两个节点哈希,将组合哈希作为新的哈希。新的哈希就成为新的树节点。重复该过程,直到仅有一个节点,也就是树根。根哈希然后就会当做是整个块交易的唯一标示,将它保存到区块头,然后用于工作量证明。</p>
<p><img src="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/merkle_tree_bitcoin.png" alt="img">
左：仅提供默克尔树（Merkle tree）上的少量节点已经足够给出分支的合法证明。<br>
右：任何对于默克尔树的任何部分进行改变的尝试都会最终导致链上某处的不一致。</p>
<p>Merkle树的好处就是一个节点可以在不下载整个块的情况下,验证是否包含某笔交易。并且这些只需要一个交易哈希,一个Merkle树根哈希和一个Merkle路径</p>
<h3 id="mpt-merkle-patricia-tree" tabindex="-1"> MPT(Merkle Patricia Tree)</h3>
<p>梅克尔帕特里夏树 = 默克尔树 + 压缩前缀树（Patricia trie）
<img src="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/MPT.png" alt="img"></p>
<p>我们将如下数据插入MPT中</p>
<table>
<thead>
<tr>
<th>key</th>
<th>values</th>
</tr>
</thead>
<tbody>
<tr>
<td>a711355</td>
<td>45.0 ETH</td>
</tr>
<tr>
<td>a77d337</td>
<td>1.00 WEI</td>
</tr>
<tr>
<td>a7f9365</td>
<td>1.1  ETH</td>
</tr>
<tr>
<td>a77d397</td>
<td>0.12 ETH</td>
</tr>
</tbody>
</table>
<p>插入第一个&lt;a711355, 45&gt;，由于只有一个key,直接用leaf node既可表示</p>
<p>接着插入a77d337,由于和a711355共享前缀’a7’,因而可以创建’a7’扩展节点。</p>
<p>接着插入a7f9365,也是共享’a7’,只需新增一个leaf node.</p>
<p>最后插入a77d397,这个key和a77d337共享’a7’+’d3’,因而再需要创建一个’d3’扩展节点</p>
<p>将叶子节点和最后的short node合并到一个节点了，事实上源码实现需要再深一层，最后一层的叶子节点只有数据</p>
<h2 id="加密算法" tabindex="-1"> 加密算法</h2>
<ul>
<li>
<p>大数分解困难问题：对应RSA系列算法等。</p>
</li>
<li>
<p>离散对数困难问题：对应Diffie-Hellman密钥交换协议、ElGamal加密、DSA算法等。</p>
</li>
<li>
<p>椭圆曲线上的离散对数困难问题：对应ECDSA、EdDSA、国密SM2等。</p>
</li>
</ul>
<p>密钥长度，美国国家标准与技术研究院NIST作如下推荐。
基于各大类的公钥加密算法，单位（比特、位）</p>
<table>
<thead>
<tr>
<th>安全参数等级</th>
<th>大数分解</th>
<th>离散对数</th>
<th>椭圆曲线上的离散对数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1024</td>
<td>1024</td>
<td>160</td>
</tr>
<tr>
<td>2</td>
<td>2048</td>
<td>2048</td>
<td>224</td>
</tr>
<tr>
<td>3</td>
<td>3072</td>
<td>3072</td>
<td>256</td>
</tr>
<tr>
<td>4</td>
<td>7680</td>
<td>7680</td>
<td>384</td>
</tr>
<tr>
<td>5</td>
<td>15360</td>
<td>15360</td>
<td>512</td>
</tr>
</tbody>
</table>
<blockquote>
<ol>
<li>一个隐私保护技术方案，安全性取决于其使用的密码学算法实现中最低的安全参数等级。</li>
</ol>
</blockquote>
<ol start="2">
<li>在未指明安全参数的前提下，进行密码学算法的安全性比较没有实际意义。</li>
<li>如果安全参数值很小，一般表现为对应的密钥长度很短时，无论密码学算法设计多么精妙，实际效果可能都是不安全的。</li>
<li>由于困难问题选用上的差异，密码学算法的理论强度没有最强，只有在满足特定安全假设下的够强，强行比较基于不同困难问题的密码学算法是否有效通常没有实际意义。</li>
</ol>
<blockquote>
<p>计算困难问题归根结底还是一个计算问题，随着计算机计算能力的增强，或是算法理论研究进展的推进，这些困难问题的安全性可能就会发生变化。<br>
比如RSA加密算法，NIST密钥管理准则认为，2010年后，1024位的密钥不再安全，需要增加到2048位的密钥长度，预计其安全有效性可以保持至2030年。<br>
对于企业而言，这里的启示在于，不能简单地认为，隐私保护技术方案现在有效，就保证了10年后依旧有效。</p>
</blockquote>
<h2 id="跨链" tabindex="-1"> 跨链</h2>
<ul>
<li>公证人机制</li>
<li>侧链/中继</li>
<li>哈希锁定</li>
</ul>
<blockquote>
<p><a href="https://github.com/WeBankFinTech/WeCross" target="_blank" rel="noopener noreferrer">WeCross</a></p>
</blockquote>
<h3 id="跨链应用场景" tabindex="-1"> 跨链应用场景</h3>
<ul>
<li>资产交换</li>
<li>原子交易</li>
<li>预言机</li>
<li>信息互通</li>
</ul>
]]></content:encoded>
      <enclosure url="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/bc-merkle-tree.png" type="image/png"/>
    </item>
    <item>
      <title>Solidity基础知识</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/Intelligent_contract_solidity.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/Intelligent_contract_solidity.html</guid>
      <source url="https://bytecodes.tech/rss.xml">Solidity基础知识</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识 P2P网络 Solidity</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<p><a href="https://solidity.readthedocs.io/" target="_blank" rel="noopener noreferrer">Solidity</a> 是一门面向合约的、为实现智能合约而创建的高级编程语言，运作在以太坊虚拟机（EVM）上。</p>
<p><a href="https://solidity.readthedocs.io/" target="_blank" rel="noopener noreferrer">官方文档</a><br>
<a href="https://learnblockchain.cn/docs/solidity/" target="_blank" rel="noopener noreferrer">非官方中文文档</a><br>
<a href="https://github.com/OpenZeppelin/openzeppelin-contracts" target="_blank" rel="noopener noreferrer">Openzeppelin合约类库</a></p>
<blockquote>
<p>以太坊虚拟机（EVM）是一个 “The World Machine” 所以请原谅它简陋的语法特性、令人抓狂的debug体验、近乎贫瘠的类库支持、动不动就需要插入汇编语句来解决一下问题。Solidity 语言在这种环境下必须严格遵循的设计原则以及权衡后必须付出的代价。</p>
</blockquote>
<h2 id="abi" tabindex="-1"> ABI</h2>
<p>Application Binary Interface(ABI)</p>
<h2 id="存储" tabindex="-1"> 存储</h2>
<p><strong>栈</strong> 用于存储字节码指令的操作数。在Solidity中，局部变量若是整型、定长字节数组等类型，就会随着指令的运行入栈、出栈。对于这类变量，无法强行改变它们的存储方式，如果在它们之前放置memory修饰符，编译会报错。<br>
<strong>内存</strong> 类似java中的堆，它用于储存&quot;对象&quot;。在Solidity编程中，如果一个局部变量属于变长字节数组、字符串、结构体等类型，其通常会被memory修饰符修饰，以表明存储在内存中。<br>
<strong>状态存储</strong> 用于存储合约的状态字段。从实现而言，不同的链可能采用不同实现，比较经典的是以太坊所采用的MPT树。由于MPT树性能、扩展性等问题，FISCO BCOS放弃了这一结构，而采用了分布式存储，通过rocksdb或mysql来存储状态数据，使存储的性能、可扩展性得到提高。</p>
<div><pre><code>contract Demo<span>{</span>
    <span>//状态存储</span>
    uint <span>private</span> _state<span>;</span>

    <span>function</span> <span>set</span><span>(</span><span>uint state</span><span>)</span> <span>public</span> <span>{</span>
        <span>//栈存储</span>
        uint i <span>=</span> <span>0</span><span>;</span>
        <span>//内存存储</span>
        string memory str <span>=</span> <span>"aaa"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="event-log" tabindex="-1"> Event/Log</h2>
<div><pre><code>
pragma solidity <span>>=</span><span>0.4</span><span>.21</span> <span>&lt;</span><span>0.7</span><span>.0</span><span>;</span>
contract Demo <span>{</span>
  <span>// 定义事件</span>
  event <span>Transfer</span><span>(</span>address indexed from<span>,</span> address indexed to<span>,</span> uint256 value<span>)</span><span>;</span>

  <span>function</span> <span>bid</span><span>(</span><span>)</span> <span>public</span> payable <span>{</span>
    <span>//触发事件</span>
    emit <span>Transfer</span><span>(</span>msg<span>.</span>sender<span>,</span> _to<span>,</span> _value<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>最多三个参数可以使用 <code>indexed</code> 属性</p>
<ul>
<li>这些参数会使用 <code>keccak-256</code> 哈希后得到值被作为 <code>topic</code> 保存在区块的 Event 里</li>
<li>API调用时可以使用这些 <code>indexed</code> 参数的特定值来进行过滤</li>
</ul>
<div><pre><code><span>var</span> event <span>=</span> demoContract<span>.</span><span>Transfer</span><span>(</span><span>{</span><span>from</span><span>:</span> <span>[</span><span>"xxxx"</span><span>,</span><span>"xxxx"</span><span>,</span><span>"xxxxx"</span><span>]</span><span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>高效使用：</p>
<ul>
<li>异步获取执行结果，并可提供过滤器，支持参数的检索和过滤。</li>
<li>提供一种回调机制，在事件执行成功后，由节点向注册监听的SDK发送回调通知，触发回调函数被执行。Oracle 的原理</li>
<li>存储合约数据，巧用日志去存储数据，可以大大减少交易费用
<blockquote>
<p>storage存储的大概价格为：每32字节需要消耗20000Gas，而日志存储价格大概为每字节8Gas</p>
</blockquote>
</li>
</ul>
<h2 id="修饰符" tabindex="-1"> 修饰符</h2>
<p><strong>修饰函数</strong></p>
<ul>
<li><code>pure</code> - 不允许修改和访问状态</li>
<li><code>view</code> - 不允许修改状态</li>
<li><code>payable</code> - 允许调用接收 以太币</li>
</ul>
<p><strong>修饰函数和变量</strong></p>
<ul>
<li>
<p><code>constant</code></p>
<p>函数：与<code>view</code>等价。<br>
变量：不允许赋值（初始化除外），它不会占据 <code>storage slot</code></p>
</li>
<li>
<p><code>external</code> - 可以从其他合约和交易中调用，不可内部调用，在接收大量数据时更为高效。</p>
<p>当函数的某个参数非常大时，如果显式地将函数标记为external，可以强制将函数存储的位置设置为 <code>calldata</code>，这会节约函数执行时所需存储或计算资源。</p>
</li>
<li>
<p><code>public</code> - 可以在内部或通过消息调用。没指定默认为 public</p>
<p>变量：会自动生成一个 <code>getter</code> 函数</p>
</li>
<li>
<p><code>internal</code> - 只能是内部访问</p>
<p>变量：状态变量的修饰符默认是<code>internal</code></p>
</li>
<li>
<p><code>private</code> - 仅在当前定义它们的合约中使用，并且不能被派生合约使用</p>
</li>
</ul>
<p><strong>修饰事件参数</strong></p>
<ul>
<li><code>indexed</code> - 可作为索引</li>
<li><code>anonymous</code> - 事件签名的哈希值不会在 <code>topic</code> 中存储</li>
</ul>
<p><strong>修饰器</strong></p>
<ul>
<li>
<p><code>modifier</code> - <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#modifier" target="_blank" rel="noopener noreferrer">修饰器</a></p>
<p>有点面向切面编程的感觉。</p>
</li>
</ul>
<div><pre><code>event <span>LogStartMethod</span><span>(</span><span>)</span><span>;</span>
event <span>LogEndMethod</span><span>(</span><span>)</span><span>;</span>
modifier logMethod <span>{</span>
    emit <span>LogStartMethod</span><span>(</span><span>)</span><span>;</span>
    _<span>;</span><span>//表示所修饰函数中的代码,也就是在函数的最前与最后插入代码</span>
    emit <span>LogEndMethod</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>function</span> <span>doing</span><span>(</span><span>address _owner</span><span>)</span> <span>public</span> logMethod <span>{</span>
    <span>// something...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="抽象类与接口" tabindex="-1"> 抽象类与接口</h2>
<p><a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#index-17" target="_blank" rel="noopener noreferrer">docs</a> 与其他语言类似。但需要注意合适地使用接口或抽象合约有助于增强合约设计的可扩展性。但是，由于区块链EVM上计算和存储资源的限制，切忌过度设计，这也是从高级语言技术栈转到Solidity开发的老司机常常会陷入的天坑。</p>
<h2 id="常见问题" tabindex="-1"> 常见问题</h2>
<ul>
<li>一个合约中，入参、返回值、内部变量不能超过了16个</li>
</ul>
<div><pre><code>Compiler error<span>:</span> Stack too deep<span>,</span> <span>try</span> removing local variables<span>.</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>EVM所设计用于最大的栈深度为16。所有的计算都在一个栈内执行，对栈的访问只限于其顶端，限制方式为：允许拷贝最顶端16个元素中的一个到栈顶，或者将栈顶元素和下面16个元素中的一个交换。所有其他操作都只能取最顶的几个元素，运算后，把结果压入栈顶。当然可以把栈上的元素放到存储或内存中。但无法只访问栈上指定深度的那个元素，除非先从栈顶移除其他元素。</p>
<p><strong>建议</strong> 使用结构体或数组来封装入参或返回值，达到减少栈顶元素使用的目的，从而避免此错误。对于智能合约也应该<a href="/blockchain/basic-logic/Smart_contracts_design_pattern.html">避免过多的设计</a>。需要分布式协作的重要数据才上链，非必需数据不上链；链上验证，链下授权。</p>
]]></content:encoded>
    </item>
    <item>
      <title>区块链之联盟链知识</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/League_chain.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/League_chain.html</guid>
      <source url="https://bytecodes.tech/rss.xml">区块链之联盟链知识</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识 P2P网络 Solidity 联盟链</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<hr>
<ul>
<li>
<p>BSN 区块链服务网络（Blockchain-based Service Network）</p>
<blockquote>
<p>是一个跨云服务、跨门户、跨底层框架，用于部署和运行区块链应用的全球性公共基础设施网络，由国家信息中心、中国移动通信集团公司、中国银联股份有限公司、北京红枣科技有限公司共同发起
<a href="http://kb.bsnbase.com/webdoc/view/Pub4028813e711a7c39017185cacb7b5640.html" target="_blank" rel="noopener noreferrer">BSN培训</a></p>
</blockquote>
</li>
<li>
<p>Hyperledger Fabric (有国密版Fabric)</p>
</li>
<li>
<p>FISCO BCOS （支持国密）</p>
</li>
<li>
<p><a href="https://github.com/citahub/cita" target="_blank" rel="noopener noreferrer">CITA</a></p>
</li>
<li>
<p>梧桐链</p>
</li>
<li>
<p>Brochain</p>
</li>
<li>
<p><a href="https://github.com/xuperchain/xuperchain" target="_blank" rel="noopener noreferrer">XuperChain</a></p>
</li>
</ul>
<h2 id="fisco-bcos" tabindex="-1"> <a href="https://github.com/FISCO-BCOS/FISCO-BCOS" target="_blank" rel="noopener noreferrer">FISCO BCOS</a></h2>
<ul>
<li>
<p>保障信息保密性、认证性、完整性、不可抵赖性，需采用CA的准入机制，并支持任意多级的证书结构。<br>
默认采用三级的证书结构，自上而下分别为链证书、机构证书、节点证书。</p>
<ul>
<li>
<p>链证书: 联盟链拥有唯一的链证书</p>
<blockquote>
<p>证书<code>ca.crt</code> , 私钥<code>ca.key</code> , 签发证书的序列号记录文件<code>ca.srl</code></p>
</blockquote>
</li>
<li>
<p>机构证书：</p>
<blockquote>
<p>机构证书<code>agency.crt</code> , 机构私钥<code>agency.key</code> , <code>agency.srl</code></p>
</blockquote>
</li>
<li>
<p>节点证书：由机构自己生产，每个机构都可以拥有多个节点</p>
</li>
</ul>
</li>
<li>
<p>引入多群组架构，支持区块链节点启动多个群组，群组间交易处理、数据存储、区块共识相互隔离，保障区块链系统隐私性的同时，降低了系统的运维复杂度</p>
<blockquote>
<p>机构A、B、C所有节点构成一个区块链网络，运行业务1；一段时间后，机构A、B启动业务2，且不希望该业务相关数据、交易处理被机构C感知，有何解？</p>
</blockquote>
<p>一般理解群组个数可以达到整数上限，但由于硬件的限制，应采用这种极端的设计，机构可以为不同的业务使用不同的节点去加了对应群组来解决多业务问题。</p>
<blockquote>
<p>100个群组都落在一个节点上可能需要。64核，128g内存，百兆外网带宽，4T硬盘以上。这是基本的。如果业务有上量还得加</p>
</blockquote>
</li>
</ul>
<h3 id="节点准入机制" tabindex="-1"> 节点准入机制</h3>
<p>CA黑白名单</p>
<ul>
<li>群组节点：共识节点，观察节点</li>
<li>游离节点：完成网络准入但没有加入群组的节点，不参与共识和同步</li>
</ul>
<h4 id="网络准入机制" tabindex="-1"> 网络准入机制</h4>
<h4 id="群组准入机制" tabindex="-1"> 群组准入机制</h4>
<p><strong>交易流程</strong></p>
<ul>
<li>用户通过操作SDK或直接编写curl命令向所连接的节点发起交易。</li>
<li>节点收到交易后，若当前交易池未满则将交易附加至TxPool中并向自己所连的节点广播该交易；否则丢弃交易并输出告警。</li>
<li>Sealer(打包器)会不断从交易池中取出交易，并立即将收集到的交易打包为区块并发送至共识引擎。</li>
<li>共识引擎调用BlockVerifier对区块进行验证并在网络中进行共识，BlockVerifier调用Executor执行区块中的每笔交易。当区块验证无误且网络中节点达成一致后，共识引擎将区块发送至BlockChain。</li>
<li>BlockChain收到区块，对区块信息（如块高等）进行检查，并将区块数据与表数据写入底层存储中，完成区块上链。</li>
</ul>
<p><strong>交易同步</strong></p>
<ul>
<li>一笔交易通过channel或RPC发送到某节点上</li>
<li>收到交易的节点全量广播此交易给其它节点</li>
<li>其它节点收到交易后，为了保险起见，选择25%的节点再广播一次</li>
<li>节点收到广播过的交易，不会再次广播</li>
</ul>
<h3 id="国密算法" tabindex="-1"> 国密算法</h3>
<table>
<thead>
<tr>
<th></th>
<th>标准版FISCO BCOS</th>
<th>国密版FISCO BCOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>SSL链接</td>
<td>Openssl TLSv1.2协议</td>
<td>国密TLSv1.1协议</td>
</tr>
<tr>
<td>签名验证</td>
<td>ECDSA签名算法</td>
<td>SM2签名算法</td>
</tr>
<tr>
<td>消息摘要算法</td>
<td>SHA-256 SHA-3</td>
<td>SM3消息摘要算法</td>
</tr>
<tr>
<td>落盘加密算法</td>
<td>AES-256加密算法</td>
<td>SM4加密算法</td>
</tr>
<tr>
<td>证书模式</td>
<td>OpenSSL证书模式</td>
<td>国密双证书模式</td>
</tr>
<tr>
<td>合约编译器</td>
<td>以太坊solidity编译器</td>
<td>国密solidity编译器</td>
</tr>
</tbody>
</table>
<p><a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/design/features/guomi.html" target="_blank" rel="noopener noreferrer">详细</a></p>
<h3 id="webase" tabindex="-1"> <a href="https://github.com/WeBankFinTech/WeBASE" target="_blank" rel="noopener noreferrer">WeBASE</a></h3>
<h3 id="weidentity" tabindex="-1"> <a href="https://github.com/WeBankFinTech/WeIdentity" target="_blank" rel="noopener noreferrer">WeIdentity</a></h3>
<h3 id="wedpr" tabindex="-1"> <a href="https://github.com/WeBankBlockchain/WeDPR-Lab-Core" target="_blank" rel="noopener noreferrer">WeDPR</a></h3>
]]></content:encoded>
    </item>
    <item>
      <title>基础知识</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/</guid>
      <source url="https://bytecodes.tech/rss.xml">基础知识</source>
      <category>区块链学习</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
    </item>
    <item>
      <title>区块链之设计模式</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/Smart_contracts_design_pattern.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/Smart_contracts_design_pattern.html</guid>
      <source url="https://bytecodes.tech/rss.xml">区块链之设计模式</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识 P2P网络 Solidity 设计模式</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="设计模式" tabindex="-1"> 设计模式</h2>
<p>《Design Patterns For Smart Contracts In the Ethereum Ecosystem》</p>
<h3 id="安全-security" tabindex="-1"> 安全 Security</h3>
<ul>
<li>
<p>Checks-Effects-Interaction 保证状态完整，再做外部调用</p>
<p>Checks：参数验证，Effects：修改合约状态，Interaction：外部交互
这个模式要求合约按照Checks-Effects-Interaction的顺序来组织代码。它的好处在于进行外部调用之前，Checks-Effects已完成合约自身状态所有相关工作，使得状态完整、逻辑自洽，这样外部调用就无法利用不完整的状态进行攻击</p>
</li>
<li>
<p>Mutex - 禁止递归</p>
<p>使用修饰符防止函数被递归调用。防止重放攻击</p>
<div><pre><code>contract Mutex <span>{</span>
  bool locked<span>;</span>
  modifier <span>noReentrancy</span><span>(</span><span>)</span> <span>{</span>
      <span>//防止递归</span>
      <span>require</span><span>(</span><span>!</span>locked<span>,</span> <span>"Reentrancy detected"</span><span>)</span><span>;</span>
      locked <span>=</span> <span>true</span><span>;</span>
      _<span>;</span>
      locked <span>=</span> <span>false</span><span>;</span>
  <span>}</span>

  <span>//调用该函数将会抛出Reentrancy detected错误</span>
  <span>function</span> <span>some</span><span>(</span><span>)</span> <span>public</span> noReentrancy<span>{</span>
      <span>some</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ul>
<p>}</p>
<div><pre><code>
### 可维护性 Maintaince

高度模块化、高内聚低耦合

* Data segregation - 数据与逻辑相分离
```javascript
contract DataRepository{

  uint private _data;

  function setData(uint data) public {
      _data = data;
  }

  function getData() public view returns(uint){
      return _data;
  }
}
contract Computer{
  DataRepository private _dataRepository;
  constructor(address addr){
      _dataRepository = DataRepository(addr);
  }

  //业务代码
  function compute() public view returns(uint){
      return _dataRepository.getData() * 10;
  }    
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>Satellite - 分解合约功能</li>
</ul>
<div><pre><code>contract Base <span>{</span>
    uint <span>public</span> _variable<span>;</span>

    <span>function</span> <span>setVariable</span><span>(</span><span>uint data</span><span>)</span> <span>public</span> <span>{</span>
        _variable <span>=</span> _satellite<span>.</span><span>compute</span><span>(</span>data<span>)</span><span>;</span>
    <span>}</span>

     Satellite _satellite<span>;</span>
    <span>//更新子合约（卫星合约）</span>
    <span>function</span> <span>updateSatellite</span><span>(</span><span>address addr</span><span>)</span> <span>public</span> <span>{</span>
        _satellite <span>=</span> <span>Satellite</span><span>(</span>addr<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
contract Satellite <span>{</span>
    <span>function</span> <span>compute</span><span>(</span><span>uint a</span><span>)</span> <span>public</span> <span>returns</span><span>(</span><span>uint</span><span>)</span><span>{</span>
        <span>return</span> a <span>*</span> <span>10</span><span>;</span>        
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>Contract Registry - 跟踪最新合约</li>
</ul>
<div><pre><code>contract Registry<span>{</span>

    address _current<span>;</span>
    address<span>[</span><span>]</span> _previous<span>;</span>

    <span>//子合约升级了，就通过update函数更新地址</span>
    <span>function</span> <span>update</span><span>(</span><span>address newAddress</span><span>)</span> <span>public</span><span>{</span>
        <span>if</span><span>(</span>newAddress <span>!=</span> _current<span>)</span><span>{</span>
            _previous<span>.</span><span>push</span><span>(</span>_current<span>)</span><span>;</span>
            _current <span>=</span> newAddress<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>function</span> <span>getCurrent</span><span>(</span><span>)</span> <span>public</span> view <span>returns</span><span>(</span><span>address</span><span>)</span><span>{</span>
        <span>return</span> _current<span>;</span>
    <span>}</span>
<span>}</span>
contract Base <span>{</span>
    uint <span>public</span> _variable<span>;</span>

    <span>function</span> <span>setVariable</span><span>(</span><span>uint data</span><span>)</span> <span>public</span> <span>{</span>
        Satellite satellite <span>=</span> <span>Satellite</span><span>(</span>_registry<span>.</span><span>getCurrent</span><span>(</span><span>)</span><span>)</span><span>;</span>
        _variable <span>=</span> satellite<span>.</span><span>compute</span><span>(</span>data<span>)</span><span>;</span>
    <span>}</span>

    Registry <span>private</span> _registry <span>=</span> <span>//...;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>Contract Relay - 代理调用最新合约</li>
</ul>
<div><pre><code>contract Base <span>{</span>
    uint <span>public</span> _variable<span>;</span>

    <span>function</span> <span>setVariable</span><span>(</span><span>uint data</span><span>)</span> <span>public</span> <span>{</span>
        _variable <span>=</span> _proxy<span>.</span><span>compute</span><span>(</span>data<span>)</span><span>;</span>
    <span>}</span>
    SatelliteProxy <span>private</span> _proxy <span>=</span> <span>//...;</span>
<span>}</span>
contract SatelliteProxy<span>{</span>
    address _current<span>;</span>
    <span>function</span> <span>compute</span><span>(</span><span>uint a</span><span>)</span> <span>public</span> <span>returns</span><span>(</span><span>uint</span><span>)</span><span>{</span>
        Satellite satellite <span>=</span> <span>Satellite</span><span>(</span>_current<span>)</span><span>;</span>   
        <span>return</span> satellite<span>.</span><span>compute</span><span>(</span>a<span>)</span><span>;</span>
    <span>}</span>

    <span>//子合约升级了，就通过update函数更新地址</span>
    <span>function</span> <span>update</span><span>(</span><span>address newAddress</span><span>)</span> <span>public</span><span>{</span>
        <span>if</span><span>(</span>newAddress <span>!=</span> _current<span>)</span><span>{</span>
            _current <span>=</span> newAddress<span>;</span>
        <span>}</span>
    <span>}</span>   
<span>}</span>
contract Satellite <span>{</span>
    <span>function</span> <span>compute</span><span>(</span><span>uint a</span><span>)</span> <span>public</span> <span>returns</span><span>(</span><span>uint</span><span>)</span><span>{</span>
        <span>return</span> a <span>*</span> <span>10</span><span>;</span>        
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="生命周期-lifecycle" tabindex="-1"> 生命周期 Lifecycle</h3>
<ul>
<li>Mortal - 允许合约自毁</li>
</ul>
<div><pre><code>contract Mortal<span>{</span>
    <span>//自毁</span>
    <span>function</span> <span>destroy</span><span>(</span><span>)</span> <span>public</span><span>{</span>
        <span>//selfdestruct指令，用于销毁合约</span>
        <span>selfdestruct</span><span>(</span>msg<span>.</span>sender<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>
<p>Automatic Deprecation - 允许合约自动停止服务</p>
<p>当用户调用service，notExpired修饰符会先进行日期检测，这样，一旦过了特定时间，调用就会因过期而被拦截在notExpired层。</p>
</li>
</ul>
<div><pre><code>contract AutoDeprecated<span>{</span>

    uint <span>private</span> _deadline<span>;</span>

    <span>function</span> <span>setDeadline</span><span>(</span><span>uint time</span><span>)</span> <span>public</span> <span>{</span>
        _deadline <span>=</span> time<span>;</span>
    <span>}</span>

    modifier <span>notExpired</span><span>(</span><span>)</span><span>{</span>
        <span>require</span><span>(</span>now <span>&lt;=</span> _deadline<span>)</span><span>;</span>
        _<span>;</span>
    <span>}</span>

    <span>function</span> <span>service</span><span>(</span><span>)</span> <span>public</span> notExpired<span>{</span>
        <span>//some code    </span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="权限-authorization" tabindex="-1"> 权限 Authorization</h3>
<ul>
<li>Ownership</li>
</ul>
<div><pre><code>contract Ownable <span>{</span>
    address <span>public</span> owner<span>;</span>

    event <span>OwnershipRenounced</span><span>(</span>address indexed previousOwner<span>)</span><span>;</span>
    event <span>OwnershipTransferred</span><span>(</span>
        address indexed previousOwner<span>,</span>
        address indexed newOwner
    <span>)</span><span>;</span>

    <span>constructor</span><span>(</span><span>)</span> <span>public</span> <span>{</span>
        owner <span>=</span> msg<span>.</span>sender<span>;</span>
    <span>}</span>

    modifier <span>onlyOwner</span><span>(</span><span>)</span> <span>{</span>
        <span>require</span><span>(</span>msg<span>.</span>sender <span>==</span> owner<span>)</span><span>;</span>
        _<span>;</span><span>//表示所修饰函数中的代码,也就是将这个 require 在最前面执行</span>
    <span>}</span>

    <span>function</span> <span>transferOwnership</span><span>(</span><span>address newOwner</span><span>)</span> <span>public</span> onlyOwner <span>{</span>
        <span>require</span><span>(</span>newOwner <span>!=</span> <span>address</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>
        emit <span>OwnershipTransferred</span><span>(</span>owner<span>,</span> newOwner<span>)</span><span>;</span>
        owner <span>=</span> newOwner<span>;</span>
    <span>}</span>

    <span>function</span> <span>renounceOwnership</span><span>(</span><span>)</span> <span>public</span> onlyOwner <span>{</span>
        emit <span>OwnershipRenounced</span><span>(</span>owner<span>)</span><span>;</span>
        owner <span>=</span> <span>address</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>//继承并添加修饰器</span>
contract Biz is Owned<span>{</span>
    <span>function</span> <span>manage</span><span>(</span><span>)</span> <span>public</span> onlyOwner<span>{</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="行为控制-action-and-control" tabindex="-1"> 行为控制 Action And Control</h3>
<ul>
<li>Commit - Reveal - 延迟秘密泄露
Commit And Reveal模式允许用户将要保护的数据转换为不可识别数据，比如一串哈希值，直到某个时刻再揭示哈希值的含义，展露真正的原值。<br>
以投票场景举例，假设需要在所有参与者都完成投票后再揭示投票内容，以防这期间参与者受票数影响</li>
</ul>
<div><pre><code>contract CommitReveal <span>{</span>
    struct Commit <span>{</span>
        string choice<span>;</span>
        string secret<span>;</span>
        uint status<span>;</span>
    <span>}</span>
    <span>mapping</span><span>(</span><span>address</span> <span>=></span> <span>mapping</span><span>(</span><span>bytes32</span> <span>=></span> Commit<span>)</span><span>)</span> <span>public</span> userCommits<span>;</span>
    event <span>LogCommit</span><span>(</span>bytes32<span>,</span> address<span>)</span><span>;</span>
    event <span>LogReveal</span><span>(</span>bytes32<span>,</span> address<span>,</span> string<span>,</span> string<span>)</span><span>;</span>

    <span>function</span> <span>commit</span><span>(</span><span>bytes32 commit</span><span>)</span> <span>public</span> <span>{</span>
        Commit storage userCommit <span>=</span> userCommits<span>[</span>msg<span>.</span>sender<span>]</span><span>[</span>commit<span>]</span><span>;</span>
        <span>require</span><span>(</span>userCommit<span>.</span>status <span>==</span> <span>0</span><span>)</span><span>;</span>
        userCommit<span>.</span>status <span>=</span> <span>1</span><span>;</span> <span>// comitted</span>
        emit <span>LogCommit</span><span>(</span>commit<span>,</span> msg<span>.</span>sender<span>)</span><span>;</span>
    <span>}</span>

    <span>function</span> <span>reveal</span><span>(</span><span>string choice<span>,</span> string secret<span>,</span> bytes32 commit</span><span>)</span> <span>public</span> <span>{</span>
        Commit storage userCommit <span>=</span> userCommits<span>[</span>msg<span>.</span>sender<span>]</span><span>[</span>commit<span>]</span><span>;</span>
        <span>require</span><span>(</span>userCommit<span>.</span>status <span>==</span> <span>1</span><span>)</span><span>;</span>
        <span>require</span><span>(</span>commit <span>==</span> <span>keccak256</span><span>(</span>choice<span>,</span> secret<span>)</span><span>)</span><span>;</span>
        userCommit<span>.</span>choice <span>=</span> choice<span>;</span>
        userCommit<span>.</span>secret <span>=</span> secret<span>;</span>
        userCommit<span>.</span>status <span>=</span> <span>2</span><span>;</span>
        emit <span>LogReveal</span><span>(</span>commit<span>,</span> msg<span>.</span>sender<span>,</span> choice<span>,</span> secret<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>Oracle - 读取链外数据
获取外部数据会通过名为Oracle的链外数据层来执行。当业务方的合约尝试获取外部数据时，会先将查询请求存入到某个Oracle专用合约内；Oracle会监听该合约，读取到这个查询请求后，执行查询，并调用业务合约响应接口使合约获取结果。
<img src="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/contract-oracle.png" alt="oracle"></li>
</ul>
<div><pre><code>contract Oracle <span>{</span>
    address oracleSource <span>=</span> <span>0x123</span><span>;</span> <span>// known source</span>

    struct Request <span>{</span>
        bytes data<span>;</span>
        <span>function</span><span>(</span><span>bytes memory</span><span>)</span> external callback<span>;</span>
    <span>}</span>

    Request<span>[</span><span>]</span> requests<span>;</span>
    event <span>NewRequest</span><span>(</span>uint<span>)</span><span>;</span>
    modifier <span>onlyByOracle</span><span>(</span><span>)</span> <span>{</span>
        <span>require</span><span>(</span>msg<span>.</span>sender <span>==</span> oracleSource<span>)</span><span>;</span> _<span>;</span>
    <span>}</span>

    <span>function</span> <span>query</span><span>(</span><span>bytes data<span>,</span> <span>function</span><span>(</span><span>bytes memory</span><span>)</span> external callback</span><span>)</span> <span>public</span> <span>{</span>
        requests<span>.</span><span>push</span><span>(</span><span>Request</span><span>(</span>data<span>,</span> callback<span>)</span><span>)</span><span>;</span>
        emit <span>NewRequest</span><span>(</span>requests<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>//回调函数，由Oracle调用</span>
    <span>function</span> <span>reply</span><span>(</span><span>uint requestID<span>,</span> bytes response</span><span>)</span> <span>public</span> <span>onlyByOracle</span><span>(</span><span>)</span> <span>{</span>
        requests<span>[</span>requestID<span>]</span><span>.</span><span>callback</span><span>(</span>response<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
contract BizContract <span>{</span>
    Oracle _oracle<span>;</span>

    <span>constructor</span><span>(</span><span>address oracle</span><span>)</span><span>{</span>
        _oracle <span>=</span> <span>Oracle</span><span>(</span>oracle<span>)</span><span>;</span>
    <span>}</span>

    modifier <span>onlyByOracle</span><span>(</span><span>)</span> <span>{</span>
        <span>require</span><span>(</span>msg<span>.</span>sender <span>==</span> <span>address</span><span>(</span>_oracle<span>)</span><span>)</span><span>;</span>
        _<span>;</span>
    <span>}</span>

    <span>function</span> <span>updateExchangeRate</span><span>(</span><span>)</span> <span>{</span>
        _oracle<span>.</span><span>query</span><span>(</span><span>"USD"</span><span>,</span> <span>this</span><span>.</span>oracleResponse<span>)</span><span>;</span>
    <span>}</span>

    <span>//回调函数，用于读取响应</span>
    <span>function</span> <span>oracleResponse</span><span>(</span><span>bytes response</span><span>)</span> onlyByOracle <span>{</span>
    <span>// use the data</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="闪电网络" tabindex="-1"> 闪电网络</h2>
<h3 id="rsmc" tabindex="-1"> RSMC</h3>
<p>Revocable Sequence Maturity Contract（序列到期可撤销合约）</p>
<h3 id="htlc" tabindex="-1"> HTLC</h3>
<p>Hashed Timelock Contract（哈希时间锁定）</p>
]]></content:encoded>
      <enclosure url="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/contract-oracle.png" type="image/png"/>
    </item>
    <item>
      <title>比特币白皮书</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/The_white_paper_the_currency.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/The_white_paper_the_currency.html</guid>
      <source url="https://bytecodes.tech/rss.xml">比特币白皮书</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识 P2P网络 Solidity 比特币</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>比特币 white paper中英文对照版本，保持英文原版只字不差，排版尽量模拟原版</p>
</blockquote>
<p>Satoshi Nakamoto<br>
<a href="mailto:satoshin@gmx.com">satoshin@gmx.com</a><br>
<a href="http://www.bitcoin.org" target="_blank" rel="noopener noreferrer">www.bitcoin.org</a></p>
<blockquote>
<p><strong>Abstract.</strong>   A  purely   peer-to-peer   version   of   electronic   cash   would   allow   onlinepayments   to   be   sent   directly   from   one   party   to   another   without   going   through   afinancial institution.   Digital signatures provide part of the solution, but the mainbenefits are lost if a trusted third party is still required to prevent double-spending.We propose a solution to the double-spending problem using a peer-to-peer network.The   network   timestamps   transactions   by   hashing   them   into   an   ongoing   chain   ofhash-based proof-of-work, forming a record that cannot be changed without redoingthe proof-of-work.   The longest chain not only serves as proof of the sequence ofevents witnessed, but proof that it came from the largest pool of CPU power.   Aslong as a majority of CPU power is controlled by nodes that are not cooperating toattack the network,  they'll  generate the  longest  chain  and  outpace attackers.   Thenetwork itself requires minimal structure.   Messages are broadcast on a best effortbasis,   and   nodes   can   leave   and   rejoin   the   network   at   will,   accepting   the   longestproof-of-work chain as proof of what happened while they were gone.</p>
</blockquote>
<blockquote>
<p><strong>摘要。</strong> 一种完全的点对点电子现金应当允许在线支付从一方直接发送到另一方而不需要通过一个金融机构。数字签名提供了部分解决方案，但如果仍需一个可信任第三方来防止双重支付，那就失去了电子货币的主要优点。我们提出一种使用点对点网络解决双重支付问题的方案。该网络通过将交易哈希进一条持续增长的基于哈希的工作量证明链来给交易打上时间戳，形成一条除非重做工作量证明否则不能更改的记录。最长的链不仅是被见证事件序列的证据，而且也是它本身是由最大 CPU 算力池产生的证据。只要多数的 CPU 算力被不打算联合攻击网络的节点控制，这些节点就将生成最长的链而超过攻击者。这种网络本身只需极简的架构。信息将被尽力广播，节点可以随时离开和重新加入网络，只需接受最长的工作量证明链作为它们离开时发生事件的证据。</p>
</blockquote>
<h2 id="_1-introduction" tabindex="-1"> 1. Introduction</h2>
<p>Commerce on the Internet has come to rely almost exclusively on financial institutions serving astrusted third  parties  to process electronic payments.   While the  system works  well enough formost   transactions,   it   still   suffers   from   the   inherent   weaknesses   of   the   trust   based   model.Completely non-reversible transactions are not really possible, since financial institutions cannotavoid   mediating   disputes.     The   cost   of   mediation   increases   transaction   costs,   limiting   theminimum practical transaction size and cutting off the possibility for small casual transactions,and   there   is   a   broader   cost   in   the   loss   of   ability   to   make   non-reversible   payments   for   non-reversible services.  With the possibility of reversal, the need for trust spreads.  Merchants mustbe wary of their customers, hassling them for more information than they would otherwise need.A certain percentage of fraud is accepted as unavoidable.  These costs and payment uncertaintiescan be avoided in person by using physical currency, but no mechanism exists to make paymentsover a communications channel without a trusted party.What is needed is an electronic payment system based on cryptographic proof instead of trust,allowing any two willing parties to transact directly with each other without the need for a trustedthird  party.
Transactions  that  are  computationally  impractical  to   reverse   would  protect  sellersfrom fraud, and routine escrow mechanisms could easily be implemented to protect buyers.   Inthis paper, we propose a solution to the double-spending problem using a peer-to-peer distributedtimestamp server to generate computational proof of the chronological order of transactions.  Thesystem   is   secure   as   long   as   honest   nodes   collectively   control   more   CPU   power   than   anycooperating group of attacker nodes.</p>
<h2 id="_1、简介" tabindex="-1"> 1、简介</h2>
<p>互联网贸易已经变得几乎完全依赖金融机构作为可信任第三方来处理电子支付。尽管对于大部分交易这种系统运行得足够好，但仍需忍受基于信任模型这个固有缺点。由于金融机构不可避免的需要仲裁纠纷，完全的不可撤销交易实际是做不到的。仲裁成本增加了交易成本，限制了最小实际交易额度从而杜绝了日常小额交易的可能性，而且由于不支持不可撤销支付，对不可撤销服务进行支付将需要更大的成本。由于存在交易被撤销的可能性，对于信任的需求将更广泛。商家必须警惕他们的客户，麻烦他们提供更多他本不必要的信息。一定比例的欺诈被认为是不可避免的。虽可通过当面使用实物货币来避免这些成本及支付的不确定性，但不存在不引入一个可信任方而能在通信通道上进行支付的机制。
我们需要的是一个基于密码学原理而不是信任的电子支付系统，该系统允许任何有交易意愿的双方能直接交易而不需要一个可信任第三方。交易在计算上的不可撤销将保护卖家不被欺诈，用来保护买家的程序化合约机制也应该较容易实现。在这篇论文中，我们提出一种使用点对点分布式时间戳服务器为基于时间的交易序列生成计算上的证据来解决双重支付问题的方案。只要诚实节点集体控制的CPU算力大于每一个合作攻击节点群的CPU算力，这个系统就是安全的。</p>
<h2 id="_2-transactions" tabindex="-1"> 2. Transactions</h2>
<p>We define an electronic coin as a chain of digital signatures.  Each owner transfers the coin to thenext by digitally signing a hash of the previous transaction and the public key of the next ownerand adding these to the end of the coin.  A payee can verify the signatures to verify the chain of ownership.</p>
<h2 id="_2、交易" tabindex="-1"> 2、交易</h2>
<p>我们定义一枚电子货币就是一条数字签名链。每个拥有者都通过将上一次交易和下一个拥有者的公钥的哈希值的数字签名添加到此货币末尾的方式将这枚货币转移给下一个拥有者。收款人可以通过验证数字签名来证实其为该链的所有者。
<img src="@source/blockchain/assets/img/bitcoin-1.png" alt="bitcoin">
The problem of course is the payee can't verify that one of the owners did not double-spendthe coin.  A common solution is to introduce a trusted central authority, or mint, that checks everytransaction for double spending.  After each transaction, the coin must be returned to the mint toissue a new coin, and only coins issued directly from the mint are trusted not to be double-spent.The   problem   with   this   solution   is   that   the   fate   of   the   entire   money   system   depends   on   thecompany running the mint, with every transaction having to go through them, just like a bank.<br>
We   need   a   way   for   the   payee   to   know   that   the   previous   owners   did   not   sign   any   earliertransactions.   For our purposes, the earliest transaction is the one that counts, so we don't careabout later attempts to double-spend.  The only way to confirm the absence of a transaction is tobe aware of all transactions.  In the mint based model, the mint was aware of all transactions anddecided   which   arrived   first.    To  accomplish   this   without   a   trusted   party,   transactions   must   bepublicly announced [1], and we need a system for participants to agree on a single history of theorder in which they were received.  The payee needs proof that at the time of each transaction, themajority of nodes agreed it was the first received.<br>
这里的问题是收款人不能证实拥有者之一没有对此货币进行双重支付。通常的做法是引入一个可信任的中央机构或铸币厂来检查每笔交易是否存在双重支付。每笔交易之后，都需要将这枚货币退回铸币厂以换取发行一枚新的货币，只有由铸币厂直接发行的货币才能被确认没有被双重支付。这个方案的问题在于整个货币系统的命运都依赖于运营铸币厂的公司，每笔交易都需要经过它们，就像银行一样。<br>
我们需要一种能让收款人知道上一个货币拥有者 没有对任何更早的交易签名的方法。对我们来说，最早的那次交易是唯一有效的，所以我们不需要关心本次交易后面的双重支付尝试 。唯一能确保一笔交易不存在的方法是知晓所有之前的交易。在铸币厂模型中，铸币厂知晓所有交易并能确定哪笔交易最先到达。在不引入一个可信任方的前提下要达到这个目的， 所有交易就必须公开发布[1]，而且需要一个能让所有参与者对交易收到顺序的单一历史达成共识的系统。收款人在每笔交易时，都需要多数节点认同此交易是最先收到的证据。</p>
<h2 id="_3-timestamp-server" tabindex="-1"> 3. Timestamp Server</h2>
<p>The solution we propose begins with a timestamp server.  A timestamp server works by taking ahash   of   a   block   of   items   to   be   timestamped   and   widely   publishing   the   hash,   such   as   in   anewspaper or Usenet post [2-5].   The timestamp proves that the data must have existed at thetime, obviously, in order to get into the hash.  Each timestamp includes the previous timestamp inits hash, forming a chain, with each additional timestamp reinforcing the ones before it.</p>
<h2 id="_3、时间戳服务器" tabindex="-1"> 3、时间戳服务器</h2>
<p>我们提出的方案从时间戳服务器开始。时间戳服务器计算包含 多个需要被打时间戳的数据项的区块 的哈希  值并 广泛 地发布这个哈希值，就 像在报纸或  新闻组帖  子里[2-5]。时间戳能证明要得到这个哈希值，显然这些数据当时一定是存在的。每个时间戳的哈希值都纳 入了上一个时间戳，形成一条链，后面的时间戳进一步增强前一个时间戳。</p>
<p><img src="@source/blockchain/assets/img/bitcoin-2.png" alt="bitcoin"></p>
<h2 id="_4-proof-of-work" tabindex="-1"> 4. Proof-of-Work</h2>
<p>To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system  similar to Adam  Back's  Hashcash  [6],  rather than  newspaper  or  Usenet  posts.The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, thehash begins with a number of zero bits.  The average work required is exponential in the numberof zero bits required and can be verified by executing a single hash.<br>
For our timestamp network, we implement the proof-of-work by incrementing a nonce in theblock until a value is found that gives the block's hash the required zero bits.   Once the CPUeffort   has   been   expended   to   make   it   satisfy   the   proof-of-work,   the   block   cannot   be   changedwithout  redoing  the   work.    As   later   blocks   are  chained   after  it,   the  work  to  change  the  blockwould include redoing all the blocks after it.</p>
<h2 id="_4、工作量证明" tabindex="-1"> 4、工作量证明</h2>
<p>为了实现一个基于点对点的时间戳服务器，我们需要使用一个类似Adam Back 提出的哈希货币[6] 的工作量证明系统，而不是报纸或新闻组帖子那样。工作量证明采取搜索一个数，使得被哈希时，如使用SHA-256，得到的哈希值以数个0比特开始。平均所需工作量将随所需 0比特呈指数级增长而验证却只需执行一次哈希。<br>
对于我们的时间戳网络。我们通过在区块中加入一个随机数，直到使得区块的哈希值满足所需0比特的数被找到的方式实现工作量证明。一旦消耗了CPU算力使区块满足了工作量证明，那么除非重做这个工作否则就无法更改 区块 。由于后面的区块是链接在这个区块后面的，改变这个区块将需要重做所有后面的区块。
<img src="@source/blockchain/assets/img/bitcoin-pow.png" alt="bitcoin">
The proof-of-work also solves the problem of determining representation in majority decisionmaking.  If the majority were based on one-IP-address-one-vote, it could be subverted by anyoneable   to   allocate   many   IPs.     Proof-of-work   is   essentially   one-CPU-one-vote.     The   majoritydecision is represented by the longest chain, which has the greatest proof-of-work effort investedin it.  If a majority of CPU power is controlled by honest nodes, the honest chain will grow thefastest and outpace any competing chains.   To modify a past block, an attacker would have toredo the proof-of-work of the block and all blocks after it and then catch up with and surpass thework of the honest nodes.  We will show later that the probability of a slower attacker catching updiminishes exponentially as subsequent blocks are added.<br>
To compensate for increasing hardware speed and varying interest in running nodes over time,the proof-of-work difficulty is determined by a moving average targeting an average number ofblocks per hour.  If they're generated too fast, the difficulty increases.<br>
工作量证明同时解决了在多数决定中确定投票方式的问题。如果多数是按IP地址投票来决定，那么它将可能被能分配大量IP 地址的人破坏 。工作量证明本质上是 按CPU 投票。最长的链代表了多数决定，因为有最大的计算工作量证明的精力投入到这条链上。如果多数的CPU算力被诚实节点控制，诚实的链就会增长得最快并超过其他的竞争链。要修改过去的某区块，攻击者必须重做这个区块以及其后的所有区块的工作量证明从而赶上并超过诚实节点的工作。我们后面会证明随着后续的区块被添加一个更慢的攻击者赶上诚实节点的概率将呈指数级递减。<br>
为了抵消硬件运算速度的增加及平衡不同时期运行节点的利益，工作量证明的难度将由移动平均数法来确定每小时生成区块的平均数。如果区块生成得过快，那么生成的难度就会增加。</p>
<h2 id="_5-network" tabindex="-1"> 5. Network</h2>
<p>The steps to run the network are as follows:</p>
<ol>
<li>New transactions are broadcast to all nodes.</li>
<li>Each node collects new transactions into a block.</li>
<li>Each node works on finding a difficult proof-of-work for its block.</li>
<li>When a node finds a proof-of-work, it broadcasts the block to all nodes.</li>
<li>Nodes accept the block only if all transactions in it are valid and not already spent.</li>
<li>Nodes express their acceptance of the block by working on creating the next block in thechain, using the hash of the accepted block as the previous hash.</li>
</ol>
<p>Nodes   always   consider   the   longest   chain   to   be   the   correct   one   and   will   keep   working   onextending it.   If two nodes broadcast different versions of the next block simultaneously, somenodes may receive one or the other first.  In that case, they work on the first one they received,but save the other branch in case it becomes longer.  The tie will be broken when the next proof-of-work   is   found   and   one   branch   becomes   longer;   the   nodes   that   were   working   on   the   otherbranch will then switch to the longer one.<br>
New transaction broadcasts do not necessarily need to reach all nodes.  As long as they reachmany nodes, they will get into a block before long.  Block broadcasts are also tolerant of droppedmessages.  If a node does not receive a block, it will request it when it receives the next block andrealizes it missed one.</p>
<h2 id="_5、网络" tabindex="-1"> 5、网络</h2>
<p>运行网络的步骤如下：</p>
<ol>
<li>新交易向所有节点广播。</li>
<li>每个节点将新交易收集到一个区块。</li>
<li>每个节点为它的区块寻找工作量证明。</li>
<li>当一个节点找到了工作量证明，就向所有节点广播这个区块。</li>
<li>节点只有在区块内所有交易都是有效的且之前没有被支付的情况下接收这个区块。</li>
<li>节点通过使用这个区块的哈希值作为上一个哈希值在链中创建下一个区块的方式表示对这个区块的接受。</li>
</ol>
<p>节点总是认为最长的链为正确的并持续致力于延长它。如果两个节点同时广播了不同的下一个区块，有些节点可能先收到其中一个而其他节点先收到另一个。这种情况，节点基于他们收到的第一个区块工作，但是也保存另一个分支以防它变为更长的链。当下一个工作量证明被找到后，僵局就会被打破从而其中一个分支变得更长；在另一个分支上工作的节点将切换到更长的链上来。新交易的广播不必到达所有的节点。只要到达一些节点，不久就会进入到一个区块 。区块广播也是能容忍消息丢失的。如果一个节点没有收到某个区块 ，它将在收到下一个区块时发现它丢失了一个区块然后去请求这个区块。</p>
<h2 id="_6-incentive" tabindex="-1"> 6. Incentive</h2>
<p>By convention, the first transaction in a block is a special transaction that starts a new coin ownedby the creator of the block.  This adds an incentive for nodes to support the network, and providesa way to initially distribute coins into circulation, since there is no central authority to issue them.The steady addition of a constant of amount of new coins is analogous to gold miners expendingresources to add gold to circulation.  In our case, it is CPU time and electricity that is expended.<br>
The incentive can also be funded with transaction fees.  If the output value of a transaction isless than its input value, the difference is a transaction fee that is added to the incentive value ofthe   block   containing   the   transaction.     Once   a   predetermined   number   of   coins   have   enteredcirculation, the incentive can transition entirely to transaction fees and be completely inflationfree.<br>
The   incentive   may   help   encourage   nodes   to   stay   honest.     If   a   greedy   attacker   is   able   toassemble more CPU power than all the honest nodes, he would have to choose between using itto defraud people by stealing back his payments, or using it to generate new coins.  He ought tofind it more profitable to play by the rules, such rules that favour him with more new coins thaneveryone else combined, than to undermine the system and the validity of his own wealth.</p>
<h2 id="_6、激励" tabindex="-1"> 6、激励</h2>
<p>我们约定，区块中的第一笔交易是区块创建者开启一枚属于他的新货币的特殊的交易。这就增加了对支持网络的节点的激励 ，并提供了一种分发货币到流通领域的方法，因为这里没有中央机构来发行货币。新货币按固定量  稳定地增加就像金矿矿工消耗资源并增加黄金到流通领域一样。对我们而言，消耗的是 CPU 时间和电力。<br>
激励也可以由交易费充当。如果交易的输出值小于其输入值，差价就作为交易费被加到包含此交易的区块的激励中  。一旦预定量的货币进入了流通领域，激励将变为只含有交易费，这样可以完全避免通货膨胀。<br>
激励会有助于鼓励节点保持诚实。如果一个贪心的攻击者有能力聚集比所有诚实节点更多的CPU算力，他将面临是以骗回已付款的方式欺诈别人还是使用这些算力生成新货币的抉择。他将发现遵守规则比破坏系统和他自己财产的有效性更有利，因为这些规则准许他获得比所有其他人都多的新货币。</p>
<h2 id="_7-reclaiming-disk-space" tabindex="-1"> 7. Reclaiming Disk Space</h2>
<p>Once the latest transaction in a coin is buried under enough blocks, the spent transactions beforeit   can   be   discarded   to   save   disk   space.     To   facilitate   this   without   breaking   the   block's   hash,transactions are hashed in a Merkle Tree [7][2][5], with only the root included in the block's hash.Old blocks can then be compacted by stubbing off branches of the tree.   The interior hashes donot need to be stored.</p>
<h2 id="_7、回收磁盘空间" tabindex="-1"> 7、回收磁盘空间</h2>
<p>一旦某个货币的最新交易已经被足够多的区块覆盖，这之前的支付交易就可以被丢弃 以节省磁盘空间。为便于此而又不破坏区块的哈希值，交易将被哈希进默克尔树[7][2][5]，只有根节点被纳入到区块的哈希值。老的区块可通过剪除树枝的方式被压缩。树枝内部的哈希不需要被保存。</p>
<p><img src="@source/blockchain/assets/img/bitcoin-disk-space.png" alt="bitcoin"></p>
<p>A  block   header   with   no   transactions   would   be   about   80   bytes.     If   we   suppose   blocks   aregenerated every 10 minutes, 80 bytes <em>6</em> 24 * 365 = 4.2MB per year.  With computer systemstypically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of1.2GB   per   year,   storage   should   not   be   a   problem   even   if   the   block   headers   must   be   kept   inmemory.</p>
<p>每个不包含交易的区块头大约是 80 bytes。如果每10分钟生成一个区块 ，每年生成 80bytes <em>6</em> 24 * 365 = 4.2MB，2008年在售的典型计算机有2GB内存， 并且摩尔定律预测目前每年内存增加 1.2GB，所以就算区块头一定要存在内存里，存储也不是问题。</p>
<h2 id="_8-simplified-payment-verification" tabindex="-1"> 8. Simplified Payment Verification</h2>
<p>It is possible to verify payments without running a full network node.  A user only needs to keepa copy of the block headers of the longest proof-of-work chain, which he can get by queryingnetwork   nodes   until   he's   convinced   he   has   the   longest   chain,   and   obtain   the   Merkle   branchlinking   the   transaction   to   the   block   it's   timestamped   in.     He   can't   check   the   transaction   forhimself, but by linking it to a place in the chain, he can see that a network node has accepted it,and blocks added after it further confirm the network has accepted it.</p>
<h2 id="_8、-简化的支付验证" tabindex="-1"> 8、 简化的支付验证</h2>
<p>不运行一个完整的网络节点也是可以进行支付验证的。用户只需拥有一个最长工作量证明链的区块头副本，他可以通过向其他网络节点查询以确认他拥有了最长的链，并获取链接交易到给交易打时间戳区块的默克尔分支。虽然他自己不能核实这个交易，但如果交易已经链接到到链中的某个位置，就说明一个网络节点已经接受了此交易，而其后追加的区块进一步确认网络已经接受了它。</p>
<p><img src="@source/blockchain/assets/img/bitcoin-simplified-payment.png" alt="bitcoin"></p>
<p>As such, the verification is reliable as long as honest nodes control the network, but is morevulnerable   if   the   network   is   overpowered   by   an   attacker.     While   network   nodes   can   verifytransactions   for   themselves,   the   simplified   method   can   be   fooled   by   an   attacker's   fabricatedtransactions for as long as the attacker can continue to overpower the network.   One strategy toprotect against this would be to accept alerts from network nodes when they detect an invalidblock,   prompting   the   user's   software   to   download   the   full   block   and   alerted   transactions   toconfirm the inconsistency.  Businesses that receive frequent payments will probably still want torun their own nodes for more independent security and quicker verification.<br>
同样地，只要诚实节点控制着网络这种简化验证就是可靠的，如果网络被攻击者控制简化验证会变得比较脆弱 。虽然网络节点可以验证他们自己的交易，但只要攻击者持续控制网络那么这种简化的方法就可能被攻击者的伪造交易欺骗。一种对策是接受其他网络节点发现一个无效区块时发出的警告，提醒用户软件下载整个区块和被警告的交易来检查一致性。为了更加独立的安全性以及更快的支付确认，收款频繁的公司可能仍需运行他们自己的节点。</p>
<h2 id="_9-combining-and-splitting-value" tabindex="-1"> 9. Combining and Splitting Value</h2>
<p>Although   it   would   be   possible   to   handle   coins   individually,   it   would   be   unwieldy   to   make   aseparate   transaction   for   every   cent   in   a   transfer.     To   allow   value   to   be   split   and   combined,transactions  contain  multiple  inputs  and  outputs.    Normally  there will  be either  a  single  inputfrom a larger previous transaction or multiple inputs combining smaller amounts, and at most twooutputs: one for the payment, and one returning the change, if any, back to the sender.</p>
<h2 id="_9、合并和分割交易额" tabindex="-1"> 9、合并和分割交易额</h2>
<p>尽管单独处理每个货币是可行的，但将一次转账按每一分拆成多次交易是笨拙的。为允许交易额被分割和合并，交易将包含多个输入值和输出值。通常是一个从之前交易而得的较大输入值或多个较小输入值的组合，以及最多两个输出值：一个作为支付，另一个作为找零，如果有的话，退还给支付发送方。</p>
<p><img src="@source/blockchain/assets/img/bitcoin-transaction.png" alt="bitcoin"></p>
<p>It should be noted that fan-out, where a transaction depends on several transactions, and thosetransactions depend on many more, is not a problem here.   There is never the need to extract acomplete standalone copy of a transaction's history.<br>
注意这里的扇出，即一笔交易依赖数笔交易，这数笔交易又依赖更多的交易，在这里是不存在问题的。永远不会需要获取一笔交易历史的完整独立副本。</p>
<h2 id="_10-privacy" tabindex="-1"> 10. Privacy</h2>
<p>The traditional banking model achieves a level of privacy by limiting access to information to theparties involved and the trusted third party.   The necessity to announce all transactions publiclyprecludes this method, but privacy can still be maintained by breaking the flow of information inanother place: by keeping public keys anonymous.   The public can see that someone is sendingan amount to someone else, but without information linking the transaction to anyone.   This issimilar   to   the   level   of   information   released   by   stock   exchanges,   where   the   time   and   size   ofindividual trades, the &quot;tape&quot;, is made public, but without telling who the parties were.</p>
<h2 id="_10、隐私" tabindex="-1"> 10、隐私</h2>
<p>传统的银行模型通过限制参与方和可信任第三方对信息的访问来达到一定级别的隐私。交易必须要公开发布就不能使用这个方法，但隐私仍可在其他地方通过阻断信息流的方式来保护：那就是保持公钥匿名。 公众能看到有人正在发送一定量货币给其他人，但是不能将交易关联到某个人。这和证券交易所发布的信息级别类似，每笔交易的时间和交易量，即行情是公开的，但是不会显示交易双方是谁。</p>
<p><img src="@source/blockchain/assets/img/bitcoin-privacy.png" alt="bitcoin"></p>
<p>As an additional firewall, a new key pair should be used for each transaction to keep themfrom   being   linked   to   a   common   owner.     Some   linking   is   still   unavoidable   with   multi-inputtransactions, which necessarily reveal that their inputs were owned by the same owner.  The riskis that if the owner of a key is revealed, linking could reveal other transactions that belonged tothe same owner.<br>
作为额外的防火墙 ，对每笔交易使用新密钥对可以防止他们被关联到一个共同的拥有者。由于多输入值交易存在，有些关联仍不可避免，因为多输入值交易必然暴露其多个输入是属于同一个拥有者的。风险就在于如果一个密钥的拥有者被暴露，关联性将暴露其他属于同一个拥有者的交易。</p>
<h2 id="_11-calculations" tabindex="-1"> 11. Calculations</h2>
<p>We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent.</p>
<h2 id="_11、计算" tabindex="-1"> 11、计算</h2>
<p>假设一个场景，某个攻击者正在试图生成一个比诚实链更快的替代链。就算他成功了，也不能对系统做任意的修改，即，他不可能凭空制造出价值，也无法获取从未属于他的钱。网络节点不会把一笔无效交易当作支付，而诚实节点也永远不会接受一个包含这种支付的区块。攻击者最多只能修改属于他自己的交易，进而试图取回他已经花出去的钱。</p>
<p>The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker's chain being extended by one block, reducing the gap by -1.</p>
<p>诚实链和攻击者之间的竞争可以用二项式随机漫步来描述。成功事件是诚实链刚刚被添加了一个新的区块，使得它的优势增加了 1；而失败事件是攻击者的链刚刚被增加了一个新的区块，使得诚实链的优势减少了 1。</p>
<p>The probability of an attacker catching up from a given deficit is analogous to a Gambler's Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows[8]:</p>
<p>攻击者能够从落后局面追平的概率类似于赌徒破产问题。假设，一个拿着无限筹码的赌徒，从亏空开始，允许他赌无限次，目标是填补上已有的亏空。我们能算出他最终能填补亏空的概率，也就是攻击者能够赶上诚实链的概率[8]，如下：</p>
<p>$$
\begin{eqnarray*}
\large p &amp;=&amp; \text{ 诚实节点找到下一个区块的概率}\
\large q &amp;=&amp; \text{ 攻击者找到下一个区块的概率}\
\large q_z &amp;=&amp; \text{ 攻击者落后 $z$ 个区块却依然能够赶上的概率}
\end{eqnarray*}
$$</p>
<p>$$
\large q_z = \begin{Bmatrix}
1 &amp; \textit{if}; p \leq q\
(q/p)^z &amp; \textit{if}; p &gt; q
\end{Bmatrix}
$$</p>
<p>Given our assumption that $p \gt q$, the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn't make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind.</p>
<p>既然我们已经假定 $p &gt; q$, 既然攻击者需要赶超的区块数量越来越多，那么其成功概率就会指数级下降。于赢面不利时，如果攻击者没有在起初就能幸运地做一个前移步刺，那么他的胜率将在他进一步落后的同时消弭殆尽。</p>
<p>We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can't change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late.</p>
<p>现在考虑一下一笔新交易的收款人需要等多久才能充分确定发款人不能更改这笔交易。我们假定发款人是个攻击者，妄图让收款人在一段时间里相信他已经支付对付款项，随后将这笔钱再转回给自己。发生这种情况时，收款人当然会收到警告，但发款人希望那时木已成舟。</p>
<p>The receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction.</p>
<p>收款人生成了一对新的公私钥，而后在签署之前不久将公钥告知发款人。这样可以防止一种情形：发款人提前通过连续运算去准备一条链上的区块，并且只要有足够的运气就会足够领先，直到那时再执行交易。一旦款项已被发出，那个不诚实的发款人开始秘密地在另一条平行链上开工，试图在其中加入一个反向版本的交易。</p>
<p>The recipient waits until the transaction has been added to a block and $z$ blocks have been linked after it. He doesn't know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker's potential progress will be a Poisson distribution with expected value:</p>
<p>收款人等到此笔交易被打包进区块，并已经有 $z$ 个区块随后被加入。他并不知道攻击者的工作进展究竟如何，但是可以假定诚实区块在每个区块生成过程中耗费的平均时间；攻击者的潜在进展符合泊松分布，其期望值为：</p>
<p>$$
\large \lambda = z \frac qp
$$</p>
<p>To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point:</p>
<p>为了算出攻击者依然可以赶上的概率，我们要把每一个攻击者已有的进展的帕松密度乘以他可以从那一点能够追上来的概率：</p>
<p>$$
\large \sum_{k=0}^{\infty} \frac{\lambda^k e^{-\lambda}}{k!} \cdot
\begin{Bmatrix}
(q/p)^{(z-k)} &amp; \textit{if};k\leq z\
1 &amp; \textit{if} ; k &gt; z
\end{Bmatrix}
$$</p>
<p>Rearranging to avoid summing the infinite tail of the distribution...</p>
<p>为了避免对密度分布的无穷级数求和重新整理…</p>
<p>$$
\large 1 - \sum_{k=0}^{z} \frac{\lambda^k e^{-\lambda}}{k!}
\left ( 1-(q/p)^{(z-k)} \right )
$$</p>
<p>Converting to C code...</p>
<p>转换为 C 语言程序……</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;math.h></span></span>
<span>double</span> <span>AttackerSuccessProbability</span><span>(</span><span>double</span> q<span>,</span> <span>int</span> z<span>)</span>
<span>{</span>
 <span>double</span> p <span>=</span> <span>1.0</span> <span>-</span> q<span>;</span>
 <span>double</span> lambda <span>=</span> z <span>*</span> <span>(</span>q <span>/</span> p<span>)</span><span>;</span>
 <span>double</span> sum <span>=</span> <span>1.0</span><span>;</span>
 <span>int</span> i<span>,</span> k<span>;</span>
 <span>for</span> <span>(</span>k <span>=</span> <span>0</span><span>;</span> k <span>&lt;=</span> z<span>;</span> k<span>++</span><span>)</span>
 <span>{</span>
  <span>double</span> poisson <span>=</span> <span>exp</span><span>(</span><span>-</span>lambda<span>)</span><span>;</span>
  <span>for</span> <span>(</span>i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> k<span>;</span> i<span>++</span><span>)</span>
   poisson<span>*=</span>lambda <span>/</span> i<span>;</span>
  sum <span>-=</span> poisson <span>*</span> <span>(</span><span>1</span> <span>-</span> <span>pow</span><span>(</span>q <span>/</span> p<span>,</span> z <span>-</span> k<span>)</span><span>)</span><span>;</span>
 <span>}</span>
 <span>return</span> sum<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Running some results, we can see the probability drop off exponentially with $z$.</p>
<p>获取部分结果，我们可以看到概率随着 $z$ 的增加指数级下降：</p>
<div><pre><code>   q=0.1
   z=0    P=1.0000000
   z=1    P=0.2045873
   z=2    P=0.0509779
   z=3    P=0.0131722
   z=4    P=0.0034552
   z=5    P=0.0009137
   z=6    P=0.0002428
   z=7    P=0.0000647
   z=8    P=0.0000173
   z=9    P=0.0000046
   z=10   P=0.0000012

   q=0.3
   z=0    P=1.0000000
   z=5    P=0.1773523
   z=10   P=0.0416605
   z=15   P=0.0101008
   z=20   P=0.0024804
   z=25   P=0.0006132
   z=30   P=0.0001522
   z=35   P=0.0000379
   z=40   P=0.0000095
   z=45   P=0.0000024
   z=50   P=0.0000006
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Solving for P less than 0.1%...</p>
<p>若是 P 小于 0.1%……</p>
<div><pre><code>   P &lt; 0.001
   q=0.10   z=5
   q=0.15   z=8
   q=0.20   z=11
   q=0.25   z=15
   q=0.30   z=24
   q=0.35   z=41
   q=0.40   z=89
   q=0.45   z=340
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_12-conclusion" tabindex="-1"> 12. Conclusion</h2>
<p>We have proposed a system for electronic transactions without relying on trust. We started with the usual framework of coins made from digital signatures, which provides strong control of ownership, but is incomplete without a way to prevent double-spending. To solve this, we proposed a peer-to-peer network using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes control a majority of CPU power. The network is robust in its unstructured simplicity. Nodes work all at once with little coordination. They do not need to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis. Nodes can leave and rejoin the network at will, accepting the proof-of-work chain as proof of what happened while they were gone. They vote with their CPU power, expressing their acceptance of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them. Any needed rules and incentives can be enforced with this consensus mechanism.</p>
<h2 id="_12、总结" tabindex="-1"> 12、总结</h2>
<p>我们已经提出了一种不依赖信任的电子交易系统。我们从通用的数字签名货币体系开 始，这体系提供了强有力的 所有权控制，但由于缺乏防止双重支付的方法而不完  善。为解决这个问题，我们提出一种使用工作量证明来记录公共交易历史的点对点网络，只要诚实节点控制了多数的CPU算力，对于对攻击者，交易历史 将很快变得在  计算上不可更改。网络因其结构简 洁性而健壮。节点只需很少 的协调就能同时工作。它们不需要被认证，因为信息不会被发送到某个特殊 的位置，只需被尽力传播。节点可以随时离开和重新加入网络，只需接受最长的工作量证明链作为它们离开时发生事件的证据。节点使用CPU算力来  投票，通过 致力于 延长有效区块  来表达对其接受，通过拒绝在无效区块上工作来表达对其抵制。任何需要的规则和激励都可通过这个共识机制来加强</p>
<hr>
<h2 id="参考文献-references" tabindex="-1"> 参考文献 (References)</h2>
<ol>
<li><strong>b-money</strong> Dai Wei (1998-11-01) <a href="http://www.weidai.com/bmoney.txt" target="_blank" rel="noopener noreferrer">http://www.weidai.com/bmoney.txt</a></li>
<li><strong>Design of a secure timestamping service with minimal trust requirements</strong> Henri Massias, Xavier Serret-Avila, Jean-Jacques Quisquater <em>20th Symposium on Information Theory in the Benelux</em> (1999-05) <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.6228" target="_blank" rel="noopener noreferrer">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.6228</a></li>
<li>: <strong>How to time-stamp a digital document</strong> Stuart Haber, W.Scott Stornetta <em>Journal of Cryptology</em> (1991) <a href="https://doi.org/cwwxd4" target="_blank" rel="noopener noreferrer">https://doi.org/cwwxd4</a> DOI: <a href="https://doi.org/10.1007/bf00196791" target="_blank" rel="noopener noreferrer">10.1007/bf00196791</a></li>
<li>: <strong>Improving the Efficiency and Reliability of Digital Time-Stamping</strong> Dave Bayer, Stuart Haber, W. Scott Stornetta <em>Sequences II</em> (1993) <a href="https://doi.org/bn4rpx" target="_blank" rel="noopener noreferrer">https://doi.org/bn4rpx</a> DOI: <a href="https://doi.org/10.1007/978-1-4613-9323-8_24" target="_blank" rel="noopener noreferrer">10.1007/978-1-4613-9323-8_24</a></li>
<li>: <strong>Secure names for bit-strings</strong> Stuart Haber, W. Scott Stornetta <em>Proceedings of the 4th ACM conference on Computer and communications security - CCS ’97</em>(1997) <a href="https://doi.org/dtnrf6" target="_blank" rel="noopener noreferrer">https://doi.org/dtnrf6</a> DOI: <a href="https://doi.org/10.1145/266420.266430" target="_blank" rel="noopener noreferrer">10.1145/266420.266430</a></li>
<li>: <strong>Hashcash - A Denial of Service Counter-Measure</strong> Adam Back (2002-08-01) <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.8" target="_blank" rel="noopener noreferrer">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.8</a></li>
<li>: <strong>Protocols for Public Key Cryptosystems</strong> Ralph C. Merkle <em>1980 IEEE Symposium on Security and Privacy</em> (1980-04) <a href="https://doi.org/bmvbd6" target="_blank" rel="noopener noreferrer">https://doi.org/bmvbd6</a> DOI: <a href="https://doi.org/10.1109/sp.1980.10006" target="_blank" rel="noopener noreferrer">10.1109/sp.1980.10006</a></li>
<li>: <strong>An Introduction to Probability Theory and its Applications</strong> William Feller <em>John Wiley &amp; Sons</em> (1957) <a href="https://archive.org/details/AnIntroductionToProbabilityTheoryAndItsApplicationsVolume1" target="_blank" rel="noopener noreferrer">https://archive.org/details/AnIntroductionToProbabilityTheoryAndItsApplicationsVolume1</a></li>
</ol>
<hr>
]]></content:encoded>
    </item>
  </channel>
</rss>