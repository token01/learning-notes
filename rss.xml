<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://abelsun.tech/rss.xml" rel="self" type="application/rss+xml"/>
    <title>LearnNotes</title>
    <link>https://abelsun.tech/</link>
    <description>开源工具、编程知识、效率方法、有趣内容的自我提升笔记，记录并输出一切能让自己提升的知识。</description>
    <language>zh-CN</language>
    <pubDate>Sat, 19 Nov 2022 04:03:27 GMT</pubDate>
    <lastBuildDate>Sat, 19 Nov 2022 04:03:27 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>技术</category>
    <item>
      <title>[10 倍程序员] ⭐ 脚本的魅力，内含 js 写爬虫、python 骚操作等实用代码</title>
      <link>https://abelsun.tech/10x/script.html</link>
      <guid>https://abelsun.tech/10x/script.html</guid>
      <source url="https://abelsun.tech/rss.xml">[10 倍程序员] ⭐ 脚本的魅力，内含 js 写爬虫、python 骚操作等实用代码</source>
      <description>零、内容简介 将脚本用好能给工作带来事半功倍的效果，本文的内容主要涉及三个脚本工具：js、`awk、python， 主题如下： 使用 js 在浏览器控制台写爬虫。; 使用 shell 统计数据。; 使用 python 进行 redis、rabbitmq 运维。; 使用 python 生成 mysql 数据字典。; 话不多说，直接进入主题。 一、使用 j...</description>
      <category>技术</category>
      <pubDate>Mon, 06 Dec 2021 21:44:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_10-倍程序员-⭐脚本的魅力-内含-js-写爬虫、python-骚操作等实用代码" tabindex="-1"> [10 倍程序员] ⭐脚本的魅力，内含 js 写爬虫、python 骚操作等实用代码</h1>
<h2 id="零、内容简介" tabindex="-1"> 零、内容简介</h2>
<p>将脚本用好能给工作带来事半功倍的效果，本文的内容主要涉及三个脚本工具：<code>js</code>、<code>awk</code>、<code>python</code>， 主题如下：</p>
<ul>
<li>使用 <code>js</code> 在浏览器控制台写爬虫。</li>
<li>使用 <code>shell</code> 统计数据。</li>
<li>使用 <code>python</code> 进行 <code>redis</code>、<code>rabbitmq</code> 运维。</li>
<li>使用 <code>python</code> 生成 <code>mysql 数据字典</code>。</li>
</ul>
<p>话不多说，直接进入主题。</p>
<h2 id="一、使用-js-在浏览器控制台写爬虫" tabindex="-1"> 一、使用 js 在浏览器控制台写爬虫</h2>
<h3 id="_1-1-抓取数据" tabindex="-1"> 1.1 抓取数据</h3>
<p>使用 js 在浏览器控制台写爬虫的优势是不需要模拟浏览器请求、登录信息、基本不会被反爬虫技术禁止访问等，劣势是数据不易保存，如果爬虫是一次性的，且抓取的数据不多，使用 js 可以在几分钟就写好爬虫，至于获取的数据可以采取复制为 json 的方式导出，json 数据可以再进一步转换为易于阅读的 excel 等数据，读完这个章节你将掌握如何把复杂 json 转换为 excel 平面数据。</p>
<p>下面以获取某网站 gitlab 合并请求数据为例讲解整个数据抓取流程。</p>
<p>需求是获取所有 gitlab 项目的合并请求数据，项目 id 列表事先已经知道，代码如下：</p>
<div data-ext="js"><pre><code><span>var</span> ids <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span> <span>// 项目id</span>

<span>var</span> mrs <span>=</span> <span>[</span><span>]</span><span>;</span> <span>// 数据结果</span>

<span>function</span> <span>mr</span><span>(</span><span>idx</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>idx <span>&lt;</span> ids<span>.</span>length<span>)</span> <span>{</span>
    <span>fetch</span><span>(</span>
      <span>"https://xxx.com/gitlab/projects/"</span> <span>+</span>
        ids<span>[</span>idx<span>]</span> <span>+</span>
        <span>"/getMergeRequests?order_by=updated_at&amp;page=1&amp;per_page=100&amp;state=all"</span><span>,</span>
      <span>{</span> <span>credentials</span><span>:</span> <span>"same-origin"</span> <span>}</span>
    <span>)</span>
      <span>.</span><span>then</span><span>(</span><span>(</span><span>res</span><span>)</span> <span>=></span> res<span>.</span><span>json</span><span>(</span><span>)</span><span>)</span>
      <span>.</span><span>then</span><span>(</span><span>(</span><span>r</span><span>)</span> <span>=></span> <span>{</span>
        <span>if</span> <span>(</span>r<span>.</span>status <span>===</span> <span>"success"</span><span>)</span> <span>{</span>
          mrs<span>.</span><span>push</span><span>(</span><span>...</span>r<span>.</span>result<span>.</span>merge_requests<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
          console<span>.</span><span>log</span><span>(</span>ids<span>[</span>idx<span>]</span> <span>+</span> <span>" failed"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>mr</span><span>(</span>idx <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// 为了让请求串行执行，所以这里采用回调递归调用</span>
      <span>}</span><span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"done"</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>mr</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>// 开始抓取</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>短短几行代码就完成了数据的抓取，整个编码过程只需要 <code>5</code> 分钟左右。</p>
<p>抓取之后，数据都存储在 mrs 变量中，直接在控制台输入 <code>mrs</code> ，右键选择拷贝 json 数据，新建一个 <code>mrs.json</code> 文件将其保存起来即可。</p>
<h3 id="_1-2-转换数据" tabindex="-1"> 1.2 转换数据</h3>
<p>接下来将 json 数据转换为 excel。</p>
<p>方案 1，使用 <code>pandas</code>：</p>
<div data-ext="py"><pre><code><span>import</span> pandas
pandas<span>.</span>read_json<span>(</span><span>"mrs.json"</span><span>)</span><span>.</span>to_excel<span>(</span><span>"mrs.xlsx"</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>如果数据结构是下面这类简单 json 使用这两行脚本即可。</p>
<div data-ext="json"><pre><code><span>[</span>
  <span>{</span>
    <span>"title"</span><span>:</span> <span>"标题"</span><span>,</span>
    <span>"content"</span><span>:</span> <span>"内容"</span>
  <span>}</span>
<span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>若数据结构较复杂，列表对象中含有子对象，例如：</p>
<div data-ext="json"><pre><code><span>[</span>
  <span>{</span>
    <span>"title"</span><span>:</span> <span>"标题"</span><span>,</span>
    <span>"content"</span><span>:</span> <span>"内容"</span><span>,</span>
    <span>"detail"</span><span>:</span> <span>{</span>
      <span>"createBy"</span><span>:</span> <span>"张三"</span>
    <span>}</span>
  <span>}</span>
<span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>此时需要编码展开子对象，我们这里使用方案 2。</p>
<p>方案 2，使用 excel 导入 + <code>Power Query M 公式语言</code>转换数据。</p>
<ol>
<li>
<p>首先导入 JSON 数据。</p>
<p><img src="@source/10x/script/mrs_excel.png" alt="excel导入" loading="lazy"></p>
</li>
<li>
<p>在 Power Query 的高级编辑器中，修改 <code>Power Query M 公式语言</code> 脚本展开 json 数据。</p>
</li>
</ol>
<div data-ext="cs"><pre><code><span>let</span> responseJson <span>=</span> Json<span>.</span><span>Document</span><span>(</span>File<span>.</span><span>Contents</span><span>(</span><span>"D:\mrs.json"</span><span>)</span><span>)</span><span>,</span>
headers <span>=</span>
 <span>let</span>
 allHeaders <span>=</span> List<span>.</span><span>Combine</span><span>(</span>List<span>.</span><span>Transform</span><span>(</span>responseJson<span>,</span> Record<span>.</span>FieldNames<span>)</span><span>)</span><span>,</span>
 uniqueHeaders <span>=</span> List<span>.</span><span>Distinct</span><span>(</span>allHeaders<span>)</span>
 <span>in</span>
 uniqueHeaders<span>,</span>
 testTable <span>=</span> Table<span>.</span><span>FromRecords</span><span>(</span>responseJson<span>,</span> headers<span>,</span> MissingField<span>.</span>UseNull<span>)</span>
 <span>in</span>
 testTable
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这样就完成了数据的转换，后续再生成数据图表或导入数据库都非常方便。</p>
<p>这部分内容的重点在于要灵活使用各种工具以快速得到想要的结果。</p>
<h2 id="二、使用-shell-统计数据" tabindex="-1"> 二、使用 shell 统计数据</h2>
<p>需求：在上百个 Java 代码仓库中统计单元测试方法的数量。</p>
<p>我们以这个例子来看看 <code>awk</code> 的用法。</p>
<p>说明：这个统计方法只是简单查看单元测试方法数量，不涉及单元测试覆盖率等。</p>
<p>步骤如下：</p>
<ol>
<li>
<p>首先本地含有所有的代码仓库，cd 到代码仓库根目录。</p>
</li>
<li>
<p>使用以下命令统计每个仓库的单元测试方法数量。</p>
</li>
</ol>
<div data-ext="sh"><pre><code><span>find</span> <span>.</span> <span>-name</span> <span>'*Test.java'</span> <span>|</span> <span>xargs</span> <span>grep</span> <span>-i</span> <span>'@Test[^a-z]'</span> <span>|</span> <span>awk</span> <span>-F</span> / <span>'{count[$3]++;} END {for(i in count) {print i,count[i]}}'</span> <span>|</span> clip.exe
</code></pre><div aria-hidden="true"><div></div></div></div><p>注意：该命令运行在 <code>WSL</code>，所以可以在管道命令中包含 windows 命令。</p>
<p>命令说明：</p>
<div data-ext="sh"><pre><code><span>find</span> <span>.</span> <span>-name</span> <span>'*Test.java'</span> <span>|</span> <span>xargs</span> <span>grep</span> <span>-i</span> <span>'@Test[^a-z]'</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>找到所有 Test.java 结尾的文件，在文件中查找仅包含 @Test 的行，这一步的输出结果如下：</p>
<div data-ext="txt"><pre><code>./project/repository1/module/src/.../xxx.java: @Test
./project/repository2/module/src/.../xxx.java: @Test
./project/repository3/module/src/.../xxx.java: @Test
...
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>根据这个数据模式，再使用 awk 编写脚本进行数据分析。</p>
<div data-ext="sh"><pre><code><span>awk</span> <span>-F</span> / <span>'{count[$3]++;} END {for(i in count) {print i,count[i]}}'</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>awk 脚本中指定 / 为分隔符，第三位为仓库名称，使用仓库名称进行分组，最后输出仓库名称和分组数量。</p>
<p>输出结果：</p>
<div data-ext="txt"><pre><code>repository1 5
repository2 10
repository3 7
...
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>最后我们利用管道 <code>| clip.exe</code> 将其拷贝到剪切板，再导入 excel 即可。</p>
<h2 id="三、使用-python-进行-redis、rabbitmq-运维" tabindex="-1"> 三、使用 python 进行 redis、rabbitmq 运维</h2>
<h3 id="_3-1-扫描-redis" tabindex="-1"> 3.1 扫描 redis</h3>
<p>当 redis 内存过期速度赶不上内存增长，会导致 redis 内存占用越来越大，我们可以调整 redis 清理频率，也可以手动扫描 redis 来触发内存清理。</p>
<p>使用 python 执行以下代码即可，真是 <code>人生苦短，我用 python</code>。</p>
<div data-ext="py"><pre><code><span>import</span> redis
r <span>=</span> redis<span>.</span>Redis<span>(</span><span>)</span>
t <span>=</span> r<span>.</span>scan<span>(</span><span>)</span>
<span>while</span> t<span>[</span><span>0</span><span>]</span><span>:</span>
    t <span>=</span> r<span>.</span>scan<span>(</span>t<span>[</span><span>0</span><span>]</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_3-2-rabbitmq-消息队列转发" tabindex="-1"> 3.2 rabbitmq 消息队列转发</h3>
<p>rabbitmq 上有消息队列转发的插件，但如果是云服务，通常无法使用该插件，此时用 python 写点转发脚本也是易事。</p>
<div data-ext="py"><pre><code><span>import</span> pika

connection <span>=</span> pika<span>.</span>BlockingConnection<span>(</span>pika<span>.</span>ConnectionParameters<span>(</span>host<span>=</span><span>'ip'</span><span>,</span> port<span>=</span><span>5672</span><span>,</span> virtual_host<span>=</span><span>'/'</span><span>,</span> credentials<span>=</span>pika<span>.</span>PlainCredentials<span>(</span><span>'account'</span><span>,</span><span>'password'</span><span>)</span><span>)</span><span>)</span>

channel <span>=</span> connection<span>.</span>channel<span>(</span><span>)</span>

<span>def</span> <span>backcall</span><span>(</span>ch<span>,</span> method<span>,</span> properties<span>,</span> body<span>)</span><span>:</span>
    <span># 转发</span>
    channel<span>.</span>basic_publish<span>(</span>exchange<span>=</span><span>'exchange'</span><span>,</span> routing_key<span>=</span><span>'routing_key'</span><span>,</span> body<span>=</span>body<span>)</span>

channel<span>.</span>basic_consume<span>(</span><span>'原队列'</span><span>,</span>backcall<span>,</span> <span>True</span><span>)</span>

channel<span>.</span>start_consuming<span>(</span><span>)</span>
connection<span>.</span>close<span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="四、使用-python-生成-mysql-数据字典" tabindex="-1"> 四、使用 python 生成 mysql 数据字典</h2>
<p>生成数据字典的工具有很多，但往往生成的数据字典不易修改，试试用 python 生成 markdown 格式的数据字典如何？</p>
<div data-ext="py"><pre><code><span>import</span> mysql<span>.</span>connector
<span>import</span> importlib
<span>import</span> sys


<span>def</span> <span>generate</span><span>(</span>database_name<span>)</span><span>:</span>
    <span>"""
    生成数据库字典表
    """</span>
    importlib<span>.</span><span>reload</span><span>(</span>sys<span>)</span>

    <span># 使用前修改配置</span>
    conn <span>=</span> mysql<span>.</span>connector<span>.</span>connect<span>(</span>
        host<span>=</span><span>'localhost'</span><span>,</span>
        port<span>=</span><span>'3306'</span><span>,</span>
        user<span>=</span><span>''</span><span>,</span>
        password<span>=</span><span>''</span><span>,</span>
        use_pure<span>=</span><span>True</span>
    <span>)</span>

    cursor <span>=</span> conn<span>.</span>cursor<span>(</span><span>)</span>

    cursor<span>.</span>execute<span>(</span>
        <span>"SELECT TABLE_NAME, TABLE_COMMENT FROM information_schema.TABLES WHERE table_type='BASE TABLE' AND TABLE_SCHEMA='%s'"</span> <span>%</span> database_name
    <span>)</span>

    tables <span>=</span> cursor<span>.</span>fetchall<span>(</span><span>)</span>

    markdown_table_header <span>=</span> <span>"""\n\n\n### %s (%s) \n| 序号 | 字段名称 | 数据类型 | 是否为空 | 字段说明 |\n| :--: |----| ---- | ---- | ---- |\n"""</span>
    markdown_table_row <span>=</span> <span>"""| %s | %s | %s | %s | %s |"""</span>

    f <span>=</span> <span>open</span><span>(</span><span>'dict/'</span><span>+</span>database_name <span>+</span> <span>'.md'</span><span>,</span> <span>'w'</span><span>,</span> encoding<span>=</span><span>"utf-8"</span><span>)</span>

    <span>for</span> table <span>in</span> tables<span>:</span>

        cursor<span>.</span>execute<span>(</span>
            <span>"SELECT ORDINAL_POSITION, COLUMN_NAME, COLUMN_TYPE, IS_NULLABLE, COLUMN_COMMENT "</span>
            <span>"FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='%s' AND TABLE_NAME='%s'"</span> <span>%</span> <span>(</span>
                database_name<span>,</span> table<span>[</span><span>0</span><span>]</span>
            <span>)</span>
        <span>)</span>

        tmp_table <span>=</span> cursor<span>.</span>fetchall<span>(</span><span>)</span>
        p <span>=</span> markdown_table_header <span>%</span> <span>(</span>table<span>[</span><span>0</span><span>]</span><span>,</span> remove_newline<span>(</span>table<span>[</span><span>1</span><span>]</span><span>)</span><span>)</span>
        <span>for</span> col <span>in</span> tmp_table<span>:</span>
            colf <span>=</span> <span>list</span><span>(</span>col<span>)</span>
            colf<span>[</span><span>2</span><span>]</span><span>=</span>col<span>[</span><span>2</span><span>]</span><span>.</span>decode<span>(</span><span>)</span> <span># mysql 高级版本需要解码，代码有点丑，临时性的，能用就行</span>
            colf<span>[</span><span>4</span><span>]</span><span>=</span>col<span>[</span><span>4</span><span>]</span><span>.</span>decode<span>(</span><span>)</span>
            p <span>+=</span> <span>(</span>remove_newline<span>(</span>markdown_table_row <span>%</span> <span>tuple</span><span>(</span>colf<span>)</span><span>)</span> <span>+</span> <span>"\n"</span><span>)</span>
        <span>print</span><span>(</span>p<span>)</span>
        f<span>.</span>writelines<span>(</span>p<span>)</span>

    f<span>.</span>close<span>(</span><span>)</span>
    cursor<span>.</span>close<span>(</span><span>)</span>
    conn<span>.</span>close<span>(</span><span>)</span>


<span>def</span> <span>remove_newline</span><span>(</span>text<span>)</span><span>:</span>
    <span>"""
    去除文本中的换行符号
    """</span>
    <span>return</span> text<span>.</span>replace<span>(</span><span>"\r"</span><span>,</span> <span>""</span><span>)</span><span>.</span>replace<span>(</span><span>"\n"</span><span>,</span> <span>""</span><span>)</span>


<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>
    conn <span>=</span> mysql<span>.</span>connector<span>.</span>connect<span>(</span>
        host<span>=</span><span>'localhost'</span><span>,</span>
        port<span>=</span><span>'3306'</span><span>,</span>
        user<span>=</span><span>''</span><span>,</span>
        password<span>=</span><span>''</span><span>,</span>
        use_pure<span>=</span><span>True</span>
    <span>)</span>

    cursor <span>=</span> conn<span>.</span>cursor<span>(</span><span>)</span>

    cursor<span>.</span>execute<span>(</span><span>"SHOW DATABASES"</span><span>)</span><span>;</span>

    dbs <span>=</span> cursor<span>.</span>fetchall<span>(</span><span>)</span>

    <span>for</span> db <span>in</span> dbs<span>:</span>
        generate<span>(</span>db<span>[</span><span>0</span><span>]</span><span>)</span>

    cursor<span>.</span>close<span>(</span><span>)</span>
    conn<span>.</span>close<span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="五、后记" tabindex="-1"> 五、后记</h2>
<p>本篇文章内容比较杂，这些脚本不能说非常优美，但写起来确实是非常的高效，能够快速地完成需求，当我们把这些工具掌握的同时，偶尔发挥下想象力，必然能够体会到编程的乐趣和代码的魅力。</p>
]]></content:encoded>
    </item>
    <item>
      <title>[10 倍程序员] ⭐ 51W+ 的终端命令行工具助你成为 10 倍程序员</title>
      <link>https://abelsun.tech/10x/terminal.html</link>
      <guid>https://abelsun.tech/10x/terminal.html</guid>
      <source url="https://abelsun.tech/rss.xml">[10 倍程序员] ⭐ 51W+ 的终端命令行工具助你成为 10 倍程序员</source>
      <description>终端是程序员的必备工具之一，10 倍程序员的终端跟普通程序员有何不同？本文将介绍许多牛逼且实用的开源工具，用上这些工具后你不一定会变成 10 倍程序员，但绝对能够让你感觉自己像个 10 倍程序员。 本文仅对工具做基本介绍，不提供安装方法，因为这些工具的安装方法在项目的 github 首页上基本都会提供，在掘金上也能找到许多具体的使用教程。 在终端准备部...</description>
      <category>技术</category>
      <pubDate>Tue, 25 May 2021 21:44:08 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_10-倍程序员-⭐51w-的终端命令行工具助你成为-10-倍程序员" tabindex="-1"> [10 倍程序员] ⭐51W+ 的终端命令行工具助你成为 10 倍程序员</h1>
<p>终端是程序员的必备工具之一，10 倍程序员的终端跟普通程序员有何不同？本文将介绍许多牛逼且实用的开源工具，用上这些工具后你不一定会变成 10 倍程序员，但绝对能够让你感觉自己像个 10 倍程序员。</p>
<p>本文仅对工具做基本介绍，不提供安装方法，因为这些工具的安装方法在项目的 github 首页上基本都会提供，在掘金上也能找到许多具体的使用教程。</p>
<p>在终端准备部分介绍的工具是跟操作系统相关的，终端内的命令行工具则基本上是 <code>跨平台</code> 的，可以在 mac、linux、windows 上使用。</p>
<p>本文介绍的工具在下表中可以查阅，数据按照发文时的 star 数量倒序排列，方便读者朋友挑选。</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>地址</th>
<th>stars</th>
</tr>
</thead>
<tbody>
<tr>
<td>oh my zsh</td>
<td><a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener noreferrer">https://github.com/ohmyzsh/ohmyzsh</a></td>
<td><img src="https://img.shields.io/github/stars/ohmyzsh/ohmyzsh" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>terminal</td>
<td><a href="https://github.com/microsoft/terminal" target="_blank" rel="noopener noreferrer">https://github.com/microsoft/terminal</a></td>
<td><img src="https://img.shields.io/github/stars/microsoft/terminal" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>the fuck</td>
<td><a href="https://github.com/nvbn/thefuck" target="_blank" rel="noopener noreferrer">https://github.com/nvbn/thefuck</a></td>
<td><img src="https://img.shields.io/github/stars/nvbn/thefuck" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>fzf</td>
<td><a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener noreferrer">https://github.com/junegunn/fzf</a></td>
<td><img src="https://img.shields.io/github/stars/junegunn/fzf" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>tldr</td>
<td><a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener noreferrer">https://github.com/tldr-pages/tldr</a></td>
<td><img src="https://img.shields.io/github/stars/tldr-pages/tldr" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>bat</td>
<td><a href="https://github.com/sharkdp/bat" target="_blank" rel="noopener noreferrer">https://github.com/sharkdp/bat</a></td>
<td><img src="https://img.shields.io/github/stars/sharkdp/bat" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>vimrc</td>
<td><a href="https://github.com/amix/vimrc" target="_blank" rel="noopener noreferrer">https://github.com/amix/vimrc</a></td>
<td><img src="https://img.shields.io/github/stars/amix/vimrc" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>vim</td>
<td><a href="https://github.com/vim/vim" target="_blank" rel="noopener noreferrer">https://github.com/vim/vim</a></td>
<td><img src="https://img.shields.io/github/stars/vim/vim" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>fd</td>
<td><a href="https://github.com/sharkdp/fd" target="_blank" rel="noopener noreferrer">https://github.com/sharkdp/fd</a></td>
<td><img src="https://img.shields.io/github/stars/sharkdp/fd" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>exa</td>
<td><a href="https://github.com/ogham/exa" target="_blank" rel="noopener noreferrer">https://github.com/ogham/exa</a></td>
<td><img src="https://img.shields.io/github/stars/ogham/exa" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>z</td>
<td><a href="https://github.com/rupa/z" target="_blank" rel="noopener noreferrer">https://github.com/rupa/z</a></td>
<td><img src="https://img.shields.io/github/stars/rupa/z" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>powerline</td>
<td><a href="https://github.com/powerline/powerline" target="_blank" rel="noopener noreferrer">https://github.com/powerline/powerline</a></td>
<td><img src="https://img.shields.io/github/stars/powerline/powerline" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>zsh-syntax-highlighting</td>
<td><a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener noreferrer">https://github.com/zsh-users/zsh-syntax-highlighting</a></td>
<td><img src="https://img.shields.io/github/stars/zsh-users/zsh-syntax-highlighting" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>nnn</td>
<td><a href="https://github.com/jarun/nnn" target="_blank" rel="noopener noreferrer">https://github.com/jarun/nnn</a></td>
<td><img src="https://img.shields.io/github/stars/jarun/nnn" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>iTerm2</td>
<td><a href="https://github.com/gnachman/iTerm2" target="_blank" rel="noopener noreferrer">https://github.com/gnachman/iTerm2</a></td>
<td><img src="https://img.shields.io/github/stars/gnachman/iTerm2" alt="stars" loading="lazy"></td>
</tr>
<tr>
<td>ranger</td>
<td><a href="https://github.com/ranger/ranger" target="_blank" rel="noopener noreferrer">https://github.com/ranger/ranger</a></td>
<td><img src="https://img.shields.io/github/stars/ranger/ranger" alt="stars" loading="lazy"></td>
</tr>
</tbody>
</table>
<h2 id="终端准备" tabindex="-1"> 终端准备</h2>
<h3 id="windows-terminal" tabindex="-1"> Windows Terminal</h3>
<p><img src="https://img.shields.io/github/stars/microsoft/terminal" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/microsoft/terminal" target="_blank" rel="noopener noreferrer">https://github.com/microsoft/terminal</a></p>
<p>看这 star 数量，便知无需过多介绍，微软多年后终于意识到自家的终端实在是太简陋了，用上 Windows Terminal 后可以抛弃掉 cmder、cygwin 了。</p>
<p>要让其发挥终端的强大威力，还需要安装 <code>WSL2</code>，推荐安装 ubuntu。</p>
<p>可以为不同的 shell 环境设置不同的背景、主题，其还支持与 VS Code 一样的 <code>CTRL+SHIFT+P</code> 快捷键打开快速命令窗口，方便操作。</p>
<p><img src="@source/10x/terminal/terminal.gif" alt="Windows Terminal" loading="lazy"></p>
<h3 id="iterm2" tabindex="-1"> iTerm2</h3>
<p><img src="https://img.shields.io/github/stars/gnachman/iTerm2" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/gnachman/iTerm2" target="_blank" rel="noopener noreferrer">https://github.com/gnachman/iTerm2</a></p>
<p>作为 mac 上首选用来替换默认终端的 iTerm2 自然也无需过多介绍，它拥有超多的特性，比如：分割面板、快捷键增强、优化的搜索、自动完成、粘贴历史、高度可配置等等，它拥有超多的主题，主题的 star 数量甚至超过本体的 star 数量。</p>
<p>功能介绍：<a href="https://iterm2.com/features.html" target="_blank" rel="noopener noreferrer">https://iterm2.com/features.html</a> 。</p>
<p>丰富主题：<a href="https://github.com/mbadolato/iTerm2-Color-Schemes" target="_blank" rel="noopener noreferrer">https://github.com/mbadolato/iTerm2-Color-Schemes</a> 。</p>
<h2 id="shell-环境" tabindex="-1"> shell 环境</h2>
<h3 id="oh-my-zsh" tabindex="-1"> oh my zsh</h3>
<p><img src="https://img.shields.io/github/stars/ohmyzsh/ohmyzsh" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener noreferrer">https://github.com/ohmyzsh/ohmyzsh</a></p>
<p>超过 12 万的 star 数，可见 oh my zsh 多么受欢迎，该项目主要用于简化 zsh 的配置，自带并支持超多有用的插件。</p>
<blockquote>
<p>Oh My Zsh will not make you a 10x developer...but you may feel like one!</p>
</blockquote>
<p>本文的标题实际上借鉴了 oh my zsh 官网的这段话，用上它后你的 shell 环境将焕然一新，还有以下的插件是你务必要装上试一试的。</p>
<ol>
<li>
<p>zsh-syntax-highlighting</p>
<p><img src="https://img.shields.io/github/stars/zsh-users/zsh-syntax-highlighting" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener noreferrer">https://github.com/zsh-users/zsh-syntax-highlighting</a></p>
<p>一句话点评：语法高亮为终端增添色彩。</p>
</li>
<li>
<p>zsh-autosuggestions</p>
<p><img src="https://img.shields.io/github/stars/zsh-users/zsh-autosuggestions" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener noreferrer">https://github.com/zsh-users/zsh-autosuggestions</a></p>
<p>一句话点评：程序员怎能离开智能提示？</p>
</li>
<li>
<p>z</p>
<p><img src="https://img.shields.io/github/stars/rupa/z" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/rupa/z" target="_blank" rel="noopener noreferrer">https://github.com/rupa/z</a></p>
<p>一句话点评：切换目录比资源管理器用起来还方便。</p>
</li>
</ol>
<h3 id="powerline" tabindex="-1"> powerline</h3>
<p><img src="https://img.shields.io/github/stars/powerline/powerline" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/powerline/powerline" target="_blank" rel="noopener noreferrer">https://github.com/powerline/powerline</a></p>
<p>终端本身是高效的，但有时也略显乏味，使用 powerline 可以为终端加上强大的 <code>状态栏</code>，比如在 vim 中显示当前状态，在打开 git 目录时显示当前分支等等。</p>
<p><img src="@source/10x/terminal/powerline.png" alt="powerline" loading="lazy"></p>
<h2 id="系统工具" tabindex="-1"> 系统工具</h2>
<h3 id="文件管理器" tabindex="-1"> 文件管理器</h3>
<p>很多人用不惯终端的一个原因就是在上面无法像 windows资源管理器或 finder 一样操作文件，实际上有许多开源的命令行文件管理器，下面介绍两个热门的，大家按需选用。</p>
<ol>
<li>
<p>ranger</p>
<p><img src="https://img.shields.io/github/stars/ranger/ranger" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/ranger/ranger" target="_blank" rel="noopener noreferrer">https://github.com/ranger/ranger</a></p>
<p>Ranger 使用 Python 编写，默认为使用 <code>vim</code> 风格的按键绑定，对于使用 vim 的用户来说几乎没有学习成本，能够快速上手使用。</p>
<p><img src="@source/10x/terminal/ranger.png" alt="ranger" loading="lazy"></p>
</li>
<li>
<p>nnn</p>
<p><img src="https://img.shields.io/github/stars/jarun/nnn" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/jarun/nnn" target="_blank" rel="noopener noreferrer">https://github.com/jarun/nnn</a></p>
<p>nnn (n³) 是一个功能齐全的终端文件管理器，速度非常快且几乎 0 配置，也是一个非常不错的选择。</p>
</li>
</ol>
<h3 id="vim" tabindex="-1"> vim</h3>
<p><img src="https://img.shields.io/github/stars/vim/vim" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/vim/vim" target="_blank" rel="noopener noreferrer">https://github.com/vim/vim</a></p>
<p>终端下还有比 vim 更好用的文本编辑器吗？ vi 不仅仅是一个文本编辑器，它无处不在，如果说 10 倍程序员有什么标配，那 vim 大概率会是其中之一。</p>
<p>要调教好 vim 也需要一番配置，有不少人在 Github 上分享自己的配置文件，但要说最好用且适合大多数人的还是下面这个项目。</p>
<ul>
<li>
<p>vimrc</p>
<p><img src="https://img.shields.io/github/stars/amix/vimrc" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/amix/vimrc" target="_blank" rel="noopener noreferrer">https://github.com/amix/vimrc</a></p>
</li>
</ul>
<h2 id="命令增强" tabindex="-1"> 命令增强</h2>
<p>终端下有许多原生的命令可以满足基本使用，但有些命令并不足够好用，下面介绍几个替代工具。</p>
<ol>
<li>
<p>exa</p>
<p><img src="https://img.shields.io/github/stars/ogham/exa" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/ogham/exa" target="_blank" rel="noopener noreferrer">https://github.com/ogham/exa</a></p>
<p>一句话点评：用来替换 <code>ls</code> 命令的现代化工具。</p>
</li>
<li>
<p>fd</p>
<p><img src="https://img.shields.io/github/stars/sharkdp/fd" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/sharkdp/fd" target="_blank" rel="noopener noreferrer">https://github.com/sharkdp/fd</a></p>
<p>一句话点评：简单、快速、好用，用于替换 <code>find</code> 的搜索工具。</p>
</li>
<li>
<p>bat</p>
<p><img src="https://img.shields.io/github/stars/sharkdp/bat" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/sharkdp/bat" target="_blank" rel="noopener noreferrer">https://github.com/sharkdp/bat</a></p>
<p>一句话点评：<code>cat</code> 的替代品，是猛男就用 bat。</p>
</li>
</ol>
<h2 id="其他让人赞叹的工具" tabindex="-1"> 其他让人赞叹的工具</h2>
<h3 id="fzf" tabindex="-1"> fzf</h3>
<p><img src="https://img.shields.io/github/stars/junegunn/fzf" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener noreferrer">https://github.com/junegunn/fzf</a></p>
<p>fzf 是一款支持模糊搜索的交互式工具，可以用来查找任何列表内容，包括文件、Git 分支、进程等。</p>
<p><img src="@source/10x/terminal/fzf.png" alt="fzf" loading="lazy"></p>
<h3 id="tldr" tabindex="-1"> tldr</h3>
<p><img src="https://img.shields.io/github/stars/tldr-pages/tldr" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener noreferrer">https://github.com/tldr-pages/tldr</a></p>
<p>tdlr 是 <code>Too long, Don't read</code> 的缩写，可以帮助你快速查看常用命令的使用实例，比如 tar 命令，那后面一长串参数谁记得清呢？当然，linux 大佬除外。</p>
<p><img src="@source/10x/terminal/tldr.png" alt="tldr" loading="lazy"></p>
<h3 id="the-fuck" tabindex="-1"> The Fuck</h3>
<p><img src="https://img.shields.io/github/stars/nvbn/thefuck" alt="stars" loading="lazy"></p>
<p>地址：<a href="https://github.com/nvbn/thefuck" target="_blank" rel="noopener noreferrer">https://github.com/nvbn/thefuck</a></p>
<p>在终端下是不是经常输错命令，搞得自己心烦意乱，<code>The Fuck</code> 是一款了不起的工具，帮你彻底解决这个问题，当你输错命令后，只要输入 <code>fuck</code> 命令，它会帮你自动纠正错误，精彩之极！</p>
<p><img src="@source/10x/terminal/thefxxk.gif" alt="thefxxk" loading="lazy"></p>
<h3 id="w3m" tabindex="-1"> w3m</h3>
<p>地址：<a href="https://github.com/tats/w3m" target="_blank" rel="noopener noreferrer">https://github.com/tats/w3m</a></p>
<p>真正的程序员就该使用命令行来浏览网页。</p>
<p><img src="@source/10x/terminal/w3m.png" alt="w3m" loading="lazy"></p>
<h2 id="_10-倍程序员之路" tabindex="-1"> 10 倍程序员之路</h2>
<p>w3m 这个项目已经基本不维护了，我以这个命令来结束本篇文章，因为还有许多像这样优秀好玩的工具等待我们去发现、去创造。</p>
<p>程序员的双手是魔术师的双手，他们将代码转变成丰富多彩的软件，即使是平平无奇的终端竟然也能玩出许多花样。</p>
<p>普通程序员使用工具，10 倍程序员使用优秀的工具再造工具，10 倍程序员不是概念，而是真实存在的，今天的我看上去像，明天的我真的可以做到，加油吧，程序员们。</p>
]]></content:encoded>
      <enclosure url="https://img.shields.io/github/stars/ohmyzsh/ohmyzsh" type="image/"/>
    </item>
    <item>
      <title></title>
      <link>https://abelsun.tech/Artificial-Intelligence/AI.html</link>
      <guid>https://abelsun.tech/Artificial-Intelligence/AI.html</guid>
      <source url="https://abelsun.tech/rss.xml"></source>
      <description>TensorFlow; kubeflow (https://github.com/kubeflow/kubeflow); arena (https://github.com/kubeflow/arena); Pytorch; Caffe2;</description>
      <pubDate>Sat, 19 Nov 2022 02:42:33 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>TensorFlow
<ul>
<li><a href="https://github.com/kubeflow/kubeflow" target="_blank" rel="noopener noreferrer">kubeflow</a>
<ul>
<li><a href="https://github.com/kubeflow/arena" target="_blank" rel="noopener noreferrer">arena</a></li>
</ul>
</li>
</ul>
</li>
<li>Pytorch</li>
<li>Caffe2</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title></title>
      <link>https://abelsun.tech/Artificial-Intelligence/RoadMap.html</link>
      <guid>https://abelsun.tech/Artificial-Intelligence/RoadMap.html</guid>
      <source url="https://abelsun.tech/rss.xml"></source>
      <description>AI工程师成长 编程语言 Python 数据分析：pandas (https://github.com/pandas-dev/pandas), sklearn (https://github.com/automl/auto-sklearn); 《Effective Python》 Scala/Java 大数据领域：Hadoop,Spark,Flink;...</description>
      <pubDate>Sat, 19 Nov 2022 02:42:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="ai工程师成长" tabindex="-1"> AI工程师成长</h2>
<h2 id="编程语言" tabindex="-1"> 编程语言</h2>
<h3 id="python" tabindex="-1"> Python</h3>
<ul>
<li>数据分析：<a href="https://github.com/pandas-dev/pandas" target="_blank" rel="noopener noreferrer">pandas</a>, <a href="https://github.com/automl/auto-sklearn" target="_blank" rel="noopener noreferrer">sklearn</a></li>
</ul>
<blockquote>
<p>《Effective Python》</p>
</blockquote>
<h3 id="scala-java" tabindex="-1"> Scala/Java</h3>
<ul>
<li>大数据领域：Hadoop,Spark,Flink</li>
</ul>
<blockquote>
<p>《深入理解Java虚拟机》、《Spark快速大数据分析》、《Programming in Scala》</p>
</blockquote>
<blockquote>
<p>使用Spark的Scala API来进行大规模的数据分析及处理，完成lag feature之类的特征工程处理</p>
</blockquote>
<h3 id="c-c-rust" tabindex="-1"> C/C++/Rust</h3>
<blockquote>
<p>当前流行的算法框架，例如TensorFlow, PyTorch, LightGBM等，底层都是基于C++为主要语言进行实现的</p>
</blockquote>
<h2 id="操作系统" tabindex="-1"> 操作系统</h2>
<blockquote>
<p>硬件结构，CPU调度，进程，线程，内存管理，文件系统，IO，网络等</p>
</blockquote>
<h3 id="linux" tabindex="-1"> Linux</h3>
<ul>
<li>CentOS</li>
<li>MacOS</li>
<li>Ubuntu</li>
</ul>
<h2 id="算法与数据结构" tabindex="-1"> 算法与数据结构</h2>
<blockquote>
<p>《统计思维》，《贝叶斯方法》，《程序员的数学2》</p>
</blockquote>
<blockquote>
<p>机器学习：周志华《机器学习》、《PRML》，《ESL》、《统计学习方法》<br>
深度学习</p>
</blockquote>
<ul>
<li>通用机器学习：scikit-learn，Spark ML，LightGBM, XGBoost</li>
<li>通用深度学习：Keras/TensorFlow，PyTorch</li>
<li>特征工程：tsfresh, Featuretools，Feast</li>
<li>AutoML：hyperopt，SMAC3，nni，autogluon</li>
<li>可解释机器学习：shap，aix360，eli5，interpret</li>
<li>异常检测：pyod，egads</li>
<li>可视化：pyecharts，seaborn</li>
<li>数据质量：cerberus，pandas_profiling，Deequ</li>
<li>时间序列：fbprophet，sktime，pyts</li>
<li>大规模机器学习：Horovod，BigDL，mmlspark</li>
<li>Pipeline：MLflow, metaflow，KubeFlow，Hopsworks</li>
<li>爬虫：scrapy</li>
</ul>
<h3 id="大规模算法运行" tabindex="-1"> 大规模算法运行</h3>
<blockquote>
<p>分布式训练</p>
</blockquote>
<blockquote>
<p>高性能计算
硬件：超线程技术,向量化指令集，GPGPU，TPU<br>
软件：OpenBLAS，OpenMP，JIT<br>
Nvidia-cuDNN， LightGBM<br>
模型加速：MobileNet，TensorRT，二值网络</p>
</blockquote>
<h2 id="可视化" tabindex="-1"> 可视化</h2>
<h2 id="软件工程" tabindex="-1"> 软件工程</h2>
<ul>
<li>
<p>代码规范</p>
</li>
<li>
<p>设计模式</p>
</li>
<li>
<p>质量保障,自动化测试</p>
<blockquote>
<p>sklearn，LightGBM</p>
</blockquote>
</li>
<li>
<p>项目管理</p>
<blockquote>
<p>敏捷开发，设计评审，代码评审，版本管控，任务看板管理</p>
</blockquote>
</li>
<li>
<p>软件架构师</p>
<blockquote>
<p>技术选型与系统架构设计，架构设计原则与模式，宽广的研发知识视野，高性能，高可用，可扩展性，安全性, 微服务</p>
</blockquote>
</li>
</ul>
<h2 id="mlops" tabindex="-1"> MLOps</h2>
<blockquote>
<p>框架工具：Airflow，DolphinScheduler，Cadence<br>
开源系统：MLflow，Kubeflow，Metaflow，TFX
数据质量：TFX Data Validation，Cerberus，Deequ<br>
实验管理：MLflow，fitlog，wandb<br>
Serving：mmlspark，TF Serving，MLeap，H2O，PredictionIO，PMML/PFA/ONNX<br>
CI/CD：Jenkins，CircleCI，GoCD，VerCD
系统监控：elasicsearch + kibana</p>
</blockquote>
<h2 id="数据库" tabindex="-1"> 数据库</h2>
<p>Delta Lake<br>
<a href="https://www.hopsworks.ai/" target="_blank" rel="noopener noreferrer">Feature Store</a></p>
<h2 id="云计算" tabindex="-1"> 云计算</h2>
<p>Docker、k8s</p>
<hr>
<p><a href="https://zhuanlan.zhihu.com/p/192633890" target="_blank" rel="noopener noreferrer">参考</a></p>
<h2 id="文献" tabindex="-1"> 文献</h2>
<ul>
<li>NLP TF-IDF(Term Frequency - Inverse Document Frequency) <a href="https://www.ruanyifeng.com/blog/2013/03/tf-idf.html" target="_blank" rel="noopener noreferrer">TF-IDF与余弦相似性的应用（一）：自动提取关键词</a></li>
<li>LDA <a href="https://nbviewer.jupyter.org/github/bmabey/pyLDAvis/blob/master/notebooks/sklearn.ipynb" target="_blank" rel="noopener noreferrer">pyLDAvis</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Math</title>
      <link>https://abelsun.tech/Artificial-Intelligence/math.html</link>
      <guid>https://abelsun.tech/Artificial-Intelligence/math.html</guid>
      <source url="https://abelsun.tech/rss.xml">Math</source>
      <description>希腊字母 大写 小写 英文注音 国际音标注音 中文注音 :--- :--- :------- :----------- :------- Α α alpha alfa 阿耳法 Β β beta beta 贝塔 Γ γ gamma gamma 伽马 Δ δ deta delta 德耳塔 Ε ε epsilon epsilon 艾普西隆 Ζ ζ zeta ...</description>
      <pubDate>Sat, 19 Nov 2022 02:42:33 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="math" tabindex="-1"> Math</h1>
<h2 id="希腊字母" tabindex="-1"> 希腊字母</h2>
<table>
<thead>
<tr>
<th style="text-align:left">大写</th>
<th style="text-align:left">小写</th>
<th style="text-align:left">英文注音</th>
<th style="text-align:left">国际音标注音</th>
<th style="text-align:left">中文注音</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Α</td>
<td style="text-align:left">α</td>
<td style="text-align:left">alpha</td>
<td style="text-align:left">alfa</td>
<td style="text-align:left">阿耳法</td>
</tr>
<tr>
<td style="text-align:left">Β</td>
<td style="text-align:left">β</td>
<td style="text-align:left">beta</td>
<td style="text-align:left">beta</td>
<td style="text-align:left">贝塔</td>
</tr>
<tr>
<td style="text-align:left">Γ</td>
<td style="text-align:left">γ</td>
<td style="text-align:left">gamma</td>
<td style="text-align:left">gamma</td>
<td style="text-align:left">伽马</td>
</tr>
<tr>
<td style="text-align:left">Δ</td>
<td style="text-align:left">δ</td>
<td style="text-align:left">deta</td>
<td style="text-align:left">delta</td>
<td style="text-align:left">德耳塔</td>
</tr>
<tr>
<td style="text-align:left">Ε</td>
<td style="text-align:left">ε</td>
<td style="text-align:left">epsilon</td>
<td style="text-align:left">epsilon</td>
<td style="text-align:left">艾普西隆</td>
</tr>
<tr>
<td style="text-align:left">Ζ</td>
<td style="text-align:left">ζ</td>
<td style="text-align:left">zeta</td>
<td style="text-align:left">zeta</td>
<td style="text-align:left">截塔</td>
</tr>
<tr>
<td style="text-align:left">Η</td>
<td style="text-align:left">η</td>
<td style="text-align:left">eta</td>
<td style="text-align:left">eta</td>
<td style="text-align:left">艾塔</td>
</tr>
<tr>
<td style="text-align:left">Θ</td>
<td style="text-align:left">θ</td>
<td style="text-align:left">theta</td>
<td style="text-align:left">θita</td>
<td style="text-align:left">西塔</td>
</tr>
<tr>
<td style="text-align:left">Ι</td>
<td style="text-align:left">ι</td>
<td style="text-align:left">iota</td>
<td style="text-align:left">iota</td>
<td style="text-align:left">约塔</td>
</tr>
<tr>
<td style="text-align:left">Κ</td>
<td style="text-align:left">κ</td>
<td style="text-align:left">kappa</td>
<td style="text-align:left">kappa</td>
<td style="text-align:left">卡帕</td>
</tr>
<tr>
<td style="text-align:left">∧</td>
<td style="text-align:left">λ</td>
<td style="text-align:left">lambda</td>
<td style="text-align:left">lambda</td>
<td style="text-align:left">兰姆达</td>
</tr>
<tr>
<td style="text-align:left">Μ</td>
<td style="text-align:left">μ</td>
<td style="text-align:left">mu</td>
<td style="text-align:left">miu</td>
<td style="text-align:left">缪</td>
</tr>
<tr>
<td style="text-align:left">Ν</td>
<td style="text-align:left">ν</td>
<td style="text-align:left">nu</td>
<td style="text-align:left">niu</td>
<td style="text-align:left">纽</td>
</tr>
<tr>
<td style="text-align:left">Ξ</td>
<td style="text-align:left">ξ</td>
<td style="text-align:left">xi</td>
<td style="text-align:left">ksi</td>
<td style="text-align:left">可塞</td>
</tr>
<tr>
<td style="text-align:left">Ο</td>
<td style="text-align:left">ο</td>
<td style="text-align:left">omicron</td>
<td style="text-align:left">omikron</td>
<td style="text-align:left">奥密可戎</td>
</tr>
<tr>
<td style="text-align:left">∏</td>
<td style="text-align:left">π</td>
<td style="text-align:left">pi</td>
<td style="text-align:left">pai</td>
<td style="text-align:left">派</td>
</tr>
<tr>
<td style="text-align:left">Ρ</td>
<td style="text-align:left">ρ</td>
<td style="text-align:left">rho</td>
<td style="text-align:left">rou</td>
<td style="text-align:left">柔</td>
</tr>
<tr>
<td style="text-align:left">∑</td>
<td style="text-align:left">σ</td>
<td style="text-align:left">sigma</td>
<td style="text-align:left">sigma</td>
<td style="text-align:left">西格马</td>
</tr>
<tr>
<td style="text-align:left">Τ</td>
<td style="text-align:left">τ</td>
<td style="text-align:left">tau</td>
<td style="text-align:left">tau</td>
<td style="text-align:left">套</td>
</tr>
<tr>
<td style="text-align:left">Υ</td>
<td style="text-align:left">υ</td>
<td style="text-align:left">upsilon</td>
<td style="text-align:left">jupsilon</td>
<td style="text-align:left">衣普西隆</td>
</tr>
<tr>
<td style="text-align:left">Φ</td>
<td style="text-align:left">φ</td>
<td style="text-align:left">phi</td>
<td style="text-align:left">fai</td>
<td style="text-align:left">斐</td>
</tr>
<tr>
<td style="text-align:left">Χ</td>
<td style="text-align:left">χ</td>
<td style="text-align:left">chi</td>
<td style="text-align:left">khai</td>
<td style="text-align:left">喜</td>
</tr>
<tr>
<td style="text-align:left">Ψ</td>
<td style="text-align:left">ψ</td>
<td style="text-align:left">psi</td>
<td style="text-align:left">psai</td>
<td style="text-align:left">普西</td>
</tr>
<tr>
<td style="text-align:left">Ω</td>
<td style="text-align:left">ω</td>
<td style="text-align:left">omega</td>
<td style="text-align:left">omiga</td>
<td style="text-align:left">欧米</td>
</tr>
</tbody>
</table>
<h2 id="基础概念" tabindex="-1"> 基础概念</h2>
<ul>
<li>
<p>自然数。从0开始算</p>
</li>
<li>
<p>质数。只能被1和他本事整除的正整数（即只有1和他本事两个约数）叫质数，反之为合数，1既不是质数也不是合数。</p>
<blockquote>
<p>质数:2,3,5,7,11,13,17,19<br>
合数：4，6，8，10
2是唯一一个即使质数也是偶数的正整数，即是唯一是偶质数，大于2的质数必定是奇数<br>
若正整数a,b的乘积是质数p，则a = p,b = 1或 b = p, a = 1<br>
若两个质数的和或差是奇数，那么其中一个质数必然是2。因为只有偶±奇才能等于奇数<br>
若两个质数的乘积是偶数，那么其中一个质数必然是2。因为只有奇乘偶才能是偶数</p>
</blockquote>
</li>
<li>
<p>互质数。公约数只有1的两个数叫互质数。如：9的约数{1,3,9},16的约数{1,2,4,8,16} 它们的公约数1，所以它们是互质数。</p>
</li>
<li>
<p>最小公倍数</p>
</li>
</ul>
<h2 id="方程" tabindex="-1"> 方程</h2>
<h3 id="一元二次" tabindex="-1"> 一元二次</h3>
<ul>
<li>
<p>直接开平方法</p>
<blockquote>
<p>若 $x^2=a(a \geq 0)$ ，则 $x=\pm \sqrt{a}$</p>
</blockquote>
</li>
<li>
<p>配方法</p>
<blockquote>
<p>但二次项系数为1的时，方程两边都加上一次项系数一半的平方。<br>
构成一个完全平方公式即(a+b)²=a²+2ab+b²、(a-b)²=a²-2ab+b²<br>
平方差公式：(a+b)(a-b)=a²-b²</p>
</blockquote>
<p>解方程：$x^2 + 3x = 0$<br>
$x^2 + 3x + (\frac{3}{2})^2 = (\frac{3}{2})^2$<br>
$(x+\frac{3}{2})^2 = \frac{9}{4}$<br>
$x+\frac{3}{2} = \pm \frac{3}{2}$<br>
$x = -\frac{6}{2} = -3$ 或 x = 0</p>
</li>
<li>
<p>因式分解法</p>
<blockquote>
<p>若(x-a)(x-b)=0，则x-a=0或x-b=0</p>
</blockquote>
</li>
<li>
<p>公式法</p>
<blockquote>
<p>方程$ax^2 + bx + c = 0(a \neq 0, 判别式：b^2-4ac\geq0)$,则解是$x=\frac{-b\pm \sqrt{b^2-4ac}}{2a}$</p>
</blockquote>
</li>
<li>
<p>根与系数的关系</p>
<blockquote>
<p>若$ax^2 + bx + c = 0(a \neq 0)$的两个跟为$x_1,x_2$<br>
则$x_1+x_2=- \frac{b}{a}$，$x_1x_2=\frac{c}{a}$</p>
</blockquote>
</li>
</ul>
<p><img src="@source/assets/img/解一元二次.png" alt="" loading="lazy"></p>
<h2 id="集合" tabindex="-1"> 集合</h2>
<ul>
<li>集合元素的性质：确定性、无序性、互异性</li>
<li>元素与集合的关系
<ul>
<li>属于 $\in$  , 不属于 $\notin$<br>
元素a在集合A里面：a $\in$ A<br>
元素a不再集合A里面: a $\notin$ A</li>
</ul>
</li>
<li>常见数集符合
<ul>
<li>$N$ 自然数集  <code>0,1,2,3……</code></li>
<li>$N^*$ 或 $N_+$ 正整数集 <code>1,2,3……</code></li>
<li>$Z$ 整数集，包含正整数，负整数，零</li>
<li>$Q$ 有理数集，有理数是整数（正整数、0、负整数）和分数的统称</li>
<li>$R$ 实数集，实数是有理数和无理数的总称</li>
</ul>
</li>
<li>集合之间的关系
<ul>
<li>A=B，相等。集合A和集合B中说有元素都相同</li>
<li>A$\subseteq$B，子集。B大，其实也有可能相等</li>
<li>A$\subseteq$B，真子集，符号有错误，下面是一个不等于号$\neq$。也是B大，而且不可能相等。</li>
<li>$\emptyset$，空集。空集是任何集合在子集，是任何非空集的真子集</li>
<li>A$\cup$B，并集。取两个集合的所有元素</li>
<li>A$\cap$B，交集。取两个集合相等的部分</li>
<li>$\complement_UA$，补集。A集合在全集U中，取U中除A集合剩下的部分</li>
</ul>
</li>
<li>必然结论
<ul>
<li>A$\cup$B = A 可推理出  A$\supseteq$B</li>
<li>A$\cap$B = A 可退理出  B$\supseteq$A</li>
<li>A$\cap$A = A</li>
<li>$A\cap \emptyset = \emptyset$</li>
<li>$A\cap\complement_UA = \emptyset$</li>
<li>$A\cup\complement_UA = U$</li>
<li>$\complement_U(\complement_UA) = A$</li>
<li>$A\subseteq B$ 可推理出 $A\cap B = A$ 可推理出 $A\cup B = B$ 可推理出 $\complement_UB \subseteq \complement_UA$ 可推理出 $A \cap (\complement_UB) = \emptyset$</li>
<li>集合A中有n个元素，那么他的子集个数为$2<sup>n$，真子集个数为$2</sup>n-1$，非空真子集个数为$2^n-2$</li>
</ul>
<blockquote>
<p>例：集合A = {1,2,3}<br>
子集有：空集、{1}、{2}、{3}、{1,2}、{1,3}、{2,3}、{1,2,3} 共8个 =  $2^3$<br>
真子集去掉{1,2,3} 共7个<br>
非空真子集去掉{1,2,3}和空集，共6个</p>
</blockquote>
</li>
</ul>
<h2 id="函数" tabindex="-1"> 函数</h2>
<p>函数三要素：定义域，对应关系，值域。</p>
<p>函数：$y=f(x),x \in A$</p>
<ul>
<li>定义域：自变量x取值范围构成的集合</li>
<li>值域：函数值的集合 {$f(x), x\in A$}</li>
</ul>
<h2 id="方差" tabindex="-1"> 方差</h2>
<p>方差是各个数据与平均数之差的平方的和的平均数。</p>
<p>$S^2 = \frac{1}{n}[(x_1-x)^2 + (x_2-x)^2 + ... + (x_n-x)^2]$</p>
<p>$S^2 = \frac{\sum^n_{i=1}(x_i - x)^2}{n}$</p>
<p>其中，x表示样本的平均数，n表示样本的数量，$x_i$表示个体，而$S^2$就表示方差。</p>
<blockquote>
<p>两人的5次测验成绩如下：X： 50，100，100，60，50，平均值E(X)=72；Y：73， 70，75，72，70 平均值E(Y)=72。平均成绩相同，但X 不稳定，对平均值的偏离大。方差描述随机变量对于数学期望的偏离程度。<br>
方差越小越稳定</p>
</blockquote>
<h2 id="标准差" tabindex="-1"> 标准差</h2>
<p>$δ=\sqrt(\frac{(x_1-x)^2 +(x_2-x)^2 +......(x_n-x)^2)}{n})$</p>
<p>方差=标准差的平方</p>
<h2 id="数据标准化-normalization-method" tabindex="-1"> 数据标准化 Normalization Method</h2>
<blockquote>
<p>机器学习算法中要求样本间的距离就要使用数据归一化，把数据映射到同一尺度。<br>
数据归一化是为了解决量纲的问题，使数据映射到同一尺度。举2个例子：比如两个特征为月收入和和身高。月收入范围5000元-30000元，身高为1m-2.5m，在计算两个特征的欧式距离时，由于取值范围身高这一特征被忽略了，这样就让身高这一特征的信息失效了。所以要使用数据归一化把数据映射到同一尺度</p>
</blockquote>
<ul>
<li>
<p>标准归一化 Z-score标准化</p>
<p>$x∗ = \frac{x−μ}{δ}$</p>
<p>其中 μ为所有样本数据的均值（mean）， δ为所有样本数据的标准差（standard deviation）。</p>
</li>
<li>
<p>最大最小归一化</p>
<p>也称为离差标准化，是对原始数据的线性变换，使结果值映射到 [0 - 1] 之间。</p>
<p>$x∗=\frac{x − x_{min}}{x_{max} − x_{min}}$</p>
<p>其中 $x_{max}$为样本数据的最大值， $x_{min}$为样本数据的最小值。这种方法有个缺陷就是当有新数据加入时，可能导致 $x_{max}$和 $x_{min}$的变化，需要重新定义。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title></title>
      <link>https://abelsun.tech/algorithm/BloomFilter.html</link>
      <guid>https://abelsun.tech/algorithm/BloomFilter.html</guid>
      <source url="https://abelsun.tech/rss.xml"></source>
      <description>布隆过滤器 Bloom Filter 应用场景 在大量是数据池中找出某元素是否存在。 字处理软件中，需要检查一个英语单词是否拼写正确; 在 FBI，一个嫌疑人的名字是否已经在嫌疑名单上; 在网络爬虫里，一个网址是否被访问过; yahoo, gmail等邮箱垃圾邮件过滤功能; 联想到的解决方案 数组; 链表; 树、平衡二叉树、Trie; Map (红黑树...</description>
      <pubDate>Sat, 19 Nov 2022 02:42:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="布隆过滤器-bloom-filter" tabindex="-1"> 布隆过滤器 Bloom Filter</h2>
<h2 id="应用场景" tabindex="-1"> 应用场景</h2>
<p>在大量是数据池中找出某元素是否存在。</p>
<ul>
<li>字处理软件中，需要检查一个英语单词是否拼写正确</li>
<li>在 FBI，一个嫌疑人的名字是否已经在嫌疑名单上</li>
<li>在网络爬虫里，一个网址是否被访问过</li>
<li>yahoo, gmail等邮箱垃圾邮件过滤功能</li>
</ul>
<p>联想到的解决方案</p>
<ul>
<li>数组</li>
<li>链表</li>
<li>树、平衡二叉树、Trie</li>
<li>Map (红黑树)</li>
<li>哈希表</li>
</ul>
<p>对于这些方案 BloomFilter 具有时间和空间上的优势</p>
<h2 id="原理" tabindex="-1"> 原理</h2>
<p>布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k</p>
<p><img src="@source/assets/img/bloomfilter.webp" alt="BloomFilter" loading="lazy"></p>
<p>假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。</p>
<h2 id="实现" tabindex="-1"> 实现</h2>
<h3 id="基础实现" tabindex="-1"> 基础实现</h3>
<p>对于程序员来说概念不好理解，代码更好理解。下面就是基础的实现方式，目的就是更好的理解实现原理。</p>
<div data-ext="java"><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>BitSet</span></span><span>;</span>

<span>public</span> <span>class</span> <span>SimpleBloomFilter</span> <span>{</span>

    <span>private</span> <span>static</span> <span>final</span> <span>int</span> <span>DEFAULT_SIZE</span> <span>=</span> <span>2</span> <span>&lt;&lt;</span> <span>24</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span><span>[</span><span>]</span> seeds <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span> <span>{</span><span>7</span><span>,</span> <span>11</span><span>,</span> <span>13</span><span>,</span> <span>31</span><span>,</span> <span>37</span><span>,</span> <span>61</span><span>,</span><span>}</span><span>;</span>

    <span>private</span> <span>BitSet</span> bits <span>=</span> <span>new</span> <span>BitSet</span><span>(</span><span>DEFAULT_SIZE</span><span>)</span><span>;</span>
    <span>private</span> <span>SimpleHash</span><span>[</span><span>]</span> func <span>=</span> <span>new</span> <span>SimpleHash</span><span>[</span>seeds<span>.</span>length<span>]</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>String</span> value <span>=</span> <span>"Hello World"</span><span>;</span>
        <span>SimpleBloomFilter</span> filter <span>=</span> <span>new</span> <span>SimpleBloomFilter</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>contains</span><span>(</span>value<span>)</span><span>)</span><span>;</span>
        filter<span>.</span><span>add</span><span>(</span>value<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>filter<span>.</span><span>contains</span><span>(</span>value<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>SimpleBloomFilter</span><span>(</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> seeds<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            func<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>SimpleHash</span><span>(</span><span>DEFAULT_SIZE</span><span>,</span> seeds<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>String</span> value<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>SimpleHash</span> f <span>:</span> func<span>)</span> <span>{</span>
            bits<span>.</span><span>set</span><span>(</span>f<span>.</span><span>hash</span><span>(</span>value<span>)</span><span>,</span> <span>true</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>String</span> value<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>value <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>boolean</span> ret <span>=</span> <span>true</span><span>;</span>
        <span>for</span> <span>(</span><span>SimpleHash</span> f <span>:</span> func<span>)</span> <span>{</span>
            ret <span>=</span> ret <span>&amp;&amp;</span> bits<span>.</span><span>get</span><span>(</span>f<span>.</span><span>hash</span><span>(</span>value<span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> ret<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>class</span> <span>SimpleHash</span> <span>{</span>

        <span>private</span> <span>int</span> cap<span>;</span>
        <span>private</span> <span>int</span> seed<span>;</span>

        <span>public</span> <span>SimpleHash</span><span>(</span><span>int</span> cap<span>,</span> <span>int</span> seed<span>)</span> <span>{</span>
            <span>this</span><span>.</span>cap <span>=</span> cap<span>;</span>
            <span>this</span><span>.</span>seed <span>=</span> seed<span>;</span>
        <span>}</span>

        <span>public</span> <span>int</span> <span>hash</span><span>(</span><span>String</span> value<span>)</span> <span>{</span>
            <span>int</span> result <span>=</span> <span>0</span><span>;</span>
            <span>int</span> len <span>=</span> value<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                result <span>=</span> seed <span>*</span> result <span>+</span> value<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>
            <span>}</span>
            <span>return</span> <span>(</span>cap <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> result<span>;</span>
        <span>}</span>

    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="生产实现" tabindex="-1"> 生产实现</h3>
<ul>
<li><a href="https://mvnrepository.com/artifact/com.google.guava/guava" target="_blank" rel="noopener noreferrer">Guava</a> com.google.common.hash.BloomFilter</li>
<li><a href="../assets/code/BloomFilter.java">BloomFilter.java</a>  <a href="https://github.com/MagnusS/Java-BloomFilter/blob/master/src/com/skjegstad/utils/BloomFilter.java" target="_blank" rel="noopener noreferrer">usedby</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title></title>
      <link>https://abelsun.tech/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0.html</link>
      <guid>https://abelsun.tech/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0.html</guid>
      <source url="https://abelsun.tech/rss.xml"></source>
      <description>算法学习 algorithm 记录常用解决方案算法 收藏一下算法的使用案例 基础 [All Algorithms implemented in Java ](https://github.com/TheAlgorithms/Java) GitHub stars 寻路算法 A\*（A-Star) A\* Pathfinding for Beginners...</description>
      <pubDate>Sat, 19 Nov 2022 02:42:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="算法学习-algorithm" tabindex="-1"> 算法学习 algorithm</h2>
<p>记录常用解决方案算法<br>
收藏一下算法的使用案例</p>
<h2 id="基础" tabindex="-1"> 基础</h2>
<p><a href="https://github.com/TheAlgorithms/Java" target="_blank" rel="noopener noreferrer">All Algorithms implemented in Java
</a>
<img src="https://img.shields.io/github/stars/TheAlgorithms/Java?style=flat-square" alt="GitHub stars" loading="lazy"></p>
<h2 id="寻路算法" tabindex="-1"> 寻路算法</h2>
<ul>
<li>A*（A-Star) <a href="https://www.gamedev.net/articles/programming/artificial-intelligence/a-pathfinding-for-beginners-r2003/" target="_blank" rel="noopener noreferrer">A* Pathfinding for Beginners</a>
<a href="https://github.com/sbfkcel/fast-astar" target="_blank" rel="noopener noreferrer">fast-astar</a> <img src="https://img.shields.io/github/stars/sbfkcel/fast-astar?style=flat-square" alt="GitHub stars" loading="lazy"></li>
</ul>
<h2 id="搜索" tabindex="-1"> 搜索</h2>
<ul>
<li>DFS 深度优先搜索</li>
<li>BFS 宽度/广度优先搜索</li>
</ul>
<h2 id="协同编辑" tabindex="-1"> 协同编辑</h2>
<ul>
<li>OT （Operational Transformation）
<ul>
<li><a href="https://blog.csdn.net/pheecian10/article/details/78496854" target="_blank" rel="noopener noreferrer">1</a></li>
<li><a href="https://yafeilee.com/blogs/100" target="_blank" rel="noopener noreferrer">2</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img.shields.io/github/stars/TheAlgorithms/Java?style=flat-square" type="image/"/>
    </item>
    <item>
      <title></title>
      <link>https://abelsun.tech/bigdata/Elasticsearch.html</link>
      <guid>https://abelsun.tech/bigdata/Elasticsearch.html</guid>
      <source url="https://abelsun.tech/rss.xml"></source>
      <description>Elasticsearch 关键字 Cluster：集群。; ES可以作为一个独立的单个搜索服务器。不过，为了处理大型数据集，实现容错和高可用性，ES可以运行在许多互相合作的服务器上。这些服务器的集合称为集群。 Node：节点。; 形成集群的每个服务器称为节点。 Shard：分片。; 当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应...</description>
      <pubDate>Sat, 19 Nov 2022 02:42:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="elasticsearch" tabindex="-1"> Elasticsearch</h2>
<h2 id="关键字" tabindex="-1"> 关键字</h2>
<ul>
<li>
<p>Cluster：集群。</p>
<p>ES可以作为一个独立的单个搜索服务器。不过，为了处理大型数据集，实现容错和高可用性，ES可以运行在许多互相合作的服务器上。这些服务器的集合称为集群。</p>
</li>
<li>
<p>Node：节点。
形成集群的每个服务器称为节点。</p>
</li>
<li>
<p>Shard：分片。</p>
<p>当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。
当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的。</p>
</li>
<li>
<p>Replia：副本。</p>
<p>为提高查询吞吐量或实现高可用性，可以使用分片副本。
副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。
当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。</p>
</li>
<li>
<p>全文检索。</p>
<p>全文检索就是对一篇文章进行索引，可以根据关键字搜索，类似于mysql里的like语句。
全文索引就是把内容根据词的意义进行分词，然后分别创建索引，例如”你们的激情是因为什么事情来的” 可能会被分词成：“你们“，”激情“，“什么事情“，”来“ 等token，这样当你搜索“你们” 或者 “激情” 都会把这句搜出来。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Elasticsearch</th>
<th>MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>Index</td>
<td>Database</td>
</tr>
<tr>
<td>Type</td>
<td>Table</td>
</tr>
<tr>
<td>Mapping</td>
<td>Schema</td>
</tr>
<tr>
<td>Document</td>
<td>Row</td>
</tr>
<tr>
<td>Field</td>
<td>Column</td>
</tr>
<tr>
<td>Query DSL</td>
<td>SQL</td>
</tr>
<tr>
<td>Restful API</td>
<td>insert select update delete</td>
</tr>
</tbody>
</table>
<h3 id="安装" tabindex="-1"> 安装</h3>
<ul>
<li>Docker</li>
</ul>
<div data-ext="sh"><pre><code><span>docker</span> run <span>-d</span> <span>--name</span> elasticsearch <span>-p</span> <span>9200</span>:9200 <span>-p</span> <span>9300</span>:9300 <span>--restart</span><span>=</span>always elasticsearch:6.8.5
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>极限网关
<a href="http://gateway.infinilabs.com/zh/" target="_blank" rel="noopener noreferrer">http://gateway.infinilabs.com/zh/</a></li>
</ul>
<h3 id="常用api" tabindex="-1"> 常用API</h3>
<div data-ext="sh"><pre><code>-- 所有节点
<span>curl</span> http://127.0.0.1:9200/_cat/nodes?v
-- 所有 index
<span>curl</span> <span>'localhost:9200/_cat/indices?v'</span>

-- 导入导出 https://github.com/elasticsearch-dump/elasticsearch-dump
elasticdump <span>--input</span><span>=</span>http://localhost:9200/index-law <span>--output</span><span>=</span>my_index.json <span>--type</span><span>=</span>data

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="备份" tabindex="-1"> 备份</h4>
<div data-ext="sh"><pre><code><span>vim</span> /etc/elasticsearch/elasticsearch.yml
path.repo: <span>"/data/elasticsearch/backup

curl -XPOST -H 'Content-Type: application/json' http://127.0.0.1:9200/_snapshot/my_es_backup -d '
{
    "</span><span>type</span><span>": "</span>fs<span>",
    "</span>settings<span>": {
        "</span>location<span>": "</span>/home/sdb1/my_es_backup<span>",
        "</span>max_snapshot_bytes_per_sec<span>" : "</span>100mb<span>",
        "</span>max_restore_bytes_per_sec<span>" : "</span>100mb<span>",
        "</span>compress<span>" : true
    }
}'

-- 查看
curl -XGET "</span>localhost:9200/_snapshot/my_es_backup/_all?pretty"
-- 恢复
<span>curl</span> <span>-XPOST</span> http://127.0.0.1:9200/_snapshot/my_es_backup/snapshot_1/_restore?wait_for_completion<span>=</span>true
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="elasticsearch-head" tabindex="-1"> elasticsearch-head</h2>
<blockquote>
<p>A web front end for an elastic search cluster</p>
</blockquote>
<h3 id="安装-1" tabindex="-1"> 安装</h3>
<ul>
<li>Docker</li>
</ul>
<div data-ext="sh"><pre><code><span>docker</span> run <span>-d</span> <span>--name</span> es-head <span>-p</span> <span>9100</span>:9100 mobz/elasticsearch-head:5
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>
<p>跨域问题 <code>No 'Access-Control-Allow-Origin'</code></p>
<p><strong>修改 elasticsearch 配置文件</strong></p>
<div data-ext="sh"><pre><code><span>vim</span> /usr/share/elasticsearch/config/elasticsearch.yml

<span>#开启跨域访问支持，默认为false</span>
http.cors.enabled: <span>true</span>
<span>#跨域访问允许的域名地址，(允许所有域名)以上使用正则</span>
http.cors.allow-origin: /.*/

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>请求方式错误 <code>406 Not Acceptable</code></p>
<p>一般在使用elasticsearch 6.x 才会出现，因为<code>elasticsearch-head</code> 只适配到了5，而6.X 请求方式变成 <code>json</code> 方式请求<br>
<strong>修改 elasticsearch-head 源码</strong></p>
<div data-ext="sh"><pre><code><span>vim</span> /usr/src/app/_site/vendor.js

将
contentType: <span>"application/x-www-form-urlencoded"</span>
改为
contentType: <span>"application/json"</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title></title>
      <link>https://abelsun.tech/bigdata/Flink.html</link>
      <guid>https://abelsun.tech/bigdata/Flink.html</guid>
      <source url="https://abelsun.tech/rss.xml"></source>
      <description>Flink 大数据计算技术演进： 1. Hadoop 承载的 MapReduce 1. 支持 DAG（有向无环图）框架的计算引擎 Tez 和 Oozie，主要还是批处理任务 1. 支持 Job 内部的 DAG（有向无环图），以 Spark 为代表 1. 大数据统一计算引擎，包括流处理、批处理、AI、Machine Learning、图计算等，以 Fli...</description>
      <pubDate>Sat, 19 Nov 2022 02:42:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="flink" tabindex="-1"> Flink</h2>
<p>大数据计算技术演进：</p>
<ol>
<li>Hadoop 承载的 MapReduce</li>
<li>支持 DAG（有向无环图）框架的计算引擎 Tez 和 Oozie，主要还是批处理任务</li>
<li>支持 Job 内部的 DAG（有向无环图），以 Spark 为代表</li>
<li>大数据统一计算引擎，包括流处理、批处理、AI、Machine Learning、图计算等，以 Flink 为代表</li>
</ol>
<h2 id="场景" tabindex="-1"> 场景</h2>
<ul>
<li>业务数据处理，聚合业务数据，统计分析</li>
<li>流量日志，动态数据监控</li>
<li>交通信号灯数据</li>
<li>道路上车流量统计（拥堵状况）</li>
<li>公安视频监控</li>
<li>服务器运行状态监控</li>
<li>金融证券公司实时跟踪股市波动，计算风险价值</li>
<li>数据实时 ETL</li>
<li>银行或者支付公司涉及金融盗窃的预警</li>
<li>扩展库：CEP（复杂事件处理）、机器学习、图形处理</li>
</ul>
<h2 id="大数据" tabindex="-1"> 大数据</h2>
<h3 id="数据集类型" tabindex="-1"> 数据集类型</h3>
<ul>
<li>
<p>无穷数据集：无穷的持续集成的数据集合</p>
<blockquote>
<p>用户与客户端的实时交互数据<br>
应用实时产生的日志<br>
金融市场的实时交易记录</p>
</blockquote>
</li>
<li>
<p>有界数据集：有限不会改变的数据集合</p>
</li>
</ul>
<h3 id="数据运算模型" tabindex="-1"> 数据运算模型</h3>
<ul>
<li>流式：只要数据一直在产生，计算就持续地进行</li>
<li>批处理：在预先定义的时间内运行计算，当计算完成时释放计算机资源</li>
</ul>
<p>Flink 其特点就是处理 <strong>流式数据</strong> ，但是他其实是一个针对 <strong>流数据</strong>（DataStream）和 <strong>批数据</strong>（DataSet）的分布式处理引擎，是一个 <strong>流批统一</strong> 的计算引擎。</p>
<h2 id="部署" tabindex="-1"> 部署</h2>
<ul>
<li>
<p>Local</p>
<blockquote>
<p>直接在 IDE 中运行 Flink Job 时则会在本地启动一个 mini Flink 集群</p>
</blockquote>
</li>
<li>
<p>Standalone</p>
<blockquote>
<p>在 Flink 目录下执行 bin/start-cluster.sh 脚本则会启动一个 Standalone 模式的集群</p>
</blockquote>
</li>
<li>
<p>YARN</p>
<blockquote>
<p>YARN 是 Hadoop 集群的资源管理系统，它可以在群集上运行各种分布式应用程序，Flink 可与其他应用并行于 YARN 中</p>
</blockquote>
</li>
<li>
<p>Kubernetes</p>
</li>
<li>
<p>AWS、MapR、Aliyun OSS</p>
</li>
</ul>
<h2 id="结构" tabindex="-1"> 结构</h2>
<h3 id="api" tabindex="-1"> API</h3>
<p>至下而上：</p>
<ul>
<li>
<p>Stateful Stream Processing 最底层提供了有状态流</p>
<blockquote>
<p>它将通过 Process Function 嵌入到 DataStream API 中。它允许用户可以自由地处理来自一个或多个流数据的事件，并使用一致性、容错的状态。除此之外，用户可以注册事件时间和处理事件回调，从而使程序可以实现复杂的计算。</p>
</blockquote>
</li>
<li>
<p>DataStream/DataSet API 是 Flink 提供的核心 API</p>
<blockquote>
<p>DataSet 处理有界的数据集，DataStream 处理有界或者无界的数据流。用户可以通过各种方法（map/flatmap/window/keyby/sum/max/min/avg/join 等）将数据进行转换或者计算。</p>
</blockquote>
</li>
<li>
<p>Table API 表为中心的声明式 DSL</p>
<blockquote>
<p>其中表可能会动态变化（在表达流数据时）。Table API 提供了例如 select、project、join、group-by、aggregate 等操作，使用起来却更加简洁（代码量更少）。 你可以在表与 DataStream/DataSet 之间无缝切换，也允许程序将 Table API 与 DataStream 以及 DataSet 混合使用。</p>
</blockquote>
</li>
<li>
<p>SQL</p>
<blockquote>
<p>这一层抽象在语法与表达能力上与 Table API 类似，但是是以 SQL查询表达式的形式表现程序。SQL 抽象与 Table API 交互密切，同时 SQL 查询可以直接在 Table API 定义的表上执行。 Flink 除了 DataStream 和 DataSet API，它还支持 Table/SQL API，Flink 也将通过 SQL API 来构建统一的大数据流批处理引擎，因为在公司中通常会有那种每天定时生成报表的需求（批处理的场景，每晚定时跑一遍昨天的数据生成一个结果报表），但是也是会有流处理的场景（比如采用 Flink 来做实时性要求很高的需求），于是慢慢的整个公司的技术选型就变得越来越多了，这样开发人员也就要面临着学习两套不一样的技术框架，运维人员也需要对两种不一样的框架进行环境搭建和作业部署，平时还要维护作业的稳定性。</p>
</blockquote>
</li>
</ul>
<h3 id="模拟程序与数据流结构" tabindex="-1"> 模拟程序与数据流结构</h3>
<p><a href="https://gitbook.cn/gitchat/column/5dad4a20669f843a1a37cb4f/topic/5db69938f6a6211cb96164da" target="_blank" rel="noopener noreferrer"><img src="@source/assets/img/DevOps-BD-FLINK-1.png" alt="" loading="lazy"></a></p>
<ul>
<li>
<p>Source：数据输入</p>
<blockquote>
<p>Flink 在流处理和批处理上的 source 大概有 4 类：基于本地集合的 source、基于文件的 source、基于网络套接字的 source、自定义的 source。自定义的 source 常见的有 Apache kafka、Amazon Kinesis Streams、RabbitMQ、Twitter Streaming API、Apache NiFi 等，当然你也可以定义自己的 source。</p>
</blockquote>
</li>
<li>
<p>Transformation：数据转换的各种操作</p>
<blockquote>
<p>有 Map/FlatMap/Filter/KeyBy/Reduce/Fold/ Aggregations/Window/WindowAll/Union/Window join/Split/Select/Project 等，操作很多，可以将数据转换计算成你想要的数据。</p>
</blockquote>
</li>
<li>
<p>Sink：数据输出</p>
<blockquote>
<p>Flink 将转换计算后的数据发送的地点，你可能需要存储下来，Flink 常见的 Sink 大概有如下几类：写入文件、打印出来、写入 socket、自定义的 sink 。自定义的 Sink 常见的有 Apache kafka、RabbitMQ、MySQL、ElasticSearch、Apache Cassandra、Hadoop FileSystem 等，同理你也可以定义自己的 sink。</p>
</blockquote>
</li>
</ul>
<h3 id="事件时间-处理时间语义" tabindex="-1"> 事件时间&amp;处理时间语义</h3>
<ul>
<li>Event time 事件自身时间
Ingestion Time 事件进入flink的时间
Processing Time 事件被处理时的机器事件</li>
</ul>
<h3 id="窗口机制" tabindex="-1"> 窗口机制</h3>
<p>Flink 支持多种 Window，比如 Time Window、Count Window、Session Window，还支持自定义 Window</p>
<h3 id="并行执行任务" tabindex="-1"> 并行执行任务</h3>
<p>stream partitions
operator subtasks</p>
<h3 id="状态存储和容错" tabindex="-1"> 状态存储和容错</h3>
<p>Flink 是一款有状态的流处理框架，它提供了丰富的状态访问接口，按照数据的划分方式，可以分为 Keyed State 和 Operator State，在 Keyed State 中又提供了多种数据结构：</p>
<ul>
<li>ValueState</li>
<li>MapState</li>
<li>ListState</li>
<li>ReducingState</li>
<li>AggregatingState</li>
</ul>
<p>另外状态存储也支持多种方式：</p>
<ul>
<li>MemoryStateBackend：存储在内存中</li>
<li>FsStateBackend：存储在文件中</li>
<li>RocksDBStateBackend：存储在 RocksDB 中</li>
</ul>
<p>Flink 中支持使用 Checkpoint 来提高程序的可靠性，开启了 Checkpoint 之后，Flink 会按照一定的时间间隔对程序的运行状态进行备份，当发生故障时，Flink 会将所有任务的状态恢复至最后一次发生 Checkpoint 中的状态，并从那里开始重新开始执行。</p>
<p>另外 Flink 还支持根据 Savepoint 从已停止作业的运行状态进行恢复，这种方式需要通过命令进行触发。</p>
<h3 id="内存管理机制" tabindex="-1"> 内存管理机制</h3>
<p>Flink 在 JVM 中提供了自己的内存管理，使其独立于 Java 的默认垃圾收集器。它通过使用散列、索引、缓存和排序有效地进行内存管理</p>
<p>// TODO Flink</p>
]]></content:encoded>
    </item>
    <item>
      <title></title>
      <link>https://abelsun.tech/bigdata/%E5%95%86%E4%B8%9A%E6%99%BA%E8%83%BD.html</link>
      <guid>https://abelsun.tech/bigdata/%E5%95%86%E4%B8%9A%E6%99%BA%E8%83%BD.html</guid>
      <source url="https://abelsun.tech/rss.xml"></source>
      <description>BI (Business Intelligence) 商业智能 ETL Extract-Transform-Load ETL是将业务系统的数据经过抽取(Extract)、清洗转换(Transform)之后加载(Load)到数据仓库（Data Warehouse）或数据集市（Data Mart）中，成为联机分析处理（On-Line Analytical ...</description>
      <pubDate>Sat, 19 Nov 2022 02:42:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="bi-business-intelligence-商业智能" tabindex="-1"> BI (Business Intelligence) 商业智能</h2>
<h2 id="etl-extract-transform-load" tabindex="-1"> ETL Extract-Transform-Load</h2>
<p>ETL是将业务系统的数据经过抽取(Extract)、清洗转换(Transform)之后加载(Load)到数据仓库（Data Warehouse）或数据集市（Data Mart）中，成为联机分析处理（On-Line Analytical Processing，OLAP）、数据挖掘（Data Mining）的基础。目的是将企业中的分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析依据。</p>
<blockquote>
<p><strong>抽取</strong> 是将数据从已有的数据源中提取出来，例如通过 JDBC/Binlog 方式获取 MySQL 数据库的增量数据；<strong>转换</strong> 是对原始数据进行处理，例如将用户属性中的手机号替换为匿名的唯一 ID、计算每个用户对商品的平均打分、计算每个商品的购买数量、将 B 表的数据填充到 A 表中形成新的宽表等；<strong>加载</strong> 是将数据写入目的地。</p>
</blockquote>
<p><img src="@source/assets/img/ETL-ELT.png" alt="" loading="lazy"></p>
<ul>
<li><a href="http://camel.apache.org/" target="_blank" rel="noopener noreferrer">Apache Camel</a></li>
<li><a href="http://apatar.com/" target="_blank" rel="noopener noreferrer">Apatar</a></li>
<li><a href="http://hekad.readthedocs.io" target="_blank" rel="noopener noreferrer">Heka</a></li>
<li><a href="https://www.elastic.co/products/logstash" target="_blank" rel="noopener noreferrer">ElasticSearch</a></li>
<li><a href="http://scriptella.org/" target="_blank" rel="noopener noreferrer">Scriptella</a></li>
<li><a href="http://www.talend.com/" target="_blank" rel="noopener noreferrer">Talend</a></li>
<li><a href="https://github.com/pentaho/pentaho-kettle" target="_blank" rel="noopener noreferrer">Kettle</a></li>
<li><a href="https://www.informatica.com/" target="_blank" rel="noopener noreferrer">Informatica</a></li>
<li><a href="https://www.ibm.com/products/infosphere-datastage" target="_blank" rel="noopener noreferrer">DataStage</a></li>
</ul>
<h2 id="elt" tabindex="-1"> ELT</h2>
<p>ELT 和 ETL 相比，ETL 在数据源抽取后首先进行转换，然后将转换的结果写入目的地。ELT 则是在抽取后将结果先写入目的地，然后由下游应用利用数据库的聚合分析能力或者外部计算框架，例如 Spark 来完成转换的步骤。最大的区别是“重抽取和加载，轻转换”，从而可以用更简单的技术栈、更轻量的方案搭建起一个满足现代企业应用的数据集成平台。AI 应用内在的特点也使得 ELT 特别适合这个场景。</p>
<ul>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem" target="_blank" rel="noopener noreferrer">Kafka</a></li>
<li><a href="https://docs.confluent.io/current/connect/index.html" target="_blank" rel="noopener noreferrer">Kafka Connect</a></li>
<li><a href="https://github.com/alibaba/DataX" target="_blank" rel="noopener noreferrer">DataX</a></li>
<li><a href="https://www.datapipeline.com/" target="_blank" rel="noopener noreferrer">DataPipeline</a></li>
</ul>
<h2 id="案例" tabindex="-1"> <a href="https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;mid=2655830097&amp;idx=1&amp;sn=a637be12d879ab6f43bc35a74cdc70c6" target="_blank" rel="noopener noreferrer">案例</a></h2>
<p>设计要求在用户输入搜索内容时，要能从商家名称和商品名称两个维度去搜索，搜索出来的结果，按照准确率排序，并按商家所属商品的关联关系，来组合数据结构，同时提供 API 给业务系统调用。</p>
<ul>
<li>商家数据库和商品数据库是多台不同的服务器，并且数据量达百万级，如何才能实现跨数据库的数据同步呢？</li>
<li>商家和商品的数据是有从属关系的，不然就会把肯德基的香辣鸡腿堡挂到麦当劳去，这就尴尬了！</li>
<li>商家商品数据是经常更新的，比如修改价格、库存、上下架等，那搜索服务可不能搜出一堆过时的数据，如果客户明明搜出来的商品，点进去后却已下架了，那么客户就要吐槽了！如何实现搜索数据与源数据库增删改均实时同步呢？</li>
</ul>
<h3 id="架构设计" tabindex="-1"> 架构设计</h3>
<ul>
<li>首先，商家数据和商品数据分别存储在 2 个独立的 MySQL8 数据库，为满足商家数据和商品数据的关联，我们需要将两个库中所需要的表实时 ETL 到我们的搜索系统数据库。</li>
<li>其次，数据从商家、商品数据库 ETL 到搜索系统数据库后，需要实时的组合成为商家关联商品数据结构，并以父子文档的格式，存储到 ES 中。</li>
<li>最后，商家、商品数据库的增删改操作，需要实时的同步到 ES 中，也就是 ES 中的数据，需要支持实时的增加、删除和修改。</li>
<li>为此，我们设计了 2 个 Canal 组件，第一个 Canal 实现数据 ETL，把商家、商品数据库的某些表及字段，抽取到搜索服务数据库。</li>
<li>再利用第二个 Canal，读取搜索服务 MySQL 数据库的 Binlog，实时传输到 Kafka 消息队列，再由 canal adapter 对数据进行关联、父子文档映射等，将处理好的数据存储到 ElasticSearch 中。</li>
</ul>
<h2 id="bi商业软件" tabindex="-1"> BI商业软件</h2>
<ul>
<li><a href="https://www.tableau.com/" target="_blank" rel="noopener noreferrer">tableau</a></li>
<li><a href="http://www.powerbi.com.cn/" target="_blank" rel="noopener noreferrer">powerbi</a></li>
<li><a href="https://powerbi.microsoft.com/" target="_blank" rel="noopener noreferrer">powerbi microsoft</a></li>
<li><a href="http://www.meritdata.com.cn/" target="_blank" rel="noopener noreferrer">tempo</a></li>
<li><a href="https://www.dataojo.com/index.html" target="_blank" rel="noopener noreferrer">dataojo</a></li>
<li><a href="https://www.aliyun.com/product/bigdata/ide" target="_blank" rel="noopener noreferrer">DataWorks</a></li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>