<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://bytecodes.tech/rss.xml" rel="self" type="application/rss+xml"/>
    <title>凤凰涅槃进阶之路</title>
    <link>https://bytecodes.tech/</link>
    <description>开源工具、效率方法、心理学探索的自我提升笔记，记录并输出一切能让自己提升的知识。</description>
    <language>zh-CN</language>
    <pubDate>Mon, 26 Dec 2022 08:37:37 GMT</pubDate>
    <lastBuildDate>Mon, 26 Dec 2022 08:37:37 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>区块链</category>
    <category>区块链学习</category>
    <item>
      <title>区块链与随机数</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/Block_chain_and_random_Numbers.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/Block_chain_and_random_Numbers.html</guid>
      <source url="https://bytecodes.tech/rss.xml">区块链与随机数</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="计算机的随机数" tabindex="-1"> 计算机的随机数</h2>
<p>理论上计算机是无法真正生成随机数的，给它相同的输入，它都应该是同样的输出。<br>
为了生成随机数(Random numbers)，计算机将依赖于 seed (种子)：用于获取输出的输入 (input)。<br>
种子可以是:<br>
<strong>屏幕上鼠标光标的移动的像素位置</strong> (在500万像素屏幕中，需要重复完全一样的鼠标运动轨迹，这种任务对于人类完成度几乎是不可能的);
大气的噪音、宇宙背景辐射、放射物的衰变期、量子塌缩现象熔岩灯。<br>
在种子之上，计算机将执行数学运算并最终得出一个人类无法预测的数字。</p>
<blockquote>
<p><a href="https://www.bitaddress.org/" target="_blank" rel="noopener noreferrer">BitAddress</a> 一个开源的比特币钱包工具，他的 seed 值就是采集鼠标轨迹来完成<br>
<a href="https://www.random.org/" target="_blank" rel="noopener noreferrer">random.org</a>大气噪音生成随机数,他用录音设备获得大气中的声波，再检测其细微变化作为生成随机数的熵源<br>
<a href="https://gizmodo.com/one-of-the-secrets-guarding-the-secure-internet-is-a-wa-1820188866" target="_blank" rel="noopener noreferrer">Cloudflare</a> 内部不定形状的蜡滴的缓慢流动。<a href="https://www.cloudflare.com/zh-cn/learning/ssl/lava-lamp-encryption/" target="_blank" rel="noopener noreferrer">Cloudflare</a> 利用摄像头监视熔岩灯，拍摄视频和照片，然后将其转变成无法预测的随机比特流，再用它生成密钥</p>
</blockquote>
<p>区块链中没有鼠标、传感器或者运动比赛结果预测。更重要的是，即使一个节点到达某个随机数，但该随机数必须与区块链的所有其他节点的随机数相同(必须产生具有一致性的随机性)，不然无法验证。</p>
<h2 id="区块链中的随机数" tabindex="-1"> 区块链中的随机数</h2>
<blockquote>
<p>区块链中随机数的应用场景：</p>
<ul>
<li>公平的决定出块权力，维持一致性共识。部分PoW与PoS机制下，依靠随机数选定出块者或者出块组的，包括DPoS机制下的循环出块的顺序，也是依靠随机数决定</li>
<li>私钥的生成。目前私钥只要由各钱包自定随机数方法生成，存在较大安全隐患</li>
<li>链上应用的随机数源。保证博彩、游戏、抽奖、分发、调查等应用的公平公正，此类容易被黑客攻击</li>
<li>数据加密。链上数据因为是公开审查的，需要强度较高的加密，通过足够强的随机数确保链上数据的隐私与安全</li>
</ul>
</blockquote>
<h3 id="区块哈希" tabindex="-1"> 区块哈希</h3>
<p>依赖区块哈希 (block hash) 来处理随机性。因为哈希值是未知的、随机的，但在所有节点上都是相同的，所以对于基本可证明公平的赌博来说，哈希值可以作为随机性的来源。</p>
<p>但是如果操作区块 hash 的利益大于旷工挖到区块后的奖励，那么旷工完全就有动机进行恶意行为。更严重的是，在权益证明 (PoS) 系统中，由于生成一个区块几乎不需要计算时间或能量，矿工 (验证者) 可以很容易地继续生成数千个区块，直到获得一个他们喜欢的哈希值，并将这个哈希值进行提交。<br>
这也适用于验证者的选择。如果当前负责生产某个区块的验证者能够通过某种方式进行操纵，使得该区块哈希成为一个能够再次选中该验证者 (或者由该验证控制的另一个验证者客户端) 的种子，使该验证者继续成为提议区块的验证者，那么该验证者就可以一直提议区块，将其他的验证者挡在主要的利润之外！</p>
<h3 id="可验证随机函数-vrf" tabindex="-1"> 可验证随机函数 VRF</h3>
<p>Verifiable Random Function</p>
<blockquote>
<p>生成一对公私钥，分别为pri_key和pub_key<br>
计算hash_value=VRF_HASH(pri_key, message)<br>
计算proof_value=VRF_PROOF(pri_key, message)<br>
现在将hash_value和proof_value提供给验证者<br>
验证者拿到hash_value和proof_value计算hash_value=VRF_P2H(proof_value)<br>
如果成功，则验证者计算VRF_VERIFY(pub_key, message, proof)<br>
如果返回true则表示验证通过，否则验证失败</p>
</blockquote>
<p>就是在不暴露私钥的情况下，验证hash_value和message是否匹配</p>
<h4 id="案例分析" tabindex="-1"> 案例分析</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s/6v-PCIEpspfUX8sqS6mq6w" target="_blank" rel="noopener noreferrer">可信预言机Truora VRF</a></li>
</ul>
<ul>
<li><a href="https://mp.weixin.qq.com/s/5ZYKv0BBX1j18H6AAePZaQ" target="_blank" rel="noopener noreferrer">可信预言机Truora</a></li>
<li><a href="https://truora.readthedocs.io/" target="_blank" rel="noopener noreferrer">Truora</a></li>
<li><a href="https://github.com/WeBankBlockchain/Truora-Service" target="_blank" rel="noopener noreferrer">Truora Github</a></li>
</ul>
<h3 id="eth2-0-方案-randao-vdf" tabindex="-1"> ETH2.0 方案 RANDAO + VDF</h3>
<p><strong>RANDAO</strong> 是一个基于以太坊的项目，可以理解是一个智能合约，简单理解一下：当用户通过储存质押（m个ETH）成为验证者之，该用户将选择一个由自己选择的随机数。当需要为某个区块公布其随机数时，将系统中所有随机数加起来就可以得到一个全新的随机数。<br>
但即使在这种情况下，最后公布的数字对最终的随机数也会有一定程度的影响。房间里的最后一个人会记住之前每个人公布的数字，如此一来，就可以知道加上 (或者不加上) 他提供的数字之后的最终随机数的结果。<br>
这里只是快速了解<code>randao</code>项目，他其中还包含有经济惩罚等的各种措施保证，更具体的设计可以找白皮书。</p>
<p><strong>VDF</strong> (可验证延迟函数) Verifiable Delay Function<br>
它具有几个特性：</p>
<ul>
<li>串行性，抗矿池，任务不可分配。矿池将任务合理的分配给每个加入矿池的旷工，以达到并行计算的能力，大大提高解题速度。而VDF，如果要计算出第三级结果，那就必须先计算出第一级和第二级的结果，无法在多台计算机上并行地进行此计算，因为每个新的输入都依赖于之前的输出。</li>
<li>计算难度高，结果有延迟，预先确定的计算时间。每个输出都需要预先确定的计算时间。以太坊2.0阶段，这个 VDF 被定义为102分钟，通过引入这种延迟，并使计算的时间要长于验证者可以通过影响某个随机数而获得利益的时间，我们就可以消除最后一级的随机性偏差。</li>
<li>验证简单。VDF的运行过程可以是困难且耗时的，但是检验结果时是足够快的</li>
</ul>
<h3 id="其他随机数项目" tabindex="-1"> 其他随机数项目</h3>
<ul>
<li>Algorand</li>
</ul>
<ul>
<li>Cardano</li>
<li>Dfinity</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>区块链介绍</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/Block_chain_concept.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/Block_chain_concept.html</guid>
      <source url="https://bytecodes.tech/rss.xml">区块链介绍</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<p>区块链是由多个学科交叉组合形成的一门技术。
区块链是由分布式架构与分布式存储、块链式数据结构、点对点网络、共识算法、密码学算法、博弈论、智能合约等多种信息技术共同组成的整体解决方案。</p>
<p>区块链是<strong>最慢的分布式数据库</strong>？</p>
<blockquote>
<p>像比特币的TPS就是7（笔/秒），以太坊大概是10+。联盟链（FISCO BCOS）单链TPS目前是两万左右。</p>
</blockquote>
<p>分布式这么慢，它还有什么<strong>价值</strong>？</p>
<blockquote>
<p>它的价值就在于<strong>多方协作</strong>。</p>
</blockquote>
<p>区块链的灵魂与核心是什么？</p>
<blockquote>
<p><strong>共识</strong>。没有多方智能合约与共识算法来达成透明、高效、可信的合作，那它就只是个分布式数据库。那多方合作是为了什么？肯定是为了资产交易，数据分享。计算和数据共享基于智能合约透明的规则，大家共同执行，这就是区块链。</p>
</blockquote>
<h2 id="基础名词" tabindex="-1"> 基础名词</h2>
<h3 id="钱包" tabindex="-1"> 钱包</h3>
<p>钱包(Wallet)是一个管理私钥的工具</p>
<h4 id="冷钱包" tabindex="-1"> 冷钱包</h4>
<p>冷钱包(Cold Wallet)是一种脱离网络连接的离线钱包，将数字货币进行离线储存的钱包。使用者在一台离线的钱包上面生成数字货币地址和私钥，再将其保存起来。冷钱包是在不需要任何网络的情况下进行数字货币的储存，因此黑客是很难进入钱包获得私钥的，但它也不是绝对安全的，随机数不安全也会导致这个冷钱包不安全，此外硬件损坏、丢失也有可能造成数字货币的损失，因此需要做好密钥的备份。<br>
也成硬件钱包。可以简单理解成一个usb硬盘。</p>
<h4 id="热钱包" tabindex="-1"> 热钱包</h4>
<p>热钱包(Hot Wallet)是一种需要网络连接的在线钱包，在使用上更加方便。
但由于热钱包一般需要在线使用，个人的电子设备有可能因误点钓鱼网站被黑客盗取钱包文件、捕获钱包密码或是破解加密私钥，而部分中心化管理钱包也并非绝对安全。<br>
具有代表的交易所中心化钱包（甚至不需要你管理私钥）,被认为相对安全的开源产品Metamask</p>
<h3 id="节点" tabindex="-1"> 节点</h3>
<p>由于区块链是去中心化的分布式数据库，是由千千万万个“小服务器”组成。区块链网络中的每一个节点，就相当于存储所有区块数据的每一台电脑或者服务器。
所有新区块的生产，以及交易的验证与记帐，并将其广播给全网同步，都由节点来完成。<br>
节点分为“全节点”和“轻节点”，全节点就是拥有全网所有的交易数据的节点，那么轻节点就是只拥有和自己相关的交易数据节点（手机钱包APP）。由于每一个全节点都保留着全网数据，这意味着，其中一个节点出现问题，整个区块链网络世界也依旧能够安全运行，这也是去中心化的魅力所在。</p>
<h3 id="智能合约" tabindex="-1"> 智能合约</h3>
<p>智能合约本质可以说是一段运行在区块链网络中的代码，它以计算机指令的方式实现了传统合约的自动化处理，完成用户所赋予的业务逻辑<br>
早在 1995 年就由跨领域法律学者 Nick Szabo 提出：智能合约是一套以数字形式定义的承诺(Promises)，包括合约参与方可以在上面执行这些承诺的协议</p>
<h3 id="分叉" tabindex="-1"> 分叉</h3>
<p>分叉一般由区块链系统升级导致</p>
<h4 id="软分叉" tabindex="-1"> 软分叉</h4>
<p>软分叉(Soft-fork)更多情况下是一种协议升级，当新共识规则发布后，没有升级的旧节点并不会意识到代码已经发生改变，而继续生产不合法的区块，就会产生临时性分叉，但新节点可以兼容旧节点，即新旧节点始终在同一条链上工作。</p>
<h4 id="硬分叉" tabindex="-1"> 硬分叉</h4>
<p>硬分叉(Hard-fork)是区块链发生永久性分歧，在新共识规则发布后，已经升级的节点无法验证未升级节点产生的区块，未升级节点也无法验证已经升级的节点产生的区块，即新旧节点互不兼容，通常硬分叉就会发生，原有正常的一条链被分成了两条链（已升级的一条链和未升级的一条链，且这两条链互不兼容）。</p>
<h3 id="tps" tabindex="-1"> TPS</h3>
<blockquote>
<p>系统每秒钟能够处理的业务数量<br>
系统的吞吐量<br>
TPS = 并发数/平均响应时间</p>
</blockquote>
<blockquote>
<p>公链的TPS计算公式为：
TPS = 一个区块内包含的交易数量 / 区块产生时间 = 一个区块内包含的交易数量 / （共识算法运行的时间 + 广播并验证打包的时间 ）<br>
由此算式我们可知，要想提高TPS，有两种途径：<br>
1.对区块进行扩容，这样每个区块包含的交易数量就会提高；<br>
2.缩短区块产生的时间。</p>
</blockquote>
<ul>
<li>比特币: 7</li>
<li>以太坊: 10-20</li>
<li>EOS: 3000-4000 但宣称可以到100万</li>
</ul>
<blockquote>
<p>支付宝双十一 20W+</p>
</blockquote>
<h2 id="共识" tabindex="-1"> 共识</h2>
<p>区块链系统本身作为一个超大规模的分布式系统，但又与传统的分布式系统存在明显区别。由于它不依赖于任何一个中央权威，系统建立在去中心化的点对点网络基础之上，因此分散的节点需要就交易的有效与否达成一致，这就是共识算法发挥作用的地方，即确保所有节点都遵守协议规则并保证所有交易都以可靠的方式进行。由共识算法实现在分散的节点间对交易的处理顺序达成一致，这是共识算法在区块链系统中起到的最主要作用。</p>
<h3 id="共识算法" tabindex="-1"> 共识算法</h3>
<ul>
<li>PBFT(Practical Byzantine Fault Tolerance) 拜占庭容错技术
<blockquote>
<p>应用代表: 联盟链. fabric; fisco-bcos;</p>
</blockquote>
</li>
<li>POW(Proof of Work) 工作量证明
<blockquote>
<p>Bitcoin(比特币); Ethereum(以太访)</p>
</blockquote>
</li>
<li>POS(Proof of Stake) 股权证明
<blockquote>
<p>Peercoin(点点币); 日后以太坊逐渐替换使用</p>
</blockquote>
</li>
<li>DPOS(Delegated Proof of Stake) 委任权益证明
<blockquote>
<p>EOS; Bitshare(比特股)</p>
</blockquote>
</li>
<li>Paxos Raft</li>
<li>Ripple 瑞波</li>
</ul>
<h2 id="隐私保护" tabindex="-1"> 隐私保护</h2>
<p>数据脱敏，业务隔离,系统物理隔离等方式控制数据分发范围
或引入</p>
<h3 id="隐私保护算法" tabindex="-1"> 隐私保护算法</h3>
<ul>
<li>
<p>同态加密</p>
<blockquote>
<p>无需对加密数据进行提前解密就可以执行计算的方法。通过使用同态加密技术在区块链上存储数据可以达到一种完美的平衡，不会对区块链属性造成任何重大的改变。也就是说，区块链仍旧是公有区块链，但区块链上的数据将会被加密。</p>
</blockquote>
<blockquote>
<p>现在同态一般是用于加法计算，乘法计算的速度比较慢。另外，同态的数据量如果是比较大，那么其数据膨胀和运算速度降低就会非常明显</p>
</blockquote>
</li>
<li>
<p>零知识证明</p>
<blockquote>
<p>一种密码学技术，是一种在无需泄露数据本身情况下证明某些数据运算的一种零知识证明，允许两方（证明者和验证者）来证明某个提议是真实的，而且无需泄露除了它是真实的之外的任何信息。在密码学货币和区块链中，这通常是指交易信息数据。</p>
</blockquote>
<blockquote>
<p>重点在于证明一个事物的有效性，而不在于运算，但用户的账目、风控模型都涉及计算。</p>
</blockquote>
</li>
<li>
<p>群签名</p>
<blockquote>
<p>只有群中成员能够代表群体签名（群特性）；接收者可以用公钥验证群签名（验证简单性）；接收者不能知道由群体中哪个成员所签（无条件匿名保护）；发生争议时，群体中的成员或可信赖机构可以识别签名者（可追查性）。</p>
</blockquote>
</li>
<li>
<p>环签名</p>
<blockquote>
<p>环中一个成员利用他的私钥和其他成员的公钥进行签名，但却不需要征得其他成员的允许，而验证者只知道签名来自这个环，但不知到谁是真正的签名者。这个方式解决了对签名者完全匿名的问题，允许一个成员代表一组人进行签名而不泄漏签名者的信息。</p>
</blockquote>
<blockquote>
<p>群/环签名，它很轻也有不错的性能，但主要面向身份，不面向数据。</p>
</blockquote>
</li>
<li>
<p>盲签名</p>
<blockquote>
<p>盲签名因签名的人看不到所签署文件的具体内容而闻名，它有两个显著的特点：一是签名者对消息的内容是不可见的 ;二是签名被公开后，签名者不能追踪签名。</p>
</blockquote>
</li>
<li>
<p>门限签名</p>
<ul>
<li>基于 ECDSA 的门限签名方案</li>
<li>基于 BLS 的门限签名方案</li>
<li>基于 RSA 的 Shoup 门限签名方案</li>
<li>基于 Elgamal 的 Harn 门限签名方案</li>
</ul>
</li>
<li>
<p>混币原理</p>
</li>
<li>
<p>MPC</p>
<blockquote>
<p>Secure Multi-Party Computation Secure Multi-Party Computation</p>
</blockquote>
<blockquote>
<p>安全多方计算是可以用于联合计算，但现在它处在从两方向多方发展的阶段，多方安全解决起来比较困难，牵涉成本、计算量、复杂度。</p>
</blockquote>
</li>
<li>
<p>HMAC</p>
<blockquote>
<p>Hash-based Message Authentication Code 基于 Hash 的消息认证码</p>
</blockquote>
</li>
</ul>
<h2 id="区块链产品" tabindex="-1"> 区块链产品</h2>
<h3 id="ethereum-eth" tabindex="-1"> Ethereum (ETH)</h3>
<ul>
<li>EIP (Ethereum Improvement Protocol)</li>
</ul>
<blockquote>
<p>以太坊改进方案。用以改进方案中包括协议规范和合约标准</p>
</blockquote>
<ul>
<li>ERC (Ethereum Request for Comment)</li>
</ul>
<blockquote>
<p>Ethereum版的意见征求稿，用以记录以太坊上应用级的各种开发标准和协议(application-level standards and conventions)<br>
<a href="https://github.com/ethereum/EIPs" target="_blank" rel="noopener noreferrer">EIP</a>通过后就是ERC了</p>
</blockquote>
<ul>
<li>最典型的Token标准(<a href="https://eips.ethereum.org/EIPS/eip-20" target="_blank" rel="noopener noreferrer">ERC20</a>, <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md" target="_blank" rel="noopener noreferrer">ERC721</a>, <a href="https://github.com/ethereum/EIPs/issues/223" target="_blank" rel="noopener noreferrer">ERC223</a>)</li>
<li>名字注册(ERC26, ERC13)</li>
<li>URI范式(ERC67)</li>
<li>Library/Package格式(EIP82)</li>
<li>钱包格式(EIP75,EIP85)</li>
</ul>
<h2 id="攻击" tabindex="-1"> 攻击</h2>
<h3 id="恶意挖矿攻击" tabindex="-1"> 恶意挖矿攻击</h3>
<p>恶意挖矿攻击(Cryptojacking)是一种恶意行为，指未经授权的情况下劫持用户设备挖掘加密货币。通常，攻击者会劫持受害者设备(个人 PC 或服务器)的处理能力和带宽，由于加密货币挖掘需要大量算力，攻击者会尝试同时感染多个设备，这样他们能够收集到足够的算力来执行这种低风险和低成本的挖矿活动。</p>
<h3 id="无利益攻击" tabindex="-1"> 无利益攻击</h3>
<p>当PoS共识系统出现分叉(Fork)时，出块节点可以在“不受任何损失”的前提下，同时在两个分叉上出块；无论哪一个分叉后面被公认为主链，该节点都可以获得“所有收益”且不会有任何成本损失。这就很容易给某些节点一种动力去产生新的分叉，支持或发起不合法交易，其他逐利的出块节点会同时在多条链(窗口)上排队出块支持新的分叉。随着时间的推移，分叉越来越多，非法交易，作恶猖狂</p>
<h3 id="双花攻击" tabindex="-1"> 双花攻击</h3>
<p>双花攻击(Double Spend Attack)即一笔钱花了两次，双重支付，利用货币的数字特性两次或多次使用“同一笔钱”完成支付。双花不会产生新的 Token，但能把自己花出去的钱重新拿回来。简单说就是，攻击者将一笔 Token 转到另外一个地址，通常是转到交易所进行套现，然后再利用一些攻击手法对转账交易进行回滚。</p>
<h4 id="控制矿工费" tabindex="-1"> 控制矿工费</h4>
<p>Race Attack 这种攻击主要通过控制矿工费来实现双花。攻击者同时向网络中发送两笔交易，一笔交易发给自己(为了提高攻击成功的概率，他给这笔交易增加了足够的矿工费)，一笔交易发给商家。由于发送给自己的交易中含有较高的手续费，会被矿工优先打包进区块的概率比较高。这时候这笔交易就会先于发给商家的那笔交易，那么发给商家的交易就会被回滚。对于攻击者来说，通过控制矿工费，就实现了同一笔 Token 的“双花”。</p>
<h4 id="控制区块的广播时间" tabindex="-1"> 控制区块的广播时间</h4>
<p>Finney Attack  攻击者主要通过控制区块的广播时间来实现双花，攻击对象针对的是接受 0 确认的商家。假设攻击者挖到区块，该区块中包含着一个交易，即 A 向 B 转了一定数量的 Token，其中 A 和 B 都是攻击者的地址。但是攻击者并不广播这个区块，而是立即找到一个愿意接受 0 确认交易的商家向他购买一个物品，向商家发一笔交易，用 A 向商家的地址 C 支付，发给商家的交易广播出去后，攻击者再把自己之前挖到的区块广播出去，由于发给自己的交易先于发给商家的交易，对于攻击者来说，通过控制区块的广播时间，就实现了同一笔 Token 的“双花”。</p>
<h4 id="一次确认攻击" tabindex="-1"> 一次确认攻击</h4>
<p>Vector76 Attack 又称“一次确认攻击”，也就是交易确认一次后仍然可以回滚，是 Finney Attack 和 Race Attack 的组合。<br>
攻击者创建两个节点，节点 A 连接到商家节点，节点 B 连接到区块链网络中的其他节点。接着，攻击者用同一笔 Token 发起两笔交易，一笔交易发送给商家地址，我们称为交易 1；一笔交易发送给自己的钱包地址，我们称为交易 2。与上面说的 Race Attack 一样，攻击者对交易 2 添加了较高的矿工费从而提高了矿工的打包概率，此时，攻击者并没有把这两笔交易广播到网络中去。<br>
接着，攻击者开始在交易 1 所在的分支上进行挖矿，这条分支我们命名为分支 1。攻击者挖到区块后，并没有广播出去，而是同时做了两件事：在节点 A 上发送交易 1，在节点 B 上发送交易 2。<br>
由于节点 A 只连接了商家节点，所以当商家节点想把交易 1 传给其它对等节点时，连接了更多节点的节点 B，已经把交易 2 广播给了网络中的大部分节点。于是，从概率上来讲，交易 2 就更有可能被网络认定为是有效的，交易 1 被认定为无效。<br>
交易 2 被认为有效后，攻击者立即把自己之前在分支 1 上挖到的区块，广播到网络中。这时候，这个接受一次确认就支付的商家，会确认交易成功，然后攻击者就可以立即变现并转移资产。
同时，由于分支 2 连接的更多节点，所以矿工在这个分支上挖出了另一个区块，也就是分支 2 的链长大于分支 1 的链长。于是，分支 1 上的交易就会回滚，商家之前支付给攻击者的交易信息就会被清除，但是攻击者早已经取款，实现了双花。</p>
<h4 id="_51-攻击" tabindex="-1"> 51% 攻击</h4>
<p>攻击者占有超过全网 50% 的算力，在攻击者控制算力的这段时间，他可以创造一条高度大于原来链的新链。那么旧链中的交易会被回滚，攻击者可以使用同一笔 Token 发送一笔新的交易到新链上。</p>
<h3 id="异形攻击" tabindex="-1"> 异形攻击</h3>
<p>异形攻击(Alien Attack)实际上是一个所有公链都可能面临的问题，又称地址池污染，是指诱使同类链的节点互相侵入和污染的一种攻击手法，漏洞的主要原因是同类链系统在通信协议上没有对不同链的节点做识别。<br>
这种攻击在一些参考以太坊通信协议实现的公链上得到了复现：以太坊同类链，由于使用了兼容的握手协议，无法区分节点是否属于同个链，利用这一点，攻击者先对以太坊节点地址进行收集并进行恶意握手操作，通过跟节点握手达成污染地址池的目的，使得不同链的节点互相握手并把各自地址池里已知的节点推送给了对方，导致更多的节点互相污染，最终扩散致整个网络。遭受异形攻击的节点通常会通信性能下降，最终造成节点阻塞、主网异常等现象。相关公链需要注意持续保持主网健康状态监测，以免出现影响主网稳定的攻击事件出现。</p>
<h3 id="供应链攻击" tabindex="-1"> 供应链攻击</h3>
<p>供应链攻击(Supply Chain Attack)是一种非常可怕的攻击方式，防御上很难做到完美规避，由于现在的软件工程，各种包/模块的依赖十分频繁、常见，而开发者们很难做到一一检查，默认都过于信任市面上流通的包管理器，这就导致了供应链攻击几乎已经成为必选攻击之一。把这种攻击称成为供应链攻击，是为了形象说明这种攻击是一种依赖关系，一个链条，任意环节被感染都会导致链条之后的所有环节出问题。</p>
<h3 id="交易回滚攻击" tabindex="-1"> 交易回滚攻击</h3>
<p>交易回滚攻击(Roll Back Attack)，故名思义，指的是能对交易的状态进行回滚。回滚具体是什么意思呢？回滚具体指的是将已经发生的状态恢复成它未发生时候的样子。那么，交易回滚的意思就是将已经发生的交易变成未发生的状态。即攻击者本来已经发生了支付动作，但是通过某些手段，让转账流程发生错误，从而回滚整个交易流程，达到交易回滚的目的，这种攻击手法多发于区块链上的的智能合约游戏当中，当用户的下注动作和合约的开奖动作在一个交易内的时候，即内联交易。攻击者就可以通过交易发生时检测智能合约的某些状态，获知开奖信息，根据开奖信息选择是否对下注交易进行回滚。<br>
建议开发者们不要将用户的下注与开奖放在同一个交易内，防止攻击者通过检测智能合约中的开奖状态实现交易回滚攻击。</p>
<h3 id="交易排挤攻击" tabindex="-1"> 交易排挤攻击</h3>
<p>交易排挤攻击(Transaction Congestion Attack)是针对 EOS 上的使用 defer 进行开奖的游戏合约的一种攻击手法，攻击者可以通过某些手段，在游戏合约的 defer 开奖交易前发送大量的 defer 交易，恶意侵占区块内的 CPU 资源，使得智能合约内本应在指定区块内执行的 defer 开奖交易因资源不足无法执行，只能去到下一个区块才执行。由于很多 EOS 上的游戏智能合约使用区块信息作为智能合约本身的随机数，同一个 defer 开奖交易在不同区块内的执行结果是不一样的。通过这样的方式，攻击者在获知无法中奖的时候，就通过发送大量的 defer 交易，强行让智能合约重新开奖，从而达到攻击目的。<br>
建议智能合约开发者对在不同区块内执行结果不同的关键的操作不要采用 defer 交易的方式，降低合约被攻击的风险。</p>
<h3 id="随机数攻击" tabindex="-1"> 随机数攻击</h3>
<p>随机数攻击(Random Number Attack)，就是针对智能合约的随机数生成算法进行攻击，预测智能合约的随机数。目前区块链上很多游戏都是采用的链上信息（如区块时间，未来区块哈希等）作为游戏合约的随机数源，也称随机数种子。使用这种随机数种子生成的随机数被称为伪随机数。伪随机数不是真的随机数，存在被预测的可能。当使用可被预测的随机数种子生成随机数的时候，一旦随机数生成的算法被攻击者猜测到或通过逆向等其他方式拿到，攻击者就可以根据随机数的生成算法预测游戏即将出现的随机数，实现随机数预测，达到攻击目的。</p>
<h3 id="hard-fail状态攻击" tabindex="-1"> hard_fail状态攻击</h3>
<p>hard_fail是什么呢？简单来说就是出现错误但是没有使用错误处理器(error handler)处理错误，比方说使用onerror捕获处理，如果说没有onerror捕获，就会hard_fail。EOS 上的交易状态记录分为  executed,soft_fail, hard_fail, delayed 和 expired 这 5 种状态，通常在链上大部分人观察到的交易，都是 executed 的，或者 delayed 的，而没有失败的交易，这就导致大部分开发者误以为 EOS 链上没有失败的交易记录，从而忽略了对交易状态的检查。攻击者利用这个细节，针对链上游戏或交易所进行攻击，构造执行状态为hard_fail的交易，欺骗链上游戏或交易所进行假充值攻击，从而获利。<br>
在此提醒交易所和 EOS DApp游戏开发者在处理转账交易的时候需要严格校验交易状态，确保交易执行状态为 executed。</p>
<h3 id="重放攻击" tabindex="-1"> 重放攻击</h3>
<p>重放攻击(Replay Attack)，是针对区块链上的交易信息进行重放，一般来说，区块链为了保证不可篡改和防止双花攻击的发生，会对交易进行各种验证，包括交易的时间戳，nonce，交易 id 等，但是随着各种去中心化交易所的兴起，在智能合约中验证用户交易的场景越来越多。这种场景一般是需要用户对某一条消息进行签名后上传给智能合约，然后在合约内部进行验签。但由于用户的签名信息是会上链的，也就是说每个人都能拿到用户的签名信息，当在合约中校验用户签名的时候，如果被签名的消息不存在随着交易次数变化的变量，如时间戳，nonce 等，攻击者就可以拿着用户的签名，伪造用户发起交易，从而获利。<br>
这是一种最早出现于DApp生态初期的攻击形态，由于开发者设计的开奖随机算法存在严重缺陷，使得攻击者可利用合约漏洞重复开奖，属于开发者较为容易忽略的错误。因此，开发者们在链上进行验签操作的时候，需要对被签名消息加上各种可变因子，防止攻击者对链上签名进行重放，造成资产损失。</p>
<h3 id="重入攻击" tabindex="-1"> 重入攻击</h3>
<p>重入攻击(Reentrancy Attack)首次出现于以太坊，对应的真实攻击为 The DAO 攻击，此次攻击还导致了原来的以太坊分叉成以太经典(ETC)和现在的以太坊(ETH)。由于项目方采用的转账模型为先给用户发送转账然后才对用户的余额状态进行修改，导致恶意用户可以构造恶意合约，在接受转账的同时再次调用项目方的转账函数。利用这样的方法，导致用户的余额状态一直没有被改变，却能一直提取项目方资金，最终导致项目方资金被耗光。<br>
提醒智能合约开发者在进行智能合约开发时，在处理转账等关键操作的时候，如果智能合约中存储了用户的资金状态，要先对资金状态进行修改，然后再进行实际的资金转账，避免重入攻击。</p>
<h3 id="短地址攻击" tabindex="-1"> 短地址攻击</h3>
<p>短地址攻击(Short Address Attack)是针对以太坊上 ERC20 智能合约的一种攻击形式，利用的是 EVM 中的对于输入字节码的自动补全机制进行攻击。<br>
一般而言，针对 ERC20 合约中的 transfer 函数的调用，输入的字节码位数都是 136 字节的。当调用 ERC20 中的 transfer 函数进行 ERC20 Token 转账时，如果攻击者提供的地址后有一个或多个 0，那么攻击者就可以把地址后的零省去，提供一个缺位的地址。当对这个地址转账的时候，比方说转账 100 的 A Token，然后输入的地址是攻击者提供的缺位地址，这时候，经过编码输入的数据是 134 字节，比正常的数据少了 2 字节，在这种情况下，EVM 就会对缺失的字节位在编码数据的末尾进行补 0 凑成 136 字节，这样本来地址段缺失的 0 被数据段的 0 补齐了，而由于给地址段补 0，数据段会少 0，而数据段缺失的 0 由 EVM 自动补齐，这就像数据段向地址段移动补齐地址段缺失字节位，然后数据段缺失的字节位由 EVM 用 0 补齐。这种情况下，转账金额就会由 100 变成 100 * 16 的 n 次方，n 是地址缺失的 0 的个数。通过这种方式，攻击者就能对交易所或钱包进行攻击，盗窃交易所和钱包的资产。<br>
建议交易所和钱包在处理转账的时候，要对转账地址进行严格的校验，防止短地址攻击的发生。</p>
<h3 id="整型溢出攻击" tabindex="-1"> 整型溢出攻击</h3>
<p>数据的存储是区块链上重要的一环。但是每个数据类型本身是存在边界的，例如以太坊中 uint8 类型的变量就只能存储 0～255 大小的数据，超过了就存不下了。那么如果要放一个超过数据类型大小的数字会怎样呢？例如把 256 存进 uint8 的数据类型中，数据显示出来会变成 1，而不是其他数值，也不会报错，因为 uint8 本身能存一个 8 位二进制数字，最大值为 11111111，如果这个时候加 1，这个二进制数就变成了 100000001，而因为数据边界的关系，只能拿到后 8 位，也就是 00000001，那么数字的大小就变成 1 了，这种情况我们称为上溢。有上就有下，下溢的意思就是一个值为 0 的 uint8 数据，如果这个时候对它进行减 1 操作，结果会变成该数据类型所能存储的最大值加 1 减去被减数，在这个例子中是 255，也就是该数据类型所能存储的最大值。那么如果上述两种情况发生在智能合约当中的话，恶意用户通过下溢的操作，操纵自己的帐号向其他帐号发送超过自己余额数量的代币，如果合约内没有对余额进行检查，恶意用户的余额就会下溢出变成一个超大的值，这个时候攻击者如果大量抛售这些代币，就能瞬间破坏整个代币的价值系统。<br>
建议所有的智能合约开发者在智能合约中对数据进行操作的时候，要严格校验数据边界，防止整形溢出攻击的发生。</p>
<h3 id="条件竞争攻击" tabindex="-1"> 条件竞争攻击</h3>
<p>条件竞争(Race Condition)攻击的方式很多样，但是核心的本质无非是对某个条件的状态修改的竞争。条件竞争的例子：著名的 Edgeware 锁仓合约的拒绝服务漏洞，这个漏洞问题的本质在于对新建的锁仓合约的余额的这个条件进行竞争。攻击者可以监控所有链上的锁仓请求，提前计算出锁仓合约的地址，然后向合约地址转账，造成锁仓失败。在官方没有修复之前，要防止这种攻击，只能使用比攻击者更高的手续费让自己的锁仓交易先行打包，从而与攻击者形成竞争避免攻击。最后，官方修复方案为不对锁仓合约的余额进行强制性的相等检查，而是采用大于等于的形式，避免了攻击的发生。<br>
建议智能合约的开发者在智能合约中对某些状态进行修改的时候，要根据实际情况充分考虑条件竞争的风险，防止遭受条件竞争攻击。</p>
<h3 id="越权访问攻击" tabindex="-1"> 越权访问攻击</h3>
<p>和传统安全的定义一样，越权指的是访问或执行超出当前账户权限的操作，如本来有些操作只能是合约管理员执行的，但是由于限制做得不严谨，导致关键操作也能被合约管理员以外的人执行，导致不可预测的风险，这种攻击在以太坊和 EOS 上都曾出现过多次。<br>
以 EOS 上著名的BetDice游戏为例，由于在游戏合约内的路由(EOS 内可自定义的事件转发器)中没有对来源账号进行严格的校验，导致普通用户能通过 push action 的方式访问到合约中的关键操作 transfer 函数，直接绕过转账流程进行下注，从而发生了越权攻击，事后虽然BetDice官方紧急修复了代码，并严格限制了来源账号，但这个漏洞已经让攻击者几乎无成本薅走BetDice奖池内将近 5 万 EOS。又如在以太坊使用 solidity 版本为 0.4.x 进行合约开发的时候，很多合约开发者在对关键函数编写的时候不仅没有加上权限校验，也没有指定函数可见性，在这种情况下，函数的默认可见性为 public，恶意用户可以通过这些没有进行限制的关键函数对合约进行攻击。<br>
建议智能合约开发者们在进行合约开发的时候要注意对关键函数进行权限校验，防止关键函数被非法调用造成合约被攻击。</p>
<h3 id="交易顺序依赖攻击" tabindex="-1"> 交易顺序依赖攻击</h3>
<p>在区块链的世界当中，一笔交易内可能含有多个不同的交易，而这些交易执行的顺序会影响最终的交易的执行结果，由于在挖矿机制的区块链中，交易未被打包前都处于一种待打包的 pending 状态，如果能事先知道交易里面执行了哪些其他交易，恶意用户就能通过增加矿工费的形式，发起一笔交易，让交易中的其中一笔交易先行打包，扰乱交易顺序，造成非预期内的执行结果，达成攻击。以以太坊为例，假如存在一个 Token 交易平台，这个平台上的手续费是通过调控合约中的参数实现的，假如某天平台项目方通过一笔交易请求调高交易手续费用，这笔交易被打包后的所有买卖Token的交易手续费都要提升，正确的逻辑应该是从这笔交易开始往后所有的 Token 买卖交易的手续费都要提升，但是由于交易从发出到被打包存在一定的延时，请求修改交易手续费的交易不是立即生效的，那么这时恶意用户就可以以更高的手续费让自己的交易先行打包，避免支付更高的手续费。<br>
建议智能合约开发者在进行合约开发的时候要注意交易顺序对交易结果产生的影响，避免合约因交易顺序的不同遭受攻击。</p>
<h3 id="女巫攻击" tabindex="-1"> 女巫攻击</h3>
<p>传闻中女巫是一个会魔法的人，一个人可以幻化出多个自己，令受害人以为有多人，但其实只有一个人。在区块链世界中，女巫攻击(Sybil Attack)是针对服务器节点的攻击。攻击发生时候，通过某种方式，某个恶意节点可以伪装成多个节点，对被攻击节点发出链接请求，达到节点的最大链接请求，导致节点没办法接受其他节点的请求，造成节点拒绝服务攻击。<br>
建议在搭建全节点的情况下，服务器需要在系统层面上对网络连接情况进行监控，一旦发现某个IP连接异常就调用脚本配置 iptables 规则屏蔽异常的 IP，同时链开发者在进行公链开发时应该在 P2P 模块中对单 IP 节点连接数量添加控制。</p>
<h3 id="假错误通知攻击" tabindex="-1"> 假错误通知攻击</h3>
<p>EOS 上存在各种各样的通知，只要在 action 中添加require_recipient命令，就能对指定的帐号通知该 action，在 EOS 上某些智能合约中，为了用户体验或其他原因，一般会对onerror通知进行某些处理。如果这个时候没有对onerror通知的来源合约是否是eosio进行检验的话，就能使用和假转账通知同样的手法对合约进行攻击，触发合约中对onerror的处理，从而导致被攻击合约资产遭受损失。
建议智能合约开发者在进行智能合约开发的时候需要对onerror的来源合约进行校验，确保合约帐号为eosio帐号，防止假错误通知攻击。</p>
<h3 id="粉尘攻击" tabindex="-1"> 粉尘攻击</h3>
<p>粉尘攻击(Dusting Attack)最早发生于比特币网络当中，所谓粉尘，指的是交易中的交易金额相对于正常交易而言十分地小，可以视作微不足道的粉尘。通常这些粉尘在余额中不会被注意到，许多持币者也很容易忽略这些余额。但是由于比特币或基于比特币模型的区块链系统的账本模型是采用 UTXO 模型作为账户资金系统，即用户的每一笔交易金额，都是通过消费之前未消费的资金来产生新的资金。别有用意的用户，就能通过这种机制，给大量的账户发送这些粉尘金额，令交易粉尘化，然后再通过追踪这些粉尘交易，关联出该地址的其他关联地址，通过对这些关联地址进行行为分析，就可以分析一个地址背后的公司或个人，破坏比特币本身的匿名性。除此之外，由于比特币网络区块容量大小的限制，大量的粉尘交易会造成区块的拥堵，从而使得交易手续费提升，进而产生大量待打包交易，降低系统本身的运行效率。<br>
对于如何避免粉尘攻击，可以在构造交易的过程中，根据交易的类型，计算出交易的最低金额，同时对每个输出进行判断，如果低于该金额，则不能继续构造该笔交易。特别的，如果这个输出刚好发生在找零上，且金额对于你来说不太大，则可以通过舍弃该部分的粉尘输出，以充作交易手续费来避免构造出粉尘交易。其次，为了保护隐私性，建议可以在构造交易时把那些金额极小的 UTXO 舍弃掉，使用大额的 UTXO 组成交易。</p>
<h3 id="命令执行与控制-c2" tabindex="-1"> 命令执行与控制 C2</h3>
<p>C2 全称 Command and Control，翻译过来就是命令执行与控制，在传统的网络攻击中，在通过各种漏洞进入到目标服务器后，受限于空间，通常通过网络拉取二段 exploit 进行驻留，实现后渗透流程。所以，C2 架构也就可以理解为，恶意软件通过什么样的方式获取资源和命令，以及通过什么样的方式将数据回传给攻击者。在传统的攻击手法中，攻击者一般通过远程服务器拉取命令到本地执行，但是这种方式也有很明显的缺点，就是一旦远程服务器被发现，后续渗透活动就无法正常进行。但是区块链网络提供了一个天然且不可篡改的大型数据库，攻击者通过把攻击荷载(payload)写进交易中，并通过发送交易把该命令永久的刻在区块链数据库中。通过这种方法，即使攻击命令被发现，也无法篡改链上数据，无需担心服务器被发现然后下线的风险。
新技术不断发展，旧有的攻击手法也在随着新技术的变换而不断迭代更新。在区块链的世界中只有在各方面都做好防范，才能避免来自各方面的安全攻击。</p>
]]></content:encoded>
    </item>
    <item>
      <title>区块链与P2P网络</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/Chain_block_design.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/Chain_block_design.html</guid>
      <source url="https://bytecodes.tech/rss.xml">区块链与P2P网络</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识 P2P网络</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="p2p网络" tabindex="-1"> P2P网络</h2>
<p><strong>早期的P2P网络</strong>，P2P 网络需要解决的一个最重要的问题就是, 如何知道用户请求的资源位于哪个节点上. 在第一代 P2P 网络中, 人们设置了一台中央服务器来管理资源所处的位置. 当一个用户想要发布资源, 他需要告诉中央服务器它发布的资源信息和自己的节点信息; 当其他用户请求资源的时候, 需要先请求中央服务器以获取资源发布者的节点信息, 再向资源发布者请求资源.<br>
这种 P2P 网络的好处是效率高, 只需要请求一次中央服务器就可以发布或获取资源. 然而它的缺点也很明显: 中央服务器是这个网络系统最脆弱的地方, 它需要存储所有资源的信息, 处理所有节点的请求; 一旦中央服务器失效, 整个网络就无法使用.
另外一种 P2P 网络采取了不同的策略, 它不设置中央服务器; 当用户请求资源时, 它会请求它所有的邻接节点, 邻接节点再依次请求各自的邻接节点, 并使用一些策略防止重复请求, 直到找到拥有资源的节点. 也就是说, 这是一种泛洪搜索(Flooding Search).<br>
这种 P2P 网络去除了中央服务器, 它的稳定性就强多了. 然而它太慢了. 一次查找可能会产生大量的请求, 可能会有大量的节点卷入其中. 一旦整个系统中的的节点过多, 性能就会变得很差.</p>
<h3 id="分布式哈希表" tabindex="-1"> 分布式哈希表</h3>
<p>DHT（Distributed Hash Table）<br>
全网维护一个巨大的文件索引哈希表，这个哈希表的条目形如（key，value）。这里key通常是文件的哈希值，而value则是存储文件的IP地址。根据key就能找到存储到节点地址并返回给查询节点。这个表是按照一定规则分割存储到全网各个节点上。</p>
<ul>
<li>Kademlia</li>
<li>Chord</li>
</ul>
<h2 id="共识算法" tabindex="-1"> 共识算法</h2>
<ul>
<li>PBFT(Practical Byzantine Fault Tolerance) 拜占庭容错技术
<blockquote>
<p>应用代表: 联盟链. fabric; fisco-bcos;</p>
</blockquote>
</li>
<li>POW(Proof of Work) 工作量证明
<blockquote>
<p>Bitcoin(比特币); Ethereum(以太访)</p>
</blockquote>
</li>
<li>POS(Proof of Stake) 股权证明
<blockquote>
<p>Peercoin(点点币); 日后以太坊逐渐替换使用</p>
</blockquote>
</li>
<li>DPOS(Delegated Proof of Stake) 委任权益证明
<blockquote>
<p>EOS; Bitshare(比特股)</p>
</blockquote>
</li>
<li>Paxos Raft</li>
<li>Ripple 瑞波</li>
</ul>
<h3 id="pbft" tabindex="-1"> PBFT</h3>
<blockquote>
<p>f: 无效或恶意节点数<br>
R: 总节点数<br>
s: 正常节点数<br>
v: 系统的view编号，每次选举是触发 view change ,view number++</p>
</blockquote>
<p>前提 f &lt;= (R-1)/3  或  s &gt;= 2f+1 或 R = 3f + 1<br>
通俗讲就是可以容忍<strong>小于1/3的节点无效或恶意节点</strong></p>
<h4 id="leader-选举" tabindex="-1"> leader 选举</h4>
<div><pre><code>leader_idx = (block_number + current_view) % consensus_node_num
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>前三轮共识： node0、node1、node2为leader，且非恶意节点数目等于2<em>f+1，节点正常出块共识；<br>
第四轮共识：node3为leader，但node3为拜占庭节点，node0-node2在给定时间内未收到node3打包的区块，触发视图切换，试图切换到view_new=view+1的新视图，并相互间广播viewchange包，节点收集满在视图view_new上的(2</em>f+1)个viewchange包后，将自己的view切换为view_new，并计算出新leader；<br>
为第五轮共识：node0为leader，继续打包出块。</p>
</blockquote>
<p>采用PBFT共识算法的系统，节点规模在百级左右，再增加就会导致TPS下降，确认时延增加。目前业界有通过随机数算法选择记账组的共识机制，可以改善这个问题。</p>
<blockquote>
<p>RPBFT(rotating PBFT)就是其中的一个解决方案目的是将共识算法网络复杂度与共识节点规模解耦，提升区块链系统的可扩展性。在大节点规模下，随机选取部分节点作为“共识委员节点”参与每轮PBFT共识，由于共识委员节点数目固定、与节点规模无关，因此RPBFT共识算法可扩展性更强。<br>
epoch_sealer_num：每轮共识过程中参与共识的节点数目。<br>
epoch_block_num: 共识节点替换周期，为防止选取的共识节点联合作恶，RPBFT每出epoch_block_num个区块，会替换若干个共识委员节点。<br>
引入VRF可验证随机数算法来实现私密、随机、非交互式的共识委员节点选取方法。</p>
</blockquote>
<h4 id="角色" tabindex="-1"> 角色</h4>
<ul>
<li>replica 副本节点，备份节点,共识节点,所有参与的节点，接收并检查主节点的排序信息，如果主节点作恶可以进行换选。总数：R</li>
<li>primary 主节点，共识节点,负责将client的请求排序，发给所有的备份节点。负责将交易打包成区块和区块共识，每轮共识过程中有且仅有一个leader，为了防止leader伪造区块，每轮PBFT共识后，均会切换leader。</li>
<li>Observer 观察者节点，负责从共识节点或副本节点获取最新区块，执行并验证区块执行结果后，将产生的区块上链。</li>
</ul>
<blockquote>
<p>主节点选举：p = v 求余 R</p>
</blockquote>
<h4 id="共识流程" tabindex="-1"> 共识流程</h4>
<p>PBFT共识主要包括Pre-prepare、Prepare和Commit三个阶段。</p>
<p>PBFT共识算法中，共识节点轮流出块，每一轮共识仅有一个leader打包区块。节点计算当前leader索引与自己索引相同后，就开始</p>
<h5 id="打包区块-生成prepare" tabindex="-1"> 打包区块 生成Prepare</h5>
<blockquote>
<p><strong>产生新的空块</strong>: 通过区块链(BlockChain)获取当前最高块，并基于最高块产生新空块(将新区块父哈希置为最高块哈希，时间戳置为当前时间，交易清空)；<br>
<strong>从交易池打包交易</strong>: 产生新空块后，从交易池中获取交易，并将获取的交易插入到产生的新区块中；<br>
<strong>组装新区块</strong>: Sealer线程打包到交易后，将新区块的打包者(Sealer字段)置为自己索引，并根据打包的交易计算出所有交易的transactionRoot；<br>
<strong>产生Prepare包</strong>: 将组装的新区块编码到Prepare包内，广播给组内所有共识节点，其他共识节点收到Prepare包后，开始进行三阶段共识。</p>
</blockquote>
<h5 id="pre-prepare" tabindex="-1"> Pre-prepare</h5>
<p>共识节点收到Prepare包后，进入pre-prepare阶段，此阶段的主要工作流程包括：</p>
<blockquote>
<p><strong>Prepare包合法性判断</strong>：主要判断是否是重复的Prepare包、Prepare请求中包含的区块父哈希是否是当前节点最高块哈希(防止分叉)、Prepare请求中包含区块的块高是否等于最高块高加一；<br>
<strong>缓存合法的Prepare包</strong>: 若Prepare请求合法，则将其缓存到本地，用于过滤重复的Prepare请求；<br>
<strong>空块判断</strong>：若Prepare请求包含的区块中交易数目是0，则触发空块视图切换，将当前视图加一，并向所有其他节点广播视图切换请求；<br>
<strong>执行区块并缓存区块执行结果</strong>: 若Prepare请求包含的区块中交易数目大于0，则调用BlockVerifier区块执行器执行区块，并缓存执行后的区块；<br>
<strong>产生并广播签名包</strong>：基于执行后的区块哈希，产生并广播签名包，表明本节点已经完成区块执行和验证。</p>
</blockquote>
<h5 id="prepare" tabindex="-1"> Prepare</h5>
<p>共识节点收到签名包后，进入Prepare阶段，此阶段的主要工作流程包括：</p>
<blockquote>
<p><strong>签名包合法性判断</strong>：主要判断签名包的哈希与pre-prepare阶段缓存的执行后的区块哈希相同，若不相同，则继续判断该请求是否属于未来块签名请求(产生未来块的原因是本节点处理性能低于其他节点，还在进行上一轮共识，判断未来块的条件是：签名包的height字段大于本地最高块高加一)，若请求也非未来块，则是非法的签名请求，节点直接拒绝该签名请求；<br>
<strong>缓存合法的签名包</strong>：节点会缓存合法的签名包；
<strong>判断pre-prepare阶段缓存的区块对应的签名包缓存是否达到2*f+1，若收集满签名包，广播Commit包</strong>：若pre-prepare阶段缓存的区块哈希对应的签名包数目超过2<em>f+1，则说明大多数节点均执行了该区块，并且执行结果一致，说明本节点已经达到可以提交区块的状态，开始广播Commit包；<br>
<strong>若收集满签名包，备份pre-prepare阶段缓存的Prepare包落盘</strong>：为了防止Commit阶段区块未提交到数据库之前超过2</em>f+1个节点宕机，这些节点启动后重新出块，导致区块链分叉(剩余的节点最新区块与这些节点最高区块不同)，还需要备份pre-prepare阶段缓存的Prepare包到数据库，节点重启后，优先处理备份的Prepare包。</p>
</blockquote>
<h5 id="commit" tabindex="-1"> Commit</h5>
<p>共识节点收到Commit包后，进入Commit阶段，此阶段工作流程包括：</p>
<blockquote>
<p><strong>Commit包合法性判断</strong>：主要判断Commit包的哈希与pre-prepare阶段缓存的执行后的区块哈希相同，若不相同，则继续判断该请求是否属于未来块Commit请求(产生未来块的原因是本节点处理性能低于其他节点，还在进行上一轮共识，判断未来块的条件是：Commit的height字段大于本地最高块高加一)，若请求也非未来块，则是非法的Commit请求，节点直接拒绝该请求；<br>
<strong>缓存合法的Commit包</strong>：节点缓存合法的Commit包；<br>
<strong>判断pre-prepare阶段缓存的区块对应的Commit包缓存是否达到2*f+1，若收集满Commit包，则将新区块落盘</strong>：若pre-prepare阶段缓存的区块哈希对应的Commit请求数目超过2*f+1，则说明大多数节点达到了可提交该区块状态，且执行结果一致，则调用BlockChain模块将pre-prepare阶段缓存的区块写入数据库；</p>
</blockquote>
<h5 id="viewchange" tabindex="-1"> ViewChange</h5>
<p>当PBFT三阶段共识超时或节点收到空块时，PBFTe会试图切换到更高的视图(将要切换到的视图toView加一)，并触发ViewChange处理流程；节点收到ViewChange包时，也会触发ViewChange处理流程：</p>
<blockquote>
<p><strong>判断ViewChange包是否有效</strong>: 有效的ViewChange请求中带有的块高值必须不小于当前节点最高块高，视图必须大于当前节点视图；<br>
<strong>缓存有效ViewChange包</strong>： 防止相同的ViewChange请求被处理多次，也作为判断节点是否可以切换视图的统计依据；<br>
<strong>收集ViewChange包</strong>：若收到的ViewChange包中附带的view等于本节点的即将切换到的视图toView且本节点收集满2*f+1来自不同节点view等于toView的ViewChange包，则说明超过三分之二的节点要切换到toView视图，切换当前视图到toView。</p>
</blockquote>
<h2 id="轻节点" tabindex="-1"> 轻节点</h2>
<h3 id="默克尔树-merkle-tree" tabindex="-1"> 默克尔树 Merkle tree</h3>
<blockquote>
<p>在比特币的白皮书中提到了轻节点也就是简易支付验证(Simplified Payment Verification,SPV)，它正是基于默克尔可信树利用区块中的所有交易 hash 生成的一个默克尔根节点，保存至区块头，可用于验证交易是否打包到某区块中。</p>
</blockquote>
<p><img src="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/bc-merkle-tree.png" alt="image"></p>
<p>每个块都会有一个Merkle树,它从叶子节点(树的底部)开始,一个叶子节点就是一个交易哈希,叶子节点的数量必须是双数(如果区块里交易数是单数，就复制最后一份凑成双数)。从下往上,两两成对,连接两个节点哈希,将组合哈希作为新的哈希。新的哈希就成为新的树节点。重复该过程,直到仅有一个节点,也就是树根。根哈希然后就会当做是整个块交易的唯一标示,将它保存到区块头,然后用于工作量证明。</p>
<p><img src="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/merkle_tree_bitcoin.png" alt="img">
左：仅提供默克尔树（Merkle tree）上的少量节点已经足够给出分支的合法证明。<br>
右：任何对于默克尔树的任何部分进行改变的尝试都会最终导致链上某处的不一致。</p>
<p>Merkle树的好处就是一个节点可以在不下载整个块的情况下,验证是否包含某笔交易。并且这些只需要一个交易哈希,一个Merkle树根哈希和一个Merkle路径</p>
<h3 id="mpt-merkle-patricia-tree" tabindex="-1"> MPT(Merkle Patricia Tree)</h3>
<p>梅克尔帕特里夏树 = 默克尔树 + 压缩前缀树（Patricia trie）
<img src="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/MPT.png" alt="img"></p>
<p>我们将如下数据插入MPT中</p>
<table>
<thead>
<tr>
<th>key</th>
<th>values</th>
</tr>
</thead>
<tbody>
<tr>
<td>a711355</td>
<td>45.0 ETH</td>
</tr>
<tr>
<td>a77d337</td>
<td>1.00 WEI</td>
</tr>
<tr>
<td>a7f9365</td>
<td>1.1  ETH</td>
</tr>
<tr>
<td>a77d397</td>
<td>0.12 ETH</td>
</tr>
</tbody>
</table>
<p>插入第一个&lt;a711355, 45&gt;，由于只有一个key,直接用leaf node既可表示</p>
<p>接着插入a77d337,由于和a711355共享前缀’a7’,因而可以创建’a7’扩展节点。</p>
<p>接着插入a7f9365,也是共享’a7’,只需新增一个leaf node.</p>
<p>最后插入a77d397,这个key和a77d337共享’a7’+’d3’,因而再需要创建一个’d3’扩展节点</p>
<p>将叶子节点和最后的short node合并到一个节点了，事实上源码实现需要再深一层，最后一层的叶子节点只有数据</p>
<h2 id="加密算法" tabindex="-1"> 加密算法</h2>
<ul>
<li>
<p>大数分解困难问题：对应RSA系列算法等。</p>
</li>
<li>
<p>离散对数困难问题：对应Diffie-Hellman密钥交换协议、ElGamal加密、DSA算法等。</p>
</li>
<li>
<p>椭圆曲线上的离散对数困难问题：对应ECDSA、EdDSA、国密SM2等。</p>
</li>
</ul>
<p>密钥长度，美国国家标准与技术研究院NIST作如下推荐。
基于各大类的公钥加密算法，单位（比特、位）</p>
<table>
<thead>
<tr>
<th>安全参数等级</th>
<th>大数分解</th>
<th>离散对数</th>
<th>椭圆曲线上的离散对数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1024</td>
<td>1024</td>
<td>160</td>
</tr>
<tr>
<td>2</td>
<td>2048</td>
<td>2048</td>
<td>224</td>
</tr>
<tr>
<td>3</td>
<td>3072</td>
<td>3072</td>
<td>256</td>
</tr>
<tr>
<td>4</td>
<td>7680</td>
<td>7680</td>
<td>384</td>
</tr>
<tr>
<td>5</td>
<td>15360</td>
<td>15360</td>
<td>512</td>
</tr>
</tbody>
</table>
<blockquote>
<ol>
<li>一个隐私保护技术方案，安全性取决于其使用的密码学算法实现中最低的安全参数等级。</li>
</ol>
</blockquote>
<ol start="2">
<li>在未指明安全参数的前提下，进行密码学算法的安全性比较没有实际意义。</li>
<li>如果安全参数值很小，一般表现为对应的密钥长度很短时，无论密码学算法设计多么精妙，实际效果可能都是不安全的。</li>
<li>由于困难问题选用上的差异，密码学算法的理论强度没有最强，只有在满足特定安全假设下的够强，强行比较基于不同困难问题的密码学算法是否有效通常没有实际意义。</li>
</ol>
<blockquote>
<p>计算困难问题归根结底还是一个计算问题，随着计算机计算能力的增强，或是算法理论研究进展的推进，这些困难问题的安全性可能就会发生变化。<br>
比如RSA加密算法，NIST密钥管理准则认为，2010年后，1024位的密钥不再安全，需要增加到2048位的密钥长度，预计其安全有效性可以保持至2030年。<br>
对于企业而言，这里的启示在于，不能简单地认为，隐私保护技术方案现在有效，就保证了10年后依旧有效。</p>
</blockquote>
<h2 id="跨链" tabindex="-1"> 跨链</h2>
<ul>
<li>公证人机制</li>
<li>侧链/中继</li>
<li>哈希锁定</li>
</ul>
<blockquote>
<p><a href="https://github.com/WeBankFinTech/WeCross" target="_blank" rel="noopener noreferrer">WeCross</a></p>
</blockquote>
<h3 id="跨链应用场景" tabindex="-1"> 跨链应用场景</h3>
<ul>
<li>资产交换</li>
<li>原子交易</li>
<li>预言机</li>
<li>信息互通</li>
</ul>
]]></content:encoded>
      <enclosure url="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/bc-merkle-tree.png" type="image/png"/>
    </item>
    <item>
      <title>Solidity基础知识</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/Intelligent_contract_solidity.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/Intelligent_contract_solidity.html</guid>
      <source url="https://bytecodes.tech/rss.xml">Solidity基础知识</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识 P2P网络 Solidity</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<p><a href="https://solidity.readthedocs.io/" target="_blank" rel="noopener noreferrer">Solidity</a> 是一门面向合约的、为实现智能合约而创建的高级编程语言，运作在以太坊虚拟机（EVM）上。</p>
<p><a href="https://solidity.readthedocs.io/" target="_blank" rel="noopener noreferrer">官方文档</a><br>
<a href="https://learnblockchain.cn/docs/solidity/" target="_blank" rel="noopener noreferrer">非官方中文文档</a><br>
<a href="https://github.com/OpenZeppelin/openzeppelin-contracts" target="_blank" rel="noopener noreferrer">Openzeppelin合约类库</a></p>
<blockquote>
<p>以太坊虚拟机（EVM）是一个 “The World Machine” 所以请原谅它简陋的语法特性、令人抓狂的debug体验、近乎贫瘠的类库支持、动不动就需要插入汇编语句来解决一下问题。Solidity 语言在这种环境下必须严格遵循的设计原则以及权衡后必须付出的代价。</p>
</blockquote>
<h2 id="abi" tabindex="-1"> ABI</h2>
<p>Application Binary Interface(ABI)</p>
<h2 id="存储" tabindex="-1"> 存储</h2>
<p><strong>栈</strong> 用于存储字节码指令的操作数。在Solidity中，局部变量若是整型、定长字节数组等类型，就会随着指令的运行入栈、出栈。对于这类变量，无法强行改变它们的存储方式，如果在它们之前放置memory修饰符，编译会报错。<br>
<strong>内存</strong> 类似java中的堆，它用于储存&quot;对象&quot;。在Solidity编程中，如果一个局部变量属于变长字节数组、字符串、结构体等类型，其通常会被memory修饰符修饰，以表明存储在内存中。<br>
<strong>状态存储</strong> 用于存储合约的状态字段。从实现而言，不同的链可能采用不同实现，比较经典的是以太坊所采用的MPT树。由于MPT树性能、扩展性等问题，FISCO BCOS放弃了这一结构，而采用了分布式存储，通过rocksdb或mysql来存储状态数据，使存储的性能、可扩展性得到提高。</p>
<div><pre><code>contract Demo<span>{</span>
    <span>//状态存储</span>
    uint <span>private</span> _state<span>;</span>

    <span>function</span> <span>set</span><span>(</span><span>uint state</span><span>)</span> <span>public</span> <span>{</span>
        <span>//栈存储</span>
        uint i <span>=</span> <span>0</span><span>;</span>
        <span>//内存存储</span>
        string memory str <span>=</span> <span>"aaa"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="event-log" tabindex="-1"> Event/Log</h2>
<div><pre><code>
pragma solidity <span>>=</span><span>0.4</span><span>.21</span> <span>&lt;</span><span>0.7</span><span>.0</span><span>;</span>
contract Demo <span>{</span>
  <span>// 定义事件</span>
  event <span>Transfer</span><span>(</span>address indexed from<span>,</span> address indexed to<span>,</span> uint256 value<span>)</span><span>;</span>

  <span>function</span> <span>bid</span><span>(</span><span>)</span> <span>public</span> payable <span>{</span>
    <span>//触发事件</span>
    emit <span>Transfer</span><span>(</span>msg<span>.</span>sender<span>,</span> _to<span>,</span> _value<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>最多三个参数可以使用 <code>indexed</code> 属性</p>
<ul>
<li>这些参数会使用 <code>keccak-256</code> 哈希后得到值被作为 <code>topic</code> 保存在区块的 Event 里</li>
<li>API调用时可以使用这些 <code>indexed</code> 参数的特定值来进行过滤</li>
</ul>
<div><pre><code><span>var</span> event <span>=</span> demoContract<span>.</span><span>Transfer</span><span>(</span><span>{</span><span>from</span><span>:</span> <span>[</span><span>"xxxx"</span><span>,</span><span>"xxxx"</span><span>,</span><span>"xxxxx"</span><span>]</span><span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>高效使用：</p>
<ul>
<li>异步获取执行结果，并可提供过滤器，支持参数的检索和过滤。</li>
<li>提供一种回调机制，在事件执行成功后，由节点向注册监听的SDK发送回调通知，触发回调函数被执行。Oracle 的原理</li>
<li>存储合约数据，巧用日志去存储数据，可以大大减少交易费用
<blockquote>
<p>storage存储的大概价格为：每32字节需要消耗20000Gas，而日志存储价格大概为每字节8Gas</p>
</blockquote>
</li>
</ul>
<h2 id="修饰符" tabindex="-1"> 修饰符</h2>
<p><strong>修饰函数</strong></p>
<ul>
<li><code>pure</code> - 不允许修改和访问状态</li>
<li><code>view</code> - 不允许修改状态</li>
<li><code>payable</code> - 允许调用接收 以太币</li>
</ul>
<p><strong>修饰函数和变量</strong></p>
<ul>
<li>
<p><code>constant</code></p>
<p>函数：与<code>view</code>等价。<br>
变量：不允许赋值（初始化除外），它不会占据 <code>storage slot</code></p>
</li>
<li>
<p><code>external</code> - 可以从其他合约和交易中调用，不可内部调用，在接收大量数据时更为高效。</p>
<p>当函数的某个参数非常大时，如果显式地将函数标记为external，可以强制将函数存储的位置设置为 <code>calldata</code>，这会节约函数执行时所需存储或计算资源。</p>
</li>
<li>
<p><code>public</code> - 可以在内部或通过消息调用。没指定默认为 public</p>
<p>变量：会自动生成一个 <code>getter</code> 函数</p>
</li>
<li>
<p><code>internal</code> - 只能是内部访问</p>
<p>变量：状态变量的修饰符默认是<code>internal</code></p>
</li>
<li>
<p><code>private</code> - 仅在当前定义它们的合约中使用，并且不能被派生合约使用</p>
</li>
</ul>
<p><strong>修饰事件参数</strong></p>
<ul>
<li><code>indexed</code> - 可作为索引</li>
<li><code>anonymous</code> - 事件签名的哈希值不会在 <code>topic</code> 中存储</li>
</ul>
<p><strong>修饰器</strong></p>
<ul>
<li>
<p><code>modifier</code> - <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#modifier" target="_blank" rel="noopener noreferrer">修饰器</a></p>
<p>有点面向切面编程的感觉。</p>
</li>
</ul>
<div><pre><code>event <span>LogStartMethod</span><span>(</span><span>)</span><span>;</span>
event <span>LogEndMethod</span><span>(</span><span>)</span><span>;</span>
modifier logMethod <span>{</span>
    emit <span>LogStartMethod</span><span>(</span><span>)</span><span>;</span>
    _<span>;</span><span>//表示所修饰函数中的代码,也就是在函数的最前与最后插入代码</span>
    emit <span>LogEndMethod</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>function</span> <span>doing</span><span>(</span><span>address _owner</span><span>)</span> <span>public</span> logMethod <span>{</span>
    <span>// something...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="抽象类与接口" tabindex="-1"> 抽象类与接口</h2>
<p><a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#index-17" target="_blank" rel="noopener noreferrer">docs</a> 与其他语言类似。但需要注意合适地使用接口或抽象合约有助于增强合约设计的可扩展性。但是，由于区块链EVM上计算和存储资源的限制，切忌过度设计，这也是从高级语言技术栈转到Solidity开发的老司机常常会陷入的天坑。</p>
<h2 id="常见问题" tabindex="-1"> 常见问题</h2>
<ul>
<li>一个合约中，入参、返回值、内部变量不能超过了16个</li>
</ul>
<div><pre><code>Compiler error<span>:</span> Stack too deep<span>,</span> <span>try</span> removing local variables<span>.</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>EVM所设计用于最大的栈深度为16。所有的计算都在一个栈内执行，对栈的访问只限于其顶端，限制方式为：允许拷贝最顶端16个元素中的一个到栈顶，或者将栈顶元素和下面16个元素中的一个交换。所有其他操作都只能取最顶的几个元素，运算后，把结果压入栈顶。当然可以把栈上的元素放到存储或内存中。但无法只访问栈上指定深度的那个元素，除非先从栈顶移除其他元素。</p>
<p><strong>建议</strong> 使用结构体或数组来封装入参或返回值，达到减少栈顶元素使用的目的，从而避免此错误。对于智能合约也应该<a href="/blockchain/basic-logic/Smart_contracts_design_pattern.html">避免过多的设计</a>。需要分布式协作的重要数据才上链，非必需数据不上链；链上验证，链下授权。</p>
]]></content:encoded>
    </item>
    <item>
      <title>区块链之联盟链知识</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/League_chain.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/League_chain.html</guid>
      <source url="https://bytecodes.tech/rss.xml">区块链之联盟链知识</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识 P2P网络 Solidity 联盟链</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<hr>
<ul>
<li>
<p>BSN 区块链服务网络（Blockchain-based Service Network）</p>
<blockquote>
<p>是一个跨云服务、跨门户、跨底层框架，用于部署和运行区块链应用的全球性公共基础设施网络，由国家信息中心、中国移动通信集团公司、中国银联股份有限公司、北京红枣科技有限公司共同发起
<a href="http://kb.bsnbase.com/webdoc/view/Pub4028813e711a7c39017185cacb7b5640.html" target="_blank" rel="noopener noreferrer">BSN培训</a></p>
</blockquote>
</li>
<li>
<p>Hyperledger Fabric (有国密版Fabric)</p>
</li>
<li>
<p>FISCO BCOS （支持国密）</p>
</li>
<li>
<p><a href="https://github.com/citahub/cita" target="_blank" rel="noopener noreferrer">CITA</a></p>
</li>
<li>
<p>梧桐链</p>
</li>
<li>
<p>Brochain</p>
</li>
<li>
<p><a href="https://github.com/xuperchain/xuperchain" target="_blank" rel="noopener noreferrer">XuperChain</a></p>
</li>
</ul>
<h2 id="fisco-bcos" tabindex="-1"> <a href="https://github.com/FISCO-BCOS/FISCO-BCOS" target="_blank" rel="noopener noreferrer">FISCO BCOS</a></h2>
<ul>
<li>
<p>保障信息保密性、认证性、完整性、不可抵赖性，需采用CA的准入机制，并支持任意多级的证书结构。<br>
默认采用三级的证书结构，自上而下分别为链证书、机构证书、节点证书。</p>
<ul>
<li>
<p>链证书: 联盟链拥有唯一的链证书</p>
<blockquote>
<p>证书<code>ca.crt</code> , 私钥<code>ca.key</code> , 签发证书的序列号记录文件<code>ca.srl</code></p>
</blockquote>
</li>
<li>
<p>机构证书：</p>
<blockquote>
<p>机构证书<code>agency.crt</code> , 机构私钥<code>agency.key</code> , <code>agency.srl</code></p>
</blockquote>
</li>
<li>
<p>节点证书：由机构自己生产，每个机构都可以拥有多个节点</p>
</li>
</ul>
</li>
<li>
<p>引入多群组架构，支持区块链节点启动多个群组，群组间交易处理、数据存储、区块共识相互隔离，保障区块链系统隐私性的同时，降低了系统的运维复杂度</p>
<blockquote>
<p>机构A、B、C所有节点构成一个区块链网络，运行业务1；一段时间后，机构A、B启动业务2，且不希望该业务相关数据、交易处理被机构C感知，有何解？</p>
</blockquote>
<p>一般理解群组个数可以达到整数上限，但由于硬件的限制，应采用这种极端的设计，机构可以为不同的业务使用不同的节点去加了对应群组来解决多业务问题。</p>
<blockquote>
<p>100个群组都落在一个节点上可能需要。64核，128g内存，百兆外网带宽，4T硬盘以上。这是基本的。如果业务有上量还得加</p>
</blockquote>
</li>
</ul>
<h3 id="节点准入机制" tabindex="-1"> 节点准入机制</h3>
<p>CA黑白名单</p>
<ul>
<li>群组节点：共识节点，观察节点</li>
<li>游离节点：完成网络准入但没有加入群组的节点，不参与共识和同步</li>
</ul>
<h4 id="网络准入机制" tabindex="-1"> 网络准入机制</h4>
<h4 id="群组准入机制" tabindex="-1"> 群组准入机制</h4>
<p><strong>交易流程</strong></p>
<ul>
<li>用户通过操作SDK或直接编写curl命令向所连接的节点发起交易。</li>
<li>节点收到交易后，若当前交易池未满则将交易附加至TxPool中并向自己所连的节点广播该交易；否则丢弃交易并输出告警。</li>
<li>Sealer(打包器)会不断从交易池中取出交易，并立即将收集到的交易打包为区块并发送至共识引擎。</li>
<li>共识引擎调用BlockVerifier对区块进行验证并在网络中进行共识，BlockVerifier调用Executor执行区块中的每笔交易。当区块验证无误且网络中节点达成一致后，共识引擎将区块发送至BlockChain。</li>
<li>BlockChain收到区块，对区块信息（如块高等）进行检查，并将区块数据与表数据写入底层存储中，完成区块上链。</li>
</ul>
<p><strong>交易同步</strong></p>
<ul>
<li>一笔交易通过channel或RPC发送到某节点上</li>
<li>收到交易的节点全量广播此交易给其它节点</li>
<li>其它节点收到交易后，为了保险起见，选择25%的节点再广播一次</li>
<li>节点收到广播过的交易，不会再次广播</li>
</ul>
<h3 id="国密算法" tabindex="-1"> 国密算法</h3>
<table>
<thead>
<tr>
<th></th>
<th>标准版FISCO BCOS</th>
<th>国密版FISCO BCOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>SSL链接</td>
<td>Openssl TLSv1.2协议</td>
<td>国密TLSv1.1协议</td>
</tr>
<tr>
<td>签名验证</td>
<td>ECDSA签名算法</td>
<td>SM2签名算法</td>
</tr>
<tr>
<td>消息摘要算法</td>
<td>SHA-256 SHA-3</td>
<td>SM3消息摘要算法</td>
</tr>
<tr>
<td>落盘加密算法</td>
<td>AES-256加密算法</td>
<td>SM4加密算法</td>
</tr>
<tr>
<td>证书模式</td>
<td>OpenSSL证书模式</td>
<td>国密双证书模式</td>
</tr>
<tr>
<td>合约编译器</td>
<td>以太坊solidity编译器</td>
<td>国密solidity编译器</td>
</tr>
</tbody>
</table>
<p><a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/design/features/guomi.html" target="_blank" rel="noopener noreferrer">详细</a></p>
<h3 id="webase" tabindex="-1"> <a href="https://github.com/WeBankFinTech/WeBASE" target="_blank" rel="noopener noreferrer">WeBASE</a></h3>
<h3 id="weidentity" tabindex="-1"> <a href="https://github.com/WeBankFinTech/WeIdentity" target="_blank" rel="noopener noreferrer">WeIdentity</a></h3>
<h3 id="wedpr" tabindex="-1"> <a href="https://github.com/WeBankBlockchain/WeDPR-Lab-Core" target="_blank" rel="noopener noreferrer">WeDPR</a></h3>
]]></content:encoded>
    </item>
    <item>
      <title>基础知识</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/</guid>
      <source url="https://bytecodes.tech/rss.xml">基础知识</source>
      <category>区块链学习</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
    </item>
    <item>
      <title>区块链之设计模式</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/Smart_contracts_design_pattern.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/Smart_contracts_design_pattern.html</guid>
      <source url="https://bytecodes.tech/rss.xml">区块链之设计模式</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识 P2P网络 Solidity 设计模式</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="设计模式" tabindex="-1"> 设计模式</h2>
<p>《Design Patterns For Smart Contracts In the Ethereum Ecosystem》</p>
<h3 id="安全-security" tabindex="-1"> 安全 Security</h3>
<ul>
<li>
<p>Checks-Effects-Interaction 保证状态完整，再做外部调用</p>
<p>Checks：参数验证，Effects：修改合约状态，Interaction：外部交互
这个模式要求合约按照Checks-Effects-Interaction的顺序来组织代码。它的好处在于进行外部调用之前，Checks-Effects已完成合约自身状态所有相关工作，使得状态完整、逻辑自洽，这样外部调用就无法利用不完整的状态进行攻击</p>
</li>
<li>
<p>Mutex - 禁止递归</p>
<p>使用修饰符防止函数被递归调用。防止重放攻击</p>
<div><pre><code>contract Mutex <span>{</span>
  bool locked<span>;</span>
  modifier <span>noReentrancy</span><span>(</span><span>)</span> <span>{</span>
      <span>//防止递归</span>
      <span>require</span><span>(</span><span>!</span>locked<span>,</span> <span>"Reentrancy detected"</span><span>)</span><span>;</span>
      locked <span>=</span> <span>true</span><span>;</span>
      _<span>;</span>
      locked <span>=</span> <span>false</span><span>;</span>
  <span>}</span>

  <span>//调用该函数将会抛出Reentrancy detected错误</span>
  <span>function</span> <span>some</span><span>(</span><span>)</span> <span>public</span> noReentrancy<span>{</span>
      <span>some</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ul>
<p>}</p>
<div><pre><code>
### 可维护性 Maintaince

高度模块化、高内聚低耦合

* Data segregation - 数据与逻辑相分离
```javascript
contract DataRepository{

  uint private _data;

  function setData(uint data) public {
      _data = data;
  }

  function getData() public view returns(uint){
      return _data;
  }
}
contract Computer{
  DataRepository private _dataRepository;
  constructor(address addr){
      _dataRepository = DataRepository(addr);
  }

  //业务代码
  function compute() public view returns(uint){
      return _dataRepository.getData() * 10;
  }    
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>Satellite - 分解合约功能</li>
</ul>
<div><pre><code>contract Base <span>{</span>
    uint <span>public</span> _variable<span>;</span>

    <span>function</span> <span>setVariable</span><span>(</span><span>uint data</span><span>)</span> <span>public</span> <span>{</span>
        _variable <span>=</span> _satellite<span>.</span><span>compute</span><span>(</span>data<span>)</span><span>;</span>
    <span>}</span>

     Satellite _satellite<span>;</span>
    <span>//更新子合约（卫星合约）</span>
    <span>function</span> <span>updateSatellite</span><span>(</span><span>address addr</span><span>)</span> <span>public</span> <span>{</span>
        _satellite <span>=</span> <span>Satellite</span><span>(</span>addr<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
contract Satellite <span>{</span>
    <span>function</span> <span>compute</span><span>(</span><span>uint a</span><span>)</span> <span>public</span> <span>returns</span><span>(</span><span>uint</span><span>)</span><span>{</span>
        <span>return</span> a <span>*</span> <span>10</span><span>;</span>        
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>Contract Registry - 跟踪最新合约</li>
</ul>
<div><pre><code>contract Registry<span>{</span>

    address _current<span>;</span>
    address<span>[</span><span>]</span> _previous<span>;</span>

    <span>//子合约升级了，就通过update函数更新地址</span>
    <span>function</span> <span>update</span><span>(</span><span>address newAddress</span><span>)</span> <span>public</span><span>{</span>
        <span>if</span><span>(</span>newAddress <span>!=</span> _current<span>)</span><span>{</span>
            _previous<span>.</span><span>push</span><span>(</span>_current<span>)</span><span>;</span>
            _current <span>=</span> newAddress<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>function</span> <span>getCurrent</span><span>(</span><span>)</span> <span>public</span> view <span>returns</span><span>(</span><span>address</span><span>)</span><span>{</span>
        <span>return</span> _current<span>;</span>
    <span>}</span>
<span>}</span>
contract Base <span>{</span>
    uint <span>public</span> _variable<span>;</span>

    <span>function</span> <span>setVariable</span><span>(</span><span>uint data</span><span>)</span> <span>public</span> <span>{</span>
        Satellite satellite <span>=</span> <span>Satellite</span><span>(</span>_registry<span>.</span><span>getCurrent</span><span>(</span><span>)</span><span>)</span><span>;</span>
        _variable <span>=</span> satellite<span>.</span><span>compute</span><span>(</span>data<span>)</span><span>;</span>
    <span>}</span>

    Registry <span>private</span> _registry <span>=</span> <span>//...;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>Contract Relay - 代理调用最新合约</li>
</ul>
<div><pre><code>contract Base <span>{</span>
    uint <span>public</span> _variable<span>;</span>

    <span>function</span> <span>setVariable</span><span>(</span><span>uint data</span><span>)</span> <span>public</span> <span>{</span>
        _variable <span>=</span> _proxy<span>.</span><span>compute</span><span>(</span>data<span>)</span><span>;</span>
    <span>}</span>
    SatelliteProxy <span>private</span> _proxy <span>=</span> <span>//...;</span>
<span>}</span>
contract SatelliteProxy<span>{</span>
    address _current<span>;</span>
    <span>function</span> <span>compute</span><span>(</span><span>uint a</span><span>)</span> <span>public</span> <span>returns</span><span>(</span><span>uint</span><span>)</span><span>{</span>
        Satellite satellite <span>=</span> <span>Satellite</span><span>(</span>_current<span>)</span><span>;</span>   
        <span>return</span> satellite<span>.</span><span>compute</span><span>(</span>a<span>)</span><span>;</span>
    <span>}</span>

    <span>//子合约升级了，就通过update函数更新地址</span>
    <span>function</span> <span>update</span><span>(</span><span>address newAddress</span><span>)</span> <span>public</span><span>{</span>
        <span>if</span><span>(</span>newAddress <span>!=</span> _current<span>)</span><span>{</span>
            _current <span>=</span> newAddress<span>;</span>
        <span>}</span>
    <span>}</span>   
<span>}</span>
contract Satellite <span>{</span>
    <span>function</span> <span>compute</span><span>(</span><span>uint a</span><span>)</span> <span>public</span> <span>returns</span><span>(</span><span>uint</span><span>)</span><span>{</span>
        <span>return</span> a <span>*</span> <span>10</span><span>;</span>        
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="生命周期-lifecycle" tabindex="-1"> 生命周期 Lifecycle</h3>
<ul>
<li>Mortal - 允许合约自毁</li>
</ul>
<div><pre><code>contract Mortal<span>{</span>
    <span>//自毁</span>
    <span>function</span> <span>destroy</span><span>(</span><span>)</span> <span>public</span><span>{</span>
        <span>//selfdestruct指令，用于销毁合约</span>
        <span>selfdestruct</span><span>(</span>msg<span>.</span>sender<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>
<p>Automatic Deprecation - 允许合约自动停止服务</p>
<p>当用户调用service，notExpired修饰符会先进行日期检测，这样，一旦过了特定时间，调用就会因过期而被拦截在notExpired层。</p>
</li>
</ul>
<div><pre><code>contract AutoDeprecated<span>{</span>

    uint <span>private</span> _deadline<span>;</span>

    <span>function</span> <span>setDeadline</span><span>(</span><span>uint time</span><span>)</span> <span>public</span> <span>{</span>
        _deadline <span>=</span> time<span>;</span>
    <span>}</span>

    modifier <span>notExpired</span><span>(</span><span>)</span><span>{</span>
        <span>require</span><span>(</span>now <span>&lt;=</span> _deadline<span>)</span><span>;</span>
        _<span>;</span>
    <span>}</span>

    <span>function</span> <span>service</span><span>(</span><span>)</span> <span>public</span> notExpired<span>{</span>
        <span>//some code    </span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="权限-authorization" tabindex="-1"> 权限 Authorization</h3>
<ul>
<li>Ownership</li>
</ul>
<div><pre><code>contract Ownable <span>{</span>
    address <span>public</span> owner<span>;</span>

    event <span>OwnershipRenounced</span><span>(</span>address indexed previousOwner<span>)</span><span>;</span>
    event <span>OwnershipTransferred</span><span>(</span>
        address indexed previousOwner<span>,</span>
        address indexed newOwner
    <span>)</span><span>;</span>

    <span>constructor</span><span>(</span><span>)</span> <span>public</span> <span>{</span>
        owner <span>=</span> msg<span>.</span>sender<span>;</span>
    <span>}</span>

    modifier <span>onlyOwner</span><span>(</span><span>)</span> <span>{</span>
        <span>require</span><span>(</span>msg<span>.</span>sender <span>==</span> owner<span>)</span><span>;</span>
        _<span>;</span><span>//表示所修饰函数中的代码,也就是将这个 require 在最前面执行</span>
    <span>}</span>

    <span>function</span> <span>transferOwnership</span><span>(</span><span>address newOwner</span><span>)</span> <span>public</span> onlyOwner <span>{</span>
        <span>require</span><span>(</span>newOwner <span>!=</span> <span>address</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>
        emit <span>OwnershipTransferred</span><span>(</span>owner<span>,</span> newOwner<span>)</span><span>;</span>
        owner <span>=</span> newOwner<span>;</span>
    <span>}</span>

    <span>function</span> <span>renounceOwnership</span><span>(</span><span>)</span> <span>public</span> onlyOwner <span>{</span>
        emit <span>OwnershipRenounced</span><span>(</span>owner<span>)</span><span>;</span>
        owner <span>=</span> <span>address</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>//继承并添加修饰器</span>
contract Biz is Owned<span>{</span>
    <span>function</span> <span>manage</span><span>(</span><span>)</span> <span>public</span> onlyOwner<span>{</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="行为控制-action-and-control" tabindex="-1"> 行为控制 Action And Control</h3>
<ul>
<li>Commit - Reveal - 延迟秘密泄露
Commit And Reveal模式允许用户将要保护的数据转换为不可识别数据，比如一串哈希值，直到某个时刻再揭示哈希值的含义，展露真正的原值。<br>
以投票场景举例，假设需要在所有参与者都完成投票后再揭示投票内容，以防这期间参与者受票数影响</li>
</ul>
<div><pre><code>contract CommitReveal <span>{</span>
    struct Commit <span>{</span>
        string choice<span>;</span>
        string secret<span>;</span>
        uint status<span>;</span>
    <span>}</span>
    <span>mapping</span><span>(</span><span>address</span> <span>=></span> <span>mapping</span><span>(</span><span>bytes32</span> <span>=></span> Commit<span>)</span><span>)</span> <span>public</span> userCommits<span>;</span>
    event <span>LogCommit</span><span>(</span>bytes32<span>,</span> address<span>)</span><span>;</span>
    event <span>LogReveal</span><span>(</span>bytes32<span>,</span> address<span>,</span> string<span>,</span> string<span>)</span><span>;</span>

    <span>function</span> <span>commit</span><span>(</span><span>bytes32 commit</span><span>)</span> <span>public</span> <span>{</span>
        Commit storage userCommit <span>=</span> userCommits<span>[</span>msg<span>.</span>sender<span>]</span><span>[</span>commit<span>]</span><span>;</span>
        <span>require</span><span>(</span>userCommit<span>.</span>status <span>==</span> <span>0</span><span>)</span><span>;</span>
        userCommit<span>.</span>status <span>=</span> <span>1</span><span>;</span> <span>// comitted</span>
        emit <span>LogCommit</span><span>(</span>commit<span>,</span> msg<span>.</span>sender<span>)</span><span>;</span>
    <span>}</span>

    <span>function</span> <span>reveal</span><span>(</span><span>string choice<span>,</span> string secret<span>,</span> bytes32 commit</span><span>)</span> <span>public</span> <span>{</span>
        Commit storage userCommit <span>=</span> userCommits<span>[</span>msg<span>.</span>sender<span>]</span><span>[</span>commit<span>]</span><span>;</span>
        <span>require</span><span>(</span>userCommit<span>.</span>status <span>==</span> <span>1</span><span>)</span><span>;</span>
        <span>require</span><span>(</span>commit <span>==</span> <span>keccak256</span><span>(</span>choice<span>,</span> secret<span>)</span><span>)</span><span>;</span>
        userCommit<span>.</span>choice <span>=</span> choice<span>;</span>
        userCommit<span>.</span>secret <span>=</span> secret<span>;</span>
        userCommit<span>.</span>status <span>=</span> <span>2</span><span>;</span>
        emit <span>LogReveal</span><span>(</span>commit<span>,</span> msg<span>.</span>sender<span>,</span> choice<span>,</span> secret<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>Oracle - 读取链外数据
获取外部数据会通过名为Oracle的链外数据层来执行。当业务方的合约尝试获取外部数据时，会先将查询请求存入到某个Oracle专用合约内；Oracle会监听该合约，读取到这个查询请求后，执行查询，并调用业务合约响应接口使合约获取结果。
<img src="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/contract-oracle.png" alt="oracle"></li>
</ul>
<div><pre><code>contract Oracle <span>{</span>
    address oracleSource <span>=</span> <span>0x123</span><span>;</span> <span>// known source</span>

    struct Request <span>{</span>
        bytes data<span>;</span>
        <span>function</span><span>(</span><span>bytes memory</span><span>)</span> external callback<span>;</span>
    <span>}</span>

    Request<span>[</span><span>]</span> requests<span>;</span>
    event <span>NewRequest</span><span>(</span>uint<span>)</span><span>;</span>
    modifier <span>onlyByOracle</span><span>(</span><span>)</span> <span>{</span>
        <span>require</span><span>(</span>msg<span>.</span>sender <span>==</span> oracleSource<span>)</span><span>;</span> _<span>;</span>
    <span>}</span>

    <span>function</span> <span>query</span><span>(</span><span>bytes data<span>,</span> <span>function</span><span>(</span><span>bytes memory</span><span>)</span> external callback</span><span>)</span> <span>public</span> <span>{</span>
        requests<span>.</span><span>push</span><span>(</span><span>Request</span><span>(</span>data<span>,</span> callback<span>)</span><span>)</span><span>;</span>
        emit <span>NewRequest</span><span>(</span>requests<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>//回调函数，由Oracle调用</span>
    <span>function</span> <span>reply</span><span>(</span><span>uint requestID<span>,</span> bytes response</span><span>)</span> <span>public</span> <span>onlyByOracle</span><span>(</span><span>)</span> <span>{</span>
        requests<span>[</span>requestID<span>]</span><span>.</span><span>callback</span><span>(</span>response<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
contract BizContract <span>{</span>
    Oracle _oracle<span>;</span>

    <span>constructor</span><span>(</span><span>address oracle</span><span>)</span><span>{</span>
        _oracle <span>=</span> <span>Oracle</span><span>(</span>oracle<span>)</span><span>;</span>
    <span>}</span>

    modifier <span>onlyByOracle</span><span>(</span><span>)</span> <span>{</span>
        <span>require</span><span>(</span>msg<span>.</span>sender <span>==</span> <span>address</span><span>(</span>_oracle<span>)</span><span>)</span><span>;</span>
        _<span>;</span>
    <span>}</span>

    <span>function</span> <span>updateExchangeRate</span><span>(</span><span>)</span> <span>{</span>
        _oracle<span>.</span><span>query</span><span>(</span><span>"USD"</span><span>,</span> <span>this</span><span>.</span>oracleResponse<span>)</span><span>;</span>
    <span>}</span>

    <span>//回调函数，用于读取响应</span>
    <span>function</span> <span>oracleResponse</span><span>(</span><span>bytes response</span><span>)</span> onlyByOracle <span>{</span>
    <span>// use the data</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="闪电网络" tabindex="-1"> 闪电网络</h2>
<h3 id="rsmc" tabindex="-1"> RSMC</h3>
<p>Revocable Sequence Maturity Contract（序列到期可撤销合约）</p>
<h3 id="htlc" tabindex="-1"> HTLC</h3>
<p>Hashed Timelock Contract（哈希时间锁定）</p>
]]></content:encoded>
      <enclosure url="https://abelsun-1256449468.cos.ap-beijing.myqcloud.com/image/contract-oracle.png" type="image/png"/>
    </item>
    <item>
      <title>比特币白皮书</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/The_white_paper_the_currency.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/The_white_paper_the_currency.html</guid>
      <source url="https://bytecodes.tech/rss.xml">比特币白皮书</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识 P2P网络 Solidity 比特币</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>比特币 white paper中英文对照版本，保持英文原版只字不差，排版尽量模拟原版</p>
</blockquote>
<p>Satoshi Nakamoto<br>
<a href="mailto:satoshin@gmx.com">satoshin@gmx.com</a><br>
<a href="http://www.bitcoin.org" target="_blank" rel="noopener noreferrer">www.bitcoin.org</a></p>
<blockquote>
<p><strong>Abstract.</strong>   A  purely   peer-to-peer   version   of   electronic   cash   would   allow   onlinepayments   to   be   sent   directly   from   one   party   to   another   without   going   through   afinancial institution.   Digital signatures provide part of the solution, but the mainbenefits are lost if a trusted third party is still required to prevent double-spending.We propose a solution to the double-spending problem using a peer-to-peer network.The   network   timestamps   transactions   by   hashing   them   into   an   ongoing   chain   ofhash-based proof-of-work, forming a record that cannot be changed without redoingthe proof-of-work.   The longest chain not only serves as proof of the sequence ofevents witnessed, but proof that it came from the largest pool of CPU power.   Aslong as a majority of CPU power is controlled by nodes that are not cooperating toattack the network,  they'll  generate the  longest  chain  and  outpace attackers.   Thenetwork itself requires minimal structure.   Messages are broadcast on a best effortbasis,   and   nodes   can   leave   and   rejoin   the   network   at   will,   accepting   the   longestproof-of-work chain as proof of what happened while they were gone.</p>
</blockquote>
<blockquote>
<p><strong>摘要。</strong> 一种完全的点对点电子现金应当允许在线支付从一方直接发送到另一方而不需要通过一个金融机构。数字签名提供了部分解决方案，但如果仍需一个可信任第三方来防止双重支付，那就失去了电子货币的主要优点。我们提出一种使用点对点网络解决双重支付问题的方案。该网络通过将交易哈希进一条持续增长的基于哈希的工作量证明链来给交易打上时间戳，形成一条除非重做工作量证明否则不能更改的记录。最长的链不仅是被见证事件序列的证据，而且也是它本身是由最大 CPU 算力池产生的证据。只要多数的 CPU 算力被不打算联合攻击网络的节点控制，这些节点就将生成最长的链而超过攻击者。这种网络本身只需极简的架构。信息将被尽力广播，节点可以随时离开和重新加入网络，只需接受最长的工作量证明链作为它们离开时发生事件的证据。</p>
</blockquote>
<h2 id="_1-introduction" tabindex="-1"> 1. Introduction</h2>
<p>Commerce on the Internet has come to rely almost exclusively on financial institutions serving astrusted third  parties  to process electronic payments.   While the  system works  well enough formost   transactions,   it   still   suffers   from   the   inherent   weaknesses   of   the   trust   based   model.Completely non-reversible transactions are not really possible, since financial institutions cannotavoid   mediating   disputes.     The   cost   of   mediation   increases   transaction   costs,   limiting   theminimum practical transaction size and cutting off the possibility for small casual transactions,and   there   is   a   broader   cost   in   the   loss   of   ability   to   make   non-reversible   payments   for   non-reversible services.  With the possibility of reversal, the need for trust spreads.  Merchants mustbe wary of their customers, hassling them for more information than they would otherwise need.A certain percentage of fraud is accepted as unavoidable.  These costs and payment uncertaintiescan be avoided in person by using physical currency, but no mechanism exists to make paymentsover a communications channel without a trusted party.What is needed is an electronic payment system based on cryptographic proof instead of trust,allowing any two willing parties to transact directly with each other without the need for a trustedthird  party.
Transactions  that  are  computationally  impractical  to   reverse   would  protect  sellersfrom fraud, and routine escrow mechanisms could easily be implemented to protect buyers.   Inthis paper, we propose a solution to the double-spending problem using a peer-to-peer distributedtimestamp server to generate computational proof of the chronological order of transactions.  Thesystem   is   secure   as   long   as   honest   nodes   collectively   control   more   CPU   power   than   anycooperating group of attacker nodes.</p>
<h2 id="_1、简介" tabindex="-1"> 1、简介</h2>
<p>互联网贸易已经变得几乎完全依赖金融机构作为可信任第三方来处理电子支付。尽管对于大部分交易这种系统运行得足够好，但仍需忍受基于信任模型这个固有缺点。由于金融机构不可避免的需要仲裁纠纷，完全的不可撤销交易实际是做不到的。仲裁成本增加了交易成本，限制了最小实际交易额度从而杜绝了日常小额交易的可能性，而且由于不支持不可撤销支付，对不可撤销服务进行支付将需要更大的成本。由于存在交易被撤销的可能性，对于信任的需求将更广泛。商家必须警惕他们的客户，麻烦他们提供更多他本不必要的信息。一定比例的欺诈被认为是不可避免的。虽可通过当面使用实物货币来避免这些成本及支付的不确定性，但不存在不引入一个可信任方而能在通信通道上进行支付的机制。
我们需要的是一个基于密码学原理而不是信任的电子支付系统，该系统允许任何有交易意愿的双方能直接交易而不需要一个可信任第三方。交易在计算上的不可撤销将保护卖家不被欺诈，用来保护买家的程序化合约机制也应该较容易实现。在这篇论文中，我们提出一种使用点对点分布式时间戳服务器为基于时间的交易序列生成计算上的证据来解决双重支付问题的方案。只要诚实节点集体控制的CPU算力大于每一个合作攻击节点群的CPU算力，这个系统就是安全的。</p>
<h2 id="_2-transactions" tabindex="-1"> 2. Transactions</h2>
<p>We define an electronic coin as a chain of digital signatures.  Each owner transfers the coin to thenext by digitally signing a hash of the previous transaction and the public key of the next ownerand adding these to the end of the coin.  A payee can verify the signatures to verify the chain of ownership.</p>
<h2 id="_2、交易" tabindex="-1"> 2、交易</h2>
<p>我们定义一枚电子货币就是一条数字签名链。每个拥有者都通过将上一次交易和下一个拥有者的公钥的哈希值的数字签名添加到此货币末尾的方式将这枚货币转移给下一个拥有者。收款人可以通过验证数字签名来证实其为该链的所有者。
<img src="@source/blockchain/assets/img/bitcoin-1.png" alt="bitcoin">
The problem of course is the payee can't verify that one of the owners did not double-spendthe coin.  A common solution is to introduce a trusted central authority, or mint, that checks everytransaction for double spending.  After each transaction, the coin must be returned to the mint toissue a new coin, and only coins issued directly from the mint are trusted not to be double-spent.The   problem   with   this   solution   is   that   the   fate   of   the   entire   money   system   depends   on   thecompany running the mint, with every transaction having to go through them, just like a bank.<br>
We   need   a   way   for   the   payee   to   know   that   the   previous   owners   did   not   sign   any   earliertransactions.   For our purposes, the earliest transaction is the one that counts, so we don't careabout later attempts to double-spend.  The only way to confirm the absence of a transaction is tobe aware of all transactions.  In the mint based model, the mint was aware of all transactions anddecided   which   arrived   first.    To  accomplish   this   without   a   trusted   party,   transactions   must   bepublicly announced [1], and we need a system for participants to agree on a single history of theorder in which they were received.  The payee needs proof that at the time of each transaction, themajority of nodes agreed it was the first received.<br>
这里的问题是收款人不能证实拥有者之一没有对此货币进行双重支付。通常的做法是引入一个可信任的中央机构或铸币厂来检查每笔交易是否存在双重支付。每笔交易之后，都需要将这枚货币退回铸币厂以换取发行一枚新的货币，只有由铸币厂直接发行的货币才能被确认没有被双重支付。这个方案的问题在于整个货币系统的命运都依赖于运营铸币厂的公司，每笔交易都需要经过它们，就像银行一样。<br>
我们需要一种能让收款人知道上一个货币拥有者 没有对任何更早的交易签名的方法。对我们来说，最早的那次交易是唯一有效的，所以我们不需要关心本次交易后面的双重支付尝试 。唯一能确保一笔交易不存在的方法是知晓所有之前的交易。在铸币厂模型中，铸币厂知晓所有交易并能确定哪笔交易最先到达。在不引入一个可信任方的前提下要达到这个目的， 所有交易就必须公开发布[1]，而且需要一个能让所有参与者对交易收到顺序的单一历史达成共识的系统。收款人在每笔交易时，都需要多数节点认同此交易是最先收到的证据。</p>
<h2 id="_3-timestamp-server" tabindex="-1"> 3. Timestamp Server</h2>
<p>The solution we propose begins with a timestamp server.  A timestamp server works by taking ahash   of   a   block   of   items   to   be   timestamped   and   widely   publishing   the   hash,   such   as   in   anewspaper or Usenet post [2-5].   The timestamp proves that the data must have existed at thetime, obviously, in order to get into the hash.  Each timestamp includes the previous timestamp inits hash, forming a chain, with each additional timestamp reinforcing the ones before it.</p>
<h2 id="_3、时间戳服务器" tabindex="-1"> 3、时间戳服务器</h2>
<p>我们提出的方案从时间戳服务器开始。时间戳服务器计算包含 多个需要被打时间戳的数据项的区块 的哈希  值并 广泛 地发布这个哈希值，就 像在报纸或  新闻组帖  子里[2-5]。时间戳能证明要得到这个哈希值，显然这些数据当时一定是存在的。每个时间戳的哈希值都纳 入了上一个时间戳，形成一条链，后面的时间戳进一步增强前一个时间戳。</p>
<p><img src="@source/blockchain/assets/img/bitcoin-2.png" alt="bitcoin"></p>
<h2 id="_4-proof-of-work" tabindex="-1"> 4. Proof-of-Work</h2>
<p>To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system  similar to Adam  Back's  Hashcash  [6],  rather than  newspaper  or  Usenet  posts.The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, thehash begins with a number of zero bits.  The average work required is exponential in the numberof zero bits required and can be verified by executing a single hash.<br>
For our timestamp network, we implement the proof-of-work by incrementing a nonce in theblock until a value is found that gives the block's hash the required zero bits.   Once the CPUeffort   has   been   expended   to   make   it   satisfy   the   proof-of-work,   the   block   cannot   be   changedwithout  redoing  the   work.    As   later   blocks   are  chained   after  it,   the  work  to  change  the  blockwould include redoing all the blocks after it.</p>
<h2 id="_4、工作量证明" tabindex="-1"> 4、工作量证明</h2>
<p>为了实现一个基于点对点的时间戳服务器，我们需要使用一个类似Adam Back 提出的哈希货币[6] 的工作量证明系统，而不是报纸或新闻组帖子那样。工作量证明采取搜索一个数，使得被哈希时，如使用SHA-256，得到的哈希值以数个0比特开始。平均所需工作量将随所需 0比特呈指数级增长而验证却只需执行一次哈希。<br>
对于我们的时间戳网络。我们通过在区块中加入一个随机数，直到使得区块的哈希值满足所需0比特的数被找到的方式实现工作量证明。一旦消耗了CPU算力使区块满足了工作量证明，那么除非重做这个工作否则就无法更改 区块 。由于后面的区块是链接在这个区块后面的，改变这个区块将需要重做所有后面的区块。
<img src="@source/blockchain/assets/img/bitcoin-pow.png" alt="bitcoin">
The proof-of-work also solves the problem of determining representation in majority decisionmaking.  If the majority were based on one-IP-address-one-vote, it could be subverted by anyoneable   to   allocate   many   IPs.     Proof-of-work   is   essentially   one-CPU-one-vote.     The   majoritydecision is represented by the longest chain, which has the greatest proof-of-work effort investedin it.  If a majority of CPU power is controlled by honest nodes, the honest chain will grow thefastest and outpace any competing chains.   To modify a past block, an attacker would have toredo the proof-of-work of the block and all blocks after it and then catch up with and surpass thework of the honest nodes.  We will show later that the probability of a slower attacker catching updiminishes exponentially as subsequent blocks are added.<br>
To compensate for increasing hardware speed and varying interest in running nodes over time,the proof-of-work difficulty is determined by a moving average targeting an average number ofblocks per hour.  If they're generated too fast, the difficulty increases.<br>
工作量证明同时解决了在多数决定中确定投票方式的问题。如果多数是按IP地址投票来决定，那么它将可能被能分配大量IP 地址的人破坏 。工作量证明本质上是 按CPU 投票。最长的链代表了多数决定，因为有最大的计算工作量证明的精力投入到这条链上。如果多数的CPU算力被诚实节点控制，诚实的链就会增长得最快并超过其他的竞争链。要修改过去的某区块，攻击者必须重做这个区块以及其后的所有区块的工作量证明从而赶上并超过诚实节点的工作。我们后面会证明随着后续的区块被添加一个更慢的攻击者赶上诚实节点的概率将呈指数级递减。<br>
为了抵消硬件运算速度的增加及平衡不同时期运行节点的利益，工作量证明的难度将由移动平均数法来确定每小时生成区块的平均数。如果区块生成得过快，那么生成的难度就会增加。</p>
<h2 id="_5-network" tabindex="-1"> 5. Network</h2>
<p>The steps to run the network are as follows:</p>
<ol>
<li>New transactions are broadcast to all nodes.</li>
<li>Each node collects new transactions into a block.</li>
<li>Each node works on finding a difficult proof-of-work for its block.</li>
<li>When a node finds a proof-of-work, it broadcasts the block to all nodes.</li>
<li>Nodes accept the block only if all transactions in it are valid and not already spent.</li>
<li>Nodes express their acceptance of the block by working on creating the next block in thechain, using the hash of the accepted block as the previous hash.</li>
</ol>
<p>Nodes   always   consider   the   longest   chain   to   be   the   correct   one   and   will   keep   working   onextending it.   If two nodes broadcast different versions of the next block simultaneously, somenodes may receive one or the other first.  In that case, they work on the first one they received,but save the other branch in case it becomes longer.  The tie will be broken when the next proof-of-work   is   found   and   one   branch   becomes   longer;   the   nodes   that   were   working   on   the   otherbranch will then switch to the longer one.<br>
New transaction broadcasts do not necessarily need to reach all nodes.  As long as they reachmany nodes, they will get into a block before long.  Block broadcasts are also tolerant of droppedmessages.  If a node does not receive a block, it will request it when it receives the next block andrealizes it missed one.</p>
<h2 id="_5、网络" tabindex="-1"> 5、网络</h2>
<p>运行网络的步骤如下：</p>
<ol>
<li>新交易向所有节点广播。</li>
<li>每个节点将新交易收集到一个区块。</li>
<li>每个节点为它的区块寻找工作量证明。</li>
<li>当一个节点找到了工作量证明，就向所有节点广播这个区块。</li>
<li>节点只有在区块内所有交易都是有效的且之前没有被支付的情况下接收这个区块。</li>
<li>节点通过使用这个区块的哈希值作为上一个哈希值在链中创建下一个区块的方式表示对这个区块的接受。</li>
</ol>
<p>节点总是认为最长的链为正确的并持续致力于延长它。如果两个节点同时广播了不同的下一个区块，有些节点可能先收到其中一个而其他节点先收到另一个。这种情况，节点基于他们收到的第一个区块工作，但是也保存另一个分支以防它变为更长的链。当下一个工作量证明被找到后，僵局就会被打破从而其中一个分支变得更长；在另一个分支上工作的节点将切换到更长的链上来。新交易的广播不必到达所有的节点。只要到达一些节点，不久就会进入到一个区块 。区块广播也是能容忍消息丢失的。如果一个节点没有收到某个区块 ，它将在收到下一个区块时发现它丢失了一个区块然后去请求这个区块。</p>
<h2 id="_6-incentive" tabindex="-1"> 6. Incentive</h2>
<p>By convention, the first transaction in a block is a special transaction that starts a new coin ownedby the creator of the block.  This adds an incentive for nodes to support the network, and providesa way to initially distribute coins into circulation, since there is no central authority to issue them.The steady addition of a constant of amount of new coins is analogous to gold miners expendingresources to add gold to circulation.  In our case, it is CPU time and electricity that is expended.<br>
The incentive can also be funded with transaction fees.  If the output value of a transaction isless than its input value, the difference is a transaction fee that is added to the incentive value ofthe   block   containing   the   transaction.     Once   a   predetermined   number   of   coins   have   enteredcirculation, the incentive can transition entirely to transaction fees and be completely inflationfree.<br>
The   incentive   may   help   encourage   nodes   to   stay   honest.     If   a   greedy   attacker   is   able   toassemble more CPU power than all the honest nodes, he would have to choose between using itto defraud people by stealing back his payments, or using it to generate new coins.  He ought tofind it more profitable to play by the rules, such rules that favour him with more new coins thaneveryone else combined, than to undermine the system and the validity of his own wealth.</p>
<h2 id="_6、激励" tabindex="-1"> 6、激励</h2>
<p>我们约定，区块中的第一笔交易是区块创建者开启一枚属于他的新货币的特殊的交易。这就增加了对支持网络的节点的激励 ，并提供了一种分发货币到流通领域的方法，因为这里没有中央机构来发行货币。新货币按固定量  稳定地增加就像金矿矿工消耗资源并增加黄金到流通领域一样。对我们而言，消耗的是 CPU 时间和电力。<br>
激励也可以由交易费充当。如果交易的输出值小于其输入值，差价就作为交易费被加到包含此交易的区块的激励中  。一旦预定量的货币进入了流通领域，激励将变为只含有交易费，这样可以完全避免通货膨胀。<br>
激励会有助于鼓励节点保持诚实。如果一个贪心的攻击者有能力聚集比所有诚实节点更多的CPU算力，他将面临是以骗回已付款的方式欺诈别人还是使用这些算力生成新货币的抉择。他将发现遵守规则比破坏系统和他自己财产的有效性更有利，因为这些规则准许他获得比所有其他人都多的新货币。</p>
<h2 id="_7-reclaiming-disk-space" tabindex="-1"> 7. Reclaiming Disk Space</h2>
<p>Once the latest transaction in a coin is buried under enough blocks, the spent transactions beforeit   can   be   discarded   to   save   disk   space.     To   facilitate   this   without   breaking   the   block's   hash,transactions are hashed in a Merkle Tree [7][2][5], with only the root included in the block's hash.Old blocks can then be compacted by stubbing off branches of the tree.   The interior hashes donot need to be stored.</p>
<h2 id="_7、回收磁盘空间" tabindex="-1"> 7、回收磁盘空间</h2>
<p>一旦某个货币的最新交易已经被足够多的区块覆盖，这之前的支付交易就可以被丢弃 以节省磁盘空间。为便于此而又不破坏区块的哈希值，交易将被哈希进默克尔树[7][2][5]，只有根节点被纳入到区块的哈希值。老的区块可通过剪除树枝的方式被压缩。树枝内部的哈希不需要被保存。</p>
<p><img src="@source/blockchain/assets/img/bitcoin-disk-space.png" alt="bitcoin"></p>
<p>A  block   header   with   no   transactions   would   be   about   80   bytes.     If   we   suppose   blocks   aregenerated every 10 minutes, 80 bytes <em>6</em> 24 * 365 = 4.2MB per year.  With computer systemstypically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of1.2GB   per   year,   storage   should   not   be   a   problem   even   if   the   block   headers   must   be   kept   inmemory.</p>
<p>每个不包含交易的区块头大约是 80 bytes。如果每10分钟生成一个区块 ，每年生成 80bytes <em>6</em> 24 * 365 = 4.2MB，2008年在售的典型计算机有2GB内存， 并且摩尔定律预测目前每年内存增加 1.2GB，所以就算区块头一定要存在内存里，存储也不是问题。</p>
<h2 id="_8-simplified-payment-verification" tabindex="-1"> 8. Simplified Payment Verification</h2>
<p>It is possible to verify payments without running a full network node.  A user only needs to keepa copy of the block headers of the longest proof-of-work chain, which he can get by queryingnetwork   nodes   until   he's   convinced   he   has   the   longest   chain,   and   obtain   the   Merkle   branchlinking   the   transaction   to   the   block   it's   timestamped   in.     He   can't   check   the   transaction   forhimself, but by linking it to a place in the chain, he can see that a network node has accepted it,and blocks added after it further confirm the network has accepted it.</p>
<h2 id="_8、-简化的支付验证" tabindex="-1"> 8、 简化的支付验证</h2>
<p>不运行一个完整的网络节点也是可以进行支付验证的。用户只需拥有一个最长工作量证明链的区块头副本，他可以通过向其他网络节点查询以确认他拥有了最长的链，并获取链接交易到给交易打时间戳区块的默克尔分支。虽然他自己不能核实这个交易，但如果交易已经链接到到链中的某个位置，就说明一个网络节点已经接受了此交易，而其后追加的区块进一步确认网络已经接受了它。</p>
<p><img src="@source/blockchain/assets/img/bitcoin-simplified-payment.png" alt="bitcoin"></p>
<p>As such, the verification is reliable as long as honest nodes control the network, but is morevulnerable   if   the   network   is   overpowered   by   an   attacker.     While   network   nodes   can   verifytransactions   for   themselves,   the   simplified   method   can   be   fooled   by   an   attacker's   fabricatedtransactions for as long as the attacker can continue to overpower the network.   One strategy toprotect against this would be to accept alerts from network nodes when they detect an invalidblock,   prompting   the   user's   software   to   download   the   full   block   and   alerted   transactions   toconfirm the inconsistency.  Businesses that receive frequent payments will probably still want torun their own nodes for more independent security and quicker verification.<br>
同样地，只要诚实节点控制着网络这种简化验证就是可靠的，如果网络被攻击者控制简化验证会变得比较脆弱 。虽然网络节点可以验证他们自己的交易，但只要攻击者持续控制网络那么这种简化的方法就可能被攻击者的伪造交易欺骗。一种对策是接受其他网络节点发现一个无效区块时发出的警告，提醒用户软件下载整个区块和被警告的交易来检查一致性。为了更加独立的安全性以及更快的支付确认，收款频繁的公司可能仍需运行他们自己的节点。</p>
<h2 id="_9-combining-and-splitting-value" tabindex="-1"> 9. Combining and Splitting Value</h2>
<p>Although   it   would   be   possible   to   handle   coins   individually,   it   would   be   unwieldy   to   make   aseparate   transaction   for   every   cent   in   a   transfer.     To   allow   value   to   be   split   and   combined,transactions  contain  multiple  inputs  and  outputs.    Normally  there will  be either  a  single  inputfrom a larger previous transaction or multiple inputs combining smaller amounts, and at most twooutputs: one for the payment, and one returning the change, if any, back to the sender.</p>
<h2 id="_9、合并和分割交易额" tabindex="-1"> 9、合并和分割交易额</h2>
<p>尽管单独处理每个货币是可行的，但将一次转账按每一分拆成多次交易是笨拙的。为允许交易额被分割和合并，交易将包含多个输入值和输出值。通常是一个从之前交易而得的较大输入值或多个较小输入值的组合，以及最多两个输出值：一个作为支付，另一个作为找零，如果有的话，退还给支付发送方。</p>
<p><img src="@source/blockchain/assets/img/bitcoin-transaction.png" alt="bitcoin"></p>
<p>It should be noted that fan-out, where a transaction depends on several transactions, and thosetransactions depend on many more, is not a problem here.   There is never the need to extract acomplete standalone copy of a transaction's history.<br>
注意这里的扇出，即一笔交易依赖数笔交易，这数笔交易又依赖更多的交易，在这里是不存在问题的。永远不会需要获取一笔交易历史的完整独立副本。</p>
<h2 id="_10-privacy" tabindex="-1"> 10. Privacy</h2>
<p>The traditional banking model achieves a level of privacy by limiting access to information to theparties involved and the trusted third party.   The necessity to announce all transactions publiclyprecludes this method, but privacy can still be maintained by breaking the flow of information inanother place: by keeping public keys anonymous.   The public can see that someone is sendingan amount to someone else, but without information linking the transaction to anyone.   This issimilar   to   the   level   of   information   released   by   stock   exchanges,   where   the   time   and   size   ofindividual trades, the &quot;tape&quot;, is made public, but without telling who the parties were.</p>
<h2 id="_10、隐私" tabindex="-1"> 10、隐私</h2>
<p>传统的银行模型通过限制参与方和可信任第三方对信息的访问来达到一定级别的隐私。交易必须要公开发布就不能使用这个方法，但隐私仍可在其他地方通过阻断信息流的方式来保护：那就是保持公钥匿名。 公众能看到有人正在发送一定量货币给其他人，但是不能将交易关联到某个人。这和证券交易所发布的信息级别类似，每笔交易的时间和交易量，即行情是公开的，但是不会显示交易双方是谁。</p>
<p><img src="@source/blockchain/assets/img/bitcoin-privacy.png" alt="bitcoin"></p>
<p>As an additional firewall, a new key pair should be used for each transaction to keep themfrom   being   linked   to   a   common   owner.     Some   linking   is   still   unavoidable   with   multi-inputtransactions, which necessarily reveal that their inputs were owned by the same owner.  The riskis that if the owner of a key is revealed, linking could reveal other transactions that belonged tothe same owner.<br>
作为额外的防火墙 ，对每笔交易使用新密钥对可以防止他们被关联到一个共同的拥有者。由于多输入值交易存在，有些关联仍不可避免，因为多输入值交易必然暴露其多个输入是属于同一个拥有者的。风险就在于如果一个密钥的拥有者被暴露，关联性将暴露其他属于同一个拥有者的交易。</p>
<h2 id="_11-calculations" tabindex="-1"> 11. Calculations</h2>
<p>We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent.</p>
<h2 id="_11、计算" tabindex="-1"> 11、计算</h2>
<p>假设一个场景，某个攻击者正在试图生成一个比诚实链更快的替代链。就算他成功了，也不能对系统做任意的修改，即，他不可能凭空制造出价值，也无法获取从未属于他的钱。网络节点不会把一笔无效交易当作支付，而诚实节点也永远不会接受一个包含这种支付的区块。攻击者最多只能修改属于他自己的交易，进而试图取回他已经花出去的钱。</p>
<p>The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker's chain being extended by one block, reducing the gap by -1.</p>
<p>诚实链和攻击者之间的竞争可以用二项式随机漫步来描述。成功事件是诚实链刚刚被添加了一个新的区块，使得它的优势增加了 1；而失败事件是攻击者的链刚刚被增加了一个新的区块，使得诚实链的优势减少了 1。</p>
<p>The probability of an attacker catching up from a given deficit is analogous to a Gambler's Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows[8]:</p>
<p>攻击者能够从落后局面追平的概率类似于赌徒破产问题。假设，一个拿着无限筹码的赌徒，从亏空开始，允许他赌无限次，目标是填补上已有的亏空。我们能算出他最终能填补亏空的概率，也就是攻击者能够赶上诚实链的概率[8]，如下：</p>
<p>$$
\begin{eqnarray*}
\large p &amp;=&amp; \text{ 诚实节点找到下一个区块的概率}\
\large q &amp;=&amp; \text{ 攻击者找到下一个区块的概率}\
\large q_z &amp;=&amp; \text{ 攻击者落后 $z$ 个区块却依然能够赶上的概率}
\end{eqnarray*}
$$</p>
<p>$$
\large q_z = \begin{Bmatrix}
1 &amp; \textit{if}; p \leq q\
(q/p)^z &amp; \textit{if}; p &gt; q
\end{Bmatrix}
$$</p>
<p>Given our assumption that $p \gt q$, the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn't make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind.</p>
<p>既然我们已经假定 $p &gt; q$, 既然攻击者需要赶超的区块数量越来越多，那么其成功概率就会指数级下降。于赢面不利时，如果攻击者没有在起初就能幸运地做一个前移步刺，那么他的胜率将在他进一步落后的同时消弭殆尽。</p>
<p>We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can't change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late.</p>
<p>现在考虑一下一笔新交易的收款人需要等多久才能充分确定发款人不能更改这笔交易。我们假定发款人是个攻击者，妄图让收款人在一段时间里相信他已经支付对付款项，随后将这笔钱再转回给自己。发生这种情况时，收款人当然会收到警告，但发款人希望那时木已成舟。</p>
<p>The receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction.</p>
<p>收款人生成了一对新的公私钥，而后在签署之前不久将公钥告知发款人。这样可以防止一种情形：发款人提前通过连续运算去准备一条链上的区块，并且只要有足够的运气就会足够领先，直到那时再执行交易。一旦款项已被发出，那个不诚实的发款人开始秘密地在另一条平行链上开工，试图在其中加入一个反向版本的交易。</p>
<p>The recipient waits until the transaction has been added to a block and $z$ blocks have been linked after it. He doesn't know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker's potential progress will be a Poisson distribution with expected value:</p>
<p>收款人等到此笔交易被打包进区块，并已经有 $z$ 个区块随后被加入。他并不知道攻击者的工作进展究竟如何，但是可以假定诚实区块在每个区块生成过程中耗费的平均时间；攻击者的潜在进展符合泊松分布，其期望值为：</p>
<p>$$
\large \lambda = z \frac qp
$$</p>
<p>To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point:</p>
<p>为了算出攻击者依然可以赶上的概率，我们要把每一个攻击者已有的进展的帕松密度乘以他可以从那一点能够追上来的概率：</p>
<p>$$
\large \sum_{k=0}^{\infty} \frac{\lambda^k e^{-\lambda}}{k!} \cdot
\begin{Bmatrix}
(q/p)^{(z-k)} &amp; \textit{if};k\leq z\
1 &amp; \textit{if} ; k &gt; z
\end{Bmatrix}
$$</p>
<p>Rearranging to avoid summing the infinite tail of the distribution...</p>
<p>为了避免对密度分布的无穷级数求和重新整理…</p>
<p>$$
\large 1 - \sum_{k=0}^{z} \frac{\lambda^k e^{-\lambda}}{k!}
\left ( 1-(q/p)^{(z-k)} \right )
$$</p>
<p>Converting to C code...</p>
<p>转换为 C 语言程序……</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;math.h></span></span>
<span>double</span> <span>AttackerSuccessProbability</span><span>(</span><span>double</span> q<span>,</span> <span>int</span> z<span>)</span>
<span>{</span>
 <span>double</span> p <span>=</span> <span>1.0</span> <span>-</span> q<span>;</span>
 <span>double</span> lambda <span>=</span> z <span>*</span> <span>(</span>q <span>/</span> p<span>)</span><span>;</span>
 <span>double</span> sum <span>=</span> <span>1.0</span><span>;</span>
 <span>int</span> i<span>,</span> k<span>;</span>
 <span>for</span> <span>(</span>k <span>=</span> <span>0</span><span>;</span> k <span>&lt;=</span> z<span>;</span> k<span>++</span><span>)</span>
 <span>{</span>
  <span>double</span> poisson <span>=</span> <span>exp</span><span>(</span><span>-</span>lambda<span>)</span><span>;</span>
  <span>for</span> <span>(</span>i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> k<span>;</span> i<span>++</span><span>)</span>
   poisson<span>*=</span>lambda <span>/</span> i<span>;</span>
  sum <span>-=</span> poisson <span>*</span> <span>(</span><span>1</span> <span>-</span> <span>pow</span><span>(</span>q <span>/</span> p<span>,</span> z <span>-</span> k<span>)</span><span>)</span><span>;</span>
 <span>}</span>
 <span>return</span> sum<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Running some results, we can see the probability drop off exponentially with $z$.</p>
<p>获取部分结果，我们可以看到概率随着 $z$ 的增加指数级下降：</p>
<div><pre><code>   q=0.1
   z=0    P=1.0000000
   z=1    P=0.2045873
   z=2    P=0.0509779
   z=3    P=0.0131722
   z=4    P=0.0034552
   z=5    P=0.0009137
   z=6    P=0.0002428
   z=7    P=0.0000647
   z=8    P=0.0000173
   z=9    P=0.0000046
   z=10   P=0.0000012

   q=0.3
   z=0    P=1.0000000
   z=5    P=0.1773523
   z=10   P=0.0416605
   z=15   P=0.0101008
   z=20   P=0.0024804
   z=25   P=0.0006132
   z=30   P=0.0001522
   z=35   P=0.0000379
   z=40   P=0.0000095
   z=45   P=0.0000024
   z=50   P=0.0000006
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Solving for P less than 0.1%...</p>
<p>若是 P 小于 0.1%……</p>
<div><pre><code>   P &lt; 0.001
   q=0.10   z=5
   q=0.15   z=8
   q=0.20   z=11
   q=0.25   z=15
   q=0.30   z=24
   q=0.35   z=41
   q=0.40   z=89
   q=0.45   z=340
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_12-conclusion" tabindex="-1"> 12. Conclusion</h2>
<p>We have proposed a system for electronic transactions without relying on trust. We started with the usual framework of coins made from digital signatures, which provides strong control of ownership, but is incomplete without a way to prevent double-spending. To solve this, we proposed a peer-to-peer network using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes control a majority of CPU power. The network is robust in its unstructured simplicity. Nodes work all at once with little coordination. They do not need to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis. Nodes can leave and rejoin the network at will, accepting the proof-of-work chain as proof of what happened while they were gone. They vote with their CPU power, expressing their acceptance of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them. Any needed rules and incentives can be enforced with this consensus mechanism.</p>
<h2 id="_12、总结" tabindex="-1"> 12、总结</h2>
<p>我们已经提出了一种不依赖信任的电子交易系统。我们从通用的数字签名货币体系开 始，这体系提供了强有力的 所有权控制，但由于缺乏防止双重支付的方法而不完  善。为解决这个问题，我们提出一种使用工作量证明来记录公共交易历史的点对点网络，只要诚实节点控制了多数的CPU算力，对于对攻击者，交易历史 将很快变得在  计算上不可更改。网络因其结构简 洁性而健壮。节点只需很少 的协调就能同时工作。它们不需要被认证，因为信息不会被发送到某个特殊 的位置，只需被尽力传播。节点可以随时离开和重新加入网络，只需接受最长的工作量证明链作为它们离开时发生事件的证据。节点使用CPU算力来  投票，通过 致力于 延长有效区块  来表达对其接受，通过拒绝在无效区块上工作来表达对其抵制。任何需要的规则和激励都可通过这个共识机制来加强</p>
<hr>
<h2 id="参考文献-references" tabindex="-1"> 参考文献 (References)</h2>
<ol>
<li><strong>b-money</strong> Dai Wei (1998-11-01) <a href="http://www.weidai.com/bmoney.txt" target="_blank" rel="noopener noreferrer">http://www.weidai.com/bmoney.txt</a></li>
<li><strong>Design of a secure timestamping service with minimal trust requirements</strong> Henri Massias, Xavier Serret-Avila, Jean-Jacques Quisquater <em>20th Symposium on Information Theory in the Benelux</em> (1999-05) <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.6228" target="_blank" rel="noopener noreferrer">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.6228</a></li>
<li>: <strong>How to time-stamp a digital document</strong> Stuart Haber, W.Scott Stornetta <em>Journal of Cryptology</em> (1991) <a href="https://doi.org/cwwxd4" target="_blank" rel="noopener noreferrer">https://doi.org/cwwxd4</a> DOI: <a href="https://doi.org/10.1007/bf00196791" target="_blank" rel="noopener noreferrer">10.1007/bf00196791</a></li>
<li>: <strong>Improving the Efficiency and Reliability of Digital Time-Stamping</strong> Dave Bayer, Stuart Haber, W. Scott Stornetta <em>Sequences II</em> (1993) <a href="https://doi.org/bn4rpx" target="_blank" rel="noopener noreferrer">https://doi.org/bn4rpx</a> DOI: <a href="https://doi.org/10.1007/978-1-4613-9323-8_24" target="_blank" rel="noopener noreferrer">10.1007/978-1-4613-9323-8_24</a></li>
<li>: <strong>Secure names for bit-strings</strong> Stuart Haber, W. Scott Stornetta <em>Proceedings of the 4th ACM conference on Computer and communications security - CCS ’97</em>(1997) <a href="https://doi.org/dtnrf6" target="_blank" rel="noopener noreferrer">https://doi.org/dtnrf6</a> DOI: <a href="https://doi.org/10.1145/266420.266430" target="_blank" rel="noopener noreferrer">10.1145/266420.266430</a></li>
<li>: <strong>Hashcash - A Denial of Service Counter-Measure</strong> Adam Back (2002-08-01) <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.8" target="_blank" rel="noopener noreferrer">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.8</a></li>
<li>: <strong>Protocols for Public Key Cryptosystems</strong> Ralph C. Merkle <em>1980 IEEE Symposium on Security and Privacy</em> (1980-04) <a href="https://doi.org/bmvbd6" target="_blank" rel="noopener noreferrer">https://doi.org/bmvbd6</a> DOI: <a href="https://doi.org/10.1109/sp.1980.10006" target="_blank" rel="noopener noreferrer">10.1109/sp.1980.10006</a></li>
<li>: <strong>An Introduction to Probability Theory and its Applications</strong> William Feller <em>John Wiley &amp; Sons</em> (1957) <a href="https://archive.org/details/AnIntroductionToProbabilityTheoryAndItsApplicationsVolume1" target="_blank" rel="noopener noreferrer">https://archive.org/details/AnIntroductionToProbabilityTheoryAndItsApplicationsVolume1</a></li>
</ol>
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>以太坊白皮书</title>
      <link>https://bytecodes.tech/blockchain/basic-logic/White_paper_the_etheric_lane.html</link>
      <guid>https://bytecodes.tech/blockchain/basic-logic/White_paper_the_etheric_lane.html</guid>
      <source url="https://bytecodes.tech/rss.xml">以太坊白皮书</source>
      <description>凤凰涅槃进阶之路 web3.0 区块链 区块链基础知识 P2P网络 以太坊白皮书</description>
      <category>区块链</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="以太坊白皮书-eth-white-paper" tabindex="-1"> 以太坊白皮书 ETH White paper</h2>
<blockquote>
<p>转自 ethfans <a href="https://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6" target="_blank" rel="noopener noreferrer">https://ethfans.org/wikis/以太坊白皮书</a></p>
</blockquote>
<h2 id="历史" tabindex="-1"> 历史</h2>
<p>去中心化的数字货币概念，正如财产登记这样的替代应用一样，早在几十年以前就被提出来了。1980和1990年代的匿名电子现金协议，大部分是以乔姆盲签技术（Chaumian blinding）为基础的。这些电子现金协议提供具有高度隐私性的货币，但是这些协议都没有流行起来，因为它们都依赖于一个中心化的中介机构。1998年，戴伟（Wei Dai）的b-money首次引入了通过解决计算难题和去中心化共识创造货币的思想，但是该建议并未给出如何实现去中心化共识的具体方法。2005年，芬尼（Hal Finney）引入了“可重复使用的工作量证明机制”（reusable proofs of work）概念，它同时使用b-money的思想和Adam Back提出的计算困难的哈希现金（Hashcash）难题来创造密码学货币。但是，这种概念再次迷失于理想化，因为它依赖于可信任的计算作为后端。</p>
<p>因为货币是一个先申请应用，交易的顺序至关重要，所以去中心化的货币需要找到实现去中心化共识的方法。比特币以前的所有电子货币协议所遇到的主要障碍是，尽管对如何创建安全的拜占庭问题容错（Byzantine-fault-tolerant）多方共识系统的研究已经历时多年，但是上述协议只解决了问题的一半。这些协议假设系统的所有参与者是已知的，并产生如“如果有N方参与到系统中，那么系统可以容忍N/4的恶意参与者”这样形式的安全边界。然而这个假设的问题在于，在匿名的情况下，系统设置的安全边界容易遭受女巫攻击，因为一个攻击者可以在一台服务器或者僵尸网络上创建数以千计的节点，从而单方面确保拥有多数份额。</p>
<p>中本聪的创新是引入这样一个理念：将一个非常简单的基于节点的去中心化共识协议与工作量证明机制结合在一起。节点通过工作量证明机制获得参与到系统的权利，每十分钟将交易打包到“区块”中，从而创建出不断增长的区块链。拥有大量算力的节点有更大的影响力，但获得比整个网络更多的算力比创建一百万个节点困难得多。尽管比特币区块链模型非常简陋，但是实践证明它已经足够好用了，在未来五年，它将成为全世界两百个以上的货币和协议的基石。</p>
<h3 id="作为状态转换系统的比特币" tabindex="-1"> 作为状态转换系统的比特币</h3>
<p><img src="http://upyun-assets.ethfans.org/uploads/photo/image/ed77a88675204904984a696a55e2254e.png" alt="img"></p>
<p>从技术角度讲，比特币账本可以被认为是一个状态转换系统，该系统包括所有现存的比特币所有权状态和“状态转换函数”。状态转换函数以当前状态和交易为输入，输出新的状态。例如，在标准的银行系统中，状态就是一个资产负债表，一个从A账户向B账户转账X美元的请求是一笔交易，状态转换函数将从A账户中减去X美元，向B账户增加X美元。如果A账户的余额小于X美元，状态转换函数就会返回错误提示。所以我们可以如下定义状态转换函数：</p>
<div><pre><code>APPLY(S,TX) ­> S' or ERROR
</code></pre><div aria-hidden="true"><div></div></div></div><p>在上面提到的银行系统中，状态转换函数如下：</p>
<div><pre><code>APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30,Bob: $70 }
</code></pre><div aria-hidden="true"><div></div></div></div><p>但是：</p>
<div><pre><code>APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR
</code></pre><div aria-hidden="true"><div></div></div></div><p>比特币系统的“状态”是所有已经被挖出的、没有花费的比特币（技术上称为“未花费的交易输出，unspent transaction outputs 或UTXO”）的集合。每个UTXO都有一个面值和所有者（由20个字节的本质上是密码学公钥的地址所定义[1]）。一笔交易包括一个或多个输入和一个或多个输出。每个输入包含一个对现有UTXO的引用和由与所有者地址相对应的私钥创建的密码学签名。每个输出包含一个新的加入到状态中的UTXO。</p>
<p>在比特币系统中，状态转换函数<code>APPLY(S,TX)-&gt;S’</code>大体上可以如下定义：</p>
<ol>
<li>交易的每个输入：
<ul>
<li>如果引用的UTXO不存在于现在的状态中（<code>S</code>），返回错误提示</li>
<li>如果签名与UTXO所有者的签名不一致，返回错误提示</li>
</ul>
</li>
<li>如果所有的UTXO输入面值总额小于所有的UTXO输出面值总额，返回错误提示</li>
<li>返回新状态<code>S’</code>,新状态<code>S</code>中移除了所有的输入UTXO，增加了所有的输出UTXO。</li>
</ol>
<p>第一步的第一部分防止交易的发送者花费不存在的比特币，第二部分防止交易的发送者花费其他人的比特币。第二步确保价值守恒。比特币的支付协议如下。假设Alice想给Bob发送11.7BTC。事实上，Alice不可能正好有11.7BTC。假设，她能得到的最小数额比特币的方式是：6+4+2=12。所以，她可以创建一笔有3个输入，2个输出的交易。第一个输出的面值是11.7BTC，所有者是Bob（Bob的比特币地址），第二个输出的面值是0.3BTC，所有者是Alice自己，也就是找零。</p>
<h3 id="挖矿" tabindex="-1"> 挖矿</h3>
<p><img src="http://upyun-assets.ethfans.org/uploads/photo/image/81a76dc0e8924cfe81a8f3c8a76e84d4.png" alt="img"></p>
<p>一个区块，每个区块包含一个时间戳、一个随机数、一个对上一个区块的引用（即哈希）和上一区块生成以来发生的所有交易列表。这样随着时间流逝就创建出了一个持续增长的区块链，它不断地更新，从而能够代表比特币账本的最新状态。</p>
<p>依照这个范式，检查一个区块是否有效的算法如下：</p>
<ol>
<li>检查区块引用的上一个区块是否存在且有效。</li>
<li>检查区块的时间戳是否晚于以前的区块的时间戳，而且早于未来2小时[2]。</li>
<li>检查区块的工作量证明是否有效。</li>
<li>将上一个区块的最终状态赋于<code>S[0]</code>。</li>
<li>假设TX是区块的交易列表，包含n笔交易。对于属于0……n-1的所有i,进行状态转换<code>S[i+1] = APPLY(S[i],TX[i])</code>。如果任何一笔交易i在状态转换中出错，退出程序，返回错误。</li>
<li>返回正确，状态<code>S[n]</code>是这一区块的最终状态。</li>
</ol>
<p>本质上，区块中的每笔交易必须提供一个正确的状态转换，要注意的是，“状态”并不是编码到区块的。它纯粹只是被校验节点记住的抽象概念，对于任意区块都可以从创世状态开始，按顺序加上每一个区块的每一笔交易，（妥妥地）计算出当前的状态。另外，需要注意矿工将交易收录进区块的顺序。如果一个区块中有A、B两笔交易，B花费的是A创建的UTXO，如果A在B以前，这个区块是有效的，否则，这个区块是无效的。</p>
<p>区块验证算法的有趣部分是“工作量证明”概念：对每个区块进行SHA256哈希处理，将得到的哈希视为长度为256比特的数值，该数值必须小于不断动态调整的目标数值，本书写作时目标数值大约是2<sup>190。工作量证明的目的是使区块的创建变得困难，从而阻止女巫攻击者恶意重新生成区块链。因为SHA256是完全不可预测的伪随机函数，创建有效区块的唯一方法就是简单地不断试错，不断地增加随机数的数值，查看新的哈希数值是否小于目标数值。如果当前的目标数值是2</sup>192，就意味着平均需要尝试2^64次才能生成有效的区块。一般而言，比特币网络每隔2016个区块重新设定目标数值，保证平均每十分钟生成一个区块。为了对矿工的计算工作进行奖励，每一个成功生成区块的矿工有权在区块中包含一笔凭空发给他们自己25BTC的交易。另外，如果交易的输入大于输出，差额部分就作为“交易费用”付给矿工。顺便提一下，对矿工的奖励是比特币发行的唯一机制，创世状态中并没有比特币。</p>
<p>为了更好地理解挖矿的目的，让我们分析比特币网络出现恶意攻击者时会发生什么。因为比特币的密码学基础是非常安全的，所以攻击者会选择攻击没有被密码学直接保护的部分：交易顺序。攻击者的策略非常简单：</p>
<ol>
<li>向卖家发送100BTC购买商品（尤其是无需邮寄的电子商品）。</li>
<li>等待直至商品发出。</li>
<li>创建另一笔交易，将相同的100BTC发送给自己的账户。</li>
<li>使比特币网络相信发送给自己账户的交易是最先发出的。</li>
</ol>
<p>一旦步骤（1）发生，几分钟后矿工将把这笔交易打包到区块，假设是第270000个区块。大约一个小时以后，在此区块后面将会有五个区块，每个区块间接地指向这笔交易，从而确认这笔交易。这时卖家收到货款，并向买家发货。因为我们假设这是数字商品，攻击者可以即时收到货。现在，攻击者创建另一笔交易，将相同的100BTC发送到自己的账户。如果攻击者只是向全网广播这一消息，这一笔交易不会被处理。矿工会运行状态转换函数<code>APPLY(S,TX)</code>，发现这笔交易将花费已经不在状态中的UTXO。所以，攻击者会对区块链进行分叉，将第269999个区块作为父区块重新生成第270000个区块，在此区块中用新的交易取代旧的交易。因为区块数据是不同的，这要求重新进行工作量证明。另外，因为攻击者生成的新的第270000个区块有不同的哈希，所以原来的第270001到第270005的区块不指向它，因此原有的区块链和攻击者的新区块是完全分离的。在发生区块链分叉时，区块链长的分支被认为是诚实的区块链，合法的的矿工将会沿着原有的第270005区块后挖矿，只有攻击者一人在新的第270000区块后挖矿。攻击者为了使得他的区块链最长，他需要拥有比除了他以外的全网更多的算力来追赶（即51%攻击）。</p>
<h3 id="默克尔树" tabindex="-1"> 默克尔树</h3>
<p><img src="@source/blockchain/assets/img/merkle_tree_bitcoin.png" alt="img"></p>
<p>左：仅提供默克尔树（Merkle tree）上的少量节点已经足够给出分支的合法证明。
右：任何对于默克尔树的任何部分进行改变的尝试都会最终导致链上某处的不一致。</p>
<p>比特币系统的一个重要的可扩展特性是：它的区块存储在多层次的数据结构中。一个区块的哈希实际上只是区块头的哈希，区块头是包含时间戳、随机数、上个区块哈希和存储了所有的区块交易的默克尔树的根哈希的长度大约为200字节的一段数据。</p>
<p>默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。最下面的大量的叶节点包含基础数据，每个中间节点是它的两个子节点的哈希，根节点也是由它的两个子节点的哈希，代表了默克尔树的顶部。默克尔树的目的是允许区块的数据可以零散地传送：节点可以从一个源下载区块头，从另外的源下载与其有关的树的其它部分，而依然能够确认所有的数据都是正确的。之所以如此是因为哈希向上的扩散：如果一个恶意用户尝试在树的下部加入一个伪造的交易，所引起的改动将导致树的上层节点的改动，以及更上层节点的改动，最终导致根节点的改动以及区块哈希的改动，这样协议就会将其记录为一个完全不同的区块（几乎可以肯定是带着不正确的工作量证明的）。</p>
<p>默克尔树协议对比特币的长期持续性可以说是至关重要的。在2014年4月，比特币网络中的一个全节点-存储和处理所有区块的全部数据的节点-需要占用15GB的内存空间，而且还以每个月超过1GB的速度增长。目前，这一存储空间对台式计算机来说尚可接受，但是手机已经负载不了如此巨大的数据了。未来只有商业机构和爱好者才会充当完整节点。简化支付确认（SPV)协议允许另一种节点存在，这样的节点被成为“轻节点”，它下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树“分支”。这使得轻节点只要下载整个区块链的一小部分就可以安全地确定任何一笔比特币交易的状态和账户的当前余额。</p>
<h3 id="其它的区块链应用" tabindex="-1"> 其它的区块链应用</h3>
<p>将区块链的思想应用到其它领域的想法早就出现了。在2005年，尼克萨博提出了“用所有权为财产冠名”的概念，文中描述了复制数据库技术的发展如何使基于区块链的系统可以应用于登记土地所有权，创建包括例如房产权、违法侵占和乔治亚州土地税等概念的详细框架。然而，不幸的是在那时还没有实用的复制数据库系统，所以这个协议被没有被付诸实践。不过，自2009年比特币系统的去中心化共识开发成功以来，许多区块链的其它应用开始快速出现。</p>
<ul>
<li><strong>域名币（namecoin）</strong>- 创建于2010年，被称为去中心化的名称注册数据库。像Tor、Bitcoin和BitMessage这样的去中心化协议，需要一些确认账户的方法，这样其他人才能够与用户进行交互。但是，在所有的现存的解决方案中仅有的可用的身份标识是象<code>1LW79wp5ZBqaHW1jL5TciBCrhQYtHagUWy</code>这样的伪随机哈希。理想的情况下，人们希望拥有一个带有象“george”这样的名称的账户。然而，问题是如果有人可以创建“george”账户，那么其他人同样也可以创建“george”账户来假扮。唯一的解决方法是先申请原则（first-to-file），只有第一个注册者可以成功注册，第二个不能再次注册同一个账户。这一问题就可以利用比特币的共识协议。域名币是利用区块链实现名称注册系统的最早的、最成功的系统。</li>
<li><strong>彩色币（Colored coins）</strong>- 彩色币的目的是为人们在比特币区块链上创建自己的数字货币，或者，在更重要的一般意义上的货币 – 数字令牌提供服务。依照彩色币协议，人们可以通过为某一特别的比特币UTXO指定颜色，发行新的货币。该协议递归地将其它UTXO定义为与交易输入UTXO相同的颜色。这就允许用户保持只包含某一特定颜色的UTXO，发送这些UTXO就像发送普通的比特币一样，通过回溯全部的区块链判断收到的UTXO颜色。</li>
<li><strong>元币（Metacoins）</strong>- 元币的理念是在比特币区块链上创建新的协议，利用比特币的交易保存元币的交易，但是采用了不同的状态转换函数APPLY’。因为元币协议不能阻止比特币区块链上的无效的元币交易，所以增加一个规则如果APPLY'(S,TX)返回错误，这一协议将默认APPLY'(S,TX) = S。这为创建任意的、先进的不能在比特币系统中实现的密码学货币协议提供了一个简单的解决方法，而且开发成本非常低，因为挖矿和网络的问题已经由比特币协议处理好了。</li>
</ul>
<p>因此，一般而言，建立共识协议有两种方法：建立一个独立的网络和在比特币网络上建立协议。虽然像域名币这样的应用使用第一种方法已经获得了成功，但是该方法的实施非常困难，因为每一个应用需要创建独立的区块链和建立、测试所有状态转换和网络代码。另外，我们预测去中心化共识技术的应用将会服从幂律分布，大多数的应用太小不足以保证自由区块链的安全，我们还注意到大量的去中心化应用，尤其是去中心化自治组织，需要进行应用之间的交互。</p>
<p>另一方面，基于比特币的方法存在缺点，它没有继承比特币可以进行简化确认支付（SPV) 的特性。比特币可以实现简化确认支付，因为比特币可以将区块链深度作为有效性确认代理。在某一点上，一旦一笔交易的祖先们距离现在足够远时，就可以认为它们是合法状态的一部分。与之相反，基于比特币区块链的元币协议不能强迫区块链不包括不符合元币协议的交易。因此，安全的元币协议的简化支付确认需要后向扫描所有的区块，直到区块链的初始点，以确认某一交易是否有效。目前，所有基于比特币的元币协议的“轻”实施都依赖可信任的服务器提供数据，这对主要目的之一是消除信任需要的密码学货币而言，只是一个相当次优的结果。</p>
<h3 id="脚本" tabindex="-1"> 脚本</h3>
<p>即使不对比特币协议进行扩展，它也能在一定程度上实现”智能合约”。比特币的UTXO可以被不只被一个公钥拥有，也可以被用基于堆栈的编程语言所编写的更加复杂的脚本所拥有。在这一模式下，花费这样的UTXO，必须提供满足脚本的数据。事实上，基本的公钥所有权机制也是通过脚本实现的：脚本将椭圆曲线签名作为输入，验证交易和拥有这一UTXO的地址，如果验证成功，返回1，否则返回0。更加复杂的脚本用于其它不同的应用情况。例如，人们可以创建要求集齐三把私钥中的两把才能进行交易确认的脚本（多重签名），对公司账户、储蓄账户和某些商业代理来说，这种脚本是非常有用的。脚本也能用来对解决计算问题的用户发送奖励。人们甚至可以创建这样的脚本“如果你能够提供你已经发送一定数额的的狗币给我的简化确认支付证明，这一比特币UTXO就是你的了”，本质上，比特币系统允许不同的密码学货币进行去中心化的兑换。</p>
<p>然而，比特币系统的脚本语言存在一些严重的限制：</p>
<ul>
<li><strong>缺少图灵完备性</strong> – 这就是说，尽管比特币脚本语言可以支持多种计算，但是它不能支持所有的计算。最主要的缺失是循环语句。不支持循环语句的目的是避免交易确认时出现无限循环。理论上，对于脚本程序员来说，这是可以克服的障碍，因为任何循环都可以用多次重复if 语句的方式来模拟，但是这样做会导致脚本空间利用上的低效率，例如，实施一个替代的椭圆曲线签名算法可能将需要256次重复的乘法，而每次都需要单独编码。</li>
<li><strong>价值盲（Value-blindness）</strong>。UTXO脚本不能为账户的取款额度提供精细的的控制。例如，预言机合约（oracle contract）的一个强大应用是对冲合约，A和B各自向对冲合约中发送价值1000美元的比特币，30天以后，脚本向A发送价值1000美元的比特币，向B发送剩余的比特币。虽然实现对冲合约需要一个预言机（oracle）决定一比特币值多少美元，但是与现在完全中心化的解决方案相比，这一机制已经在减少信任和基础设施方面有了巨大的进步。然而，因为UTXO是不可分割的，为实现此合约，唯一的方法是非常低效地采用许多有不同面值的UTXO（例如对应于最大为30的每个k，有一个2^k的UTXO)并使预言机挑出正确的UTXO发送给A和B。</li>
<li><strong>缺少状态</strong> – UTXO只能是已花费或者未花费状态，这就没有给需要任何其它内部状态的多阶段合约或者脚本留出生存空间。这使得实现多阶段期权合约、去中心化的交换要约或者两阶段加密承诺协议（对确保计算奖励非常必要）非常困难。这也意味着UTXO只能用于建立简单的、一次性的合约，而不是例如去中心化组织这样的有着更加复杂的状态的合约，使得元协议难以实现。二元状态与价值盲结合在一起意味着另一个重要的应用-取款限额-是不可能实现的。</li>
<li><strong>区块链盲（Blockchain-blindness）</strong>- UTXO看不到区块链的数据，例如随机数和上一个区块的哈希。这一缺陷剥夺了脚本语言所拥有的基于随机性的潜在价值，严重地限制了博彩等其它领域应用。</li>
</ul>
<p>我们已经考察了在密码学货币上建立高级应用的三种方法：建立一个新的区块链，在比特币区块链上使用脚本，在比特币区块链上建立元币协议。建立新区块链的方法可以自由地实现任意的特性，成本是开发时间和培育努力。使用脚本的方法非常容易实现和标准化，但是它的能力有限。元币协议尽管非常容易实现，但是存在扩展性差的缺陷。在以太坊系统中，我们的目的是建立一个能够同时具有这三种模式的所有优势的通用框架。</p>
<h2 id="以太坊" tabindex="-1"> 以太坊</h2>
<p>以太坊的目的是基于脚本、竞争币和链上元协议（on-chain meta-protocol）概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。以太坊通过建立终极的抽象的基础层-内置有图灵完备编程语言的区块链-使得任何人都能够创建合约和去中心化应用并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。域名币的主体框架只需要两行代码就可以实现，诸如货币和信誉系统等其它协议只需要不到二十行代码就可以实现。智能合约-包含价值而且只有满足某些条件才能打开的加密箱子-也能在我们的平台上创建，并且因为图灵完备性、价值知晓（value-awareness）、区块链知晓（blockchain-awareness）和多状态所增加的力量而比比特币脚本所能提供的智能合约强大得多。</p>
<h3 id="以太坊账户" tabindex="-1"> 以太坊账户</h3>
<p>在以太坊系统中，状态是由被称为“账户”（每个账户由一个20字节的地址）的对象和在两个账户之间转移价值和信息的状态转换构成的。以太坊的账户包含四个部分：</p>
<ul>
<li>随机数，用于确定每笔交易只能被处理一次的计数器</li>
<li>账户目前的以太币余额</li>
<li>账户的合约代码，如果有的话</li>
<li>账户的存储（默认为空）</li>
</ul>
<p>以太币（Ether）是以太坊内部的主要加密燃料，用于支付交易费用。一般而言，以太坊有两种类型的账户：外部所有的账户（由私钥控制的）和合约账户（由合约代码控制）。外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。</p>
<h3 id="消息和交易" tabindex="-1"> 消息和交易</h3>
<p>以太坊的消息在某种程度上类似于比特币的交易，但是两者之间存在三点重要的不同。第一，以太坊的消息可以由外部实体或者合约创建，然而比特币的交易只能从外部创建。第二，以太坊消息可以选择包含数据。第三，如果以太坊消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。</p>
<p>以太坊中“交易”是指存储从外部账户发出的消息的签名数据包。交易包含消息的接收者、用于确认发送者的签名、以太币账户余额、要发送的数据和两个被称为STARTGAS和GASPRICE的数值。为了防止代码的指数型爆炸和无限循环，每笔交易需要对执行代码所引发的计算步骤-包括初始消息和所有执行中引发的消息-做出限制。STARTGAS就是限制，GASPRICE是每一计算步骤需要支付矿工的费用。如果执行交易的过程中，“用完了瓦斯”，所有的状态改变恢复原状态，但是已经支付的交易费用不可收回了。如果执行交易中止时还剩余瓦斯，那么这些瓦斯将退还给发送者。创建合约有单独的交易类型和相应的消息类型；合约的地址是基于账号随机数和交易数据的哈希计算出来的。</p>
<p>消息机制的一个重要后果是以太坊的“头等公民”财产-合约与外部账户拥有同样权利，包括发送消息和创建其它合约的权利。这使得合约可以同时充当多个不同的角色，例如，用户可以使去中心化组织（一个合约）的一个成员成为一个中介账户（另一个合约），为一个偏执的使用定制的基于量子证明的兰波特签名（第三个合约）的个人和一个自身使用由五个私钥保证安全的账户（第四个合约）的共同签名实体提供居间服务。以太坊平台的强大之处在于去中心化的组织和代理合约不需要关心合约的每一参与方是什么类型的账户。</p>
<h3 id="以太坊状态转换函数" tabindex="-1"> 以太坊状态转换函数</h3>
<p><img src="http://upyun-assets.ethfans.org/uploads/photo/image/a1c08251ec654a8c9392821362a17946.png" alt="img"></p>
<p>以太坊的状态转换函数：<code>APPLY(S,TX) -&gt; S'</code>，可以定义如下：</p>
<ol>
<li>检查交易的格式是否正确（即有正确数值）、签名是否有效和随机数是否与发送者账户的随机数匹配。如否，返回错误。</li>
<li>计算交易费用:<code>fee=STARTGAS * GASPRICE</code>，并从签名中确定发送者的地址。从发送者的账户中减去交易费用和增加发送者的随机数。如果账户余额不足，返回错误。</li>
<li>设定初值<code>GAS = STARTGAS</code>，并根据交易中的字节数减去一定量的瓦斯值。</li>
<li>从发送者的账户转移价值到接收者账户。如果接收账户还不存在，创建此账户。如果接收账户是一个合约，运行合约的代码，直到代码运行结束或者瓦斯用完。</li>
<li>如果因为发送者账户没有足够的钱或者代码执行耗尽瓦斯导致价值转移失败，恢复原来的状态，但是还需要支付交易费用，交易费用加至矿工账户。</li>
<li>否则，将所有剩余的瓦斯归还给发送者，消耗掉的瓦斯作为交易费用发送给矿工。 例如，假设合约的代码如下：</li>
</ol>
<div><pre><code>if !self.storage[calldataload(0)]:
    self.storage[calldataload(0)] = calldataload(32)
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>需要注意的是，在现实中合约代码是用底层以太坊虚拟机（EVM）代码写成的。上面的合约是用我们的高级语言Serpent语言写成的，它可以被编译成EVM代码。假设合约存储器开始时是空的，一个值为10以太，瓦斯为2000，瓦斯价格为0.001以太并且64字节数据，第一个三十二字节的快代表号码2和第二个代表词<code>CHARLIE</code>。的交易发送后，状态转换函数的处理过程如下：</p>
<ol>
<li>检查交易是否有效、格式是否正确。</li>
<li>检查交易发送者至少有2000*0.001=2个以太币。如果有，从发送者账户中减去2个以太币。</li>
<li>初始设定gas=2000,假设交易长为170字节，每字节的费用是5，减去850，所以还剩1150。</li>
<li>从发送者账户减去10个以太币，为合约账户增加10个以太币。</li>
<li>运行代码。在这个合约中，运行代码很简单：它检查合约存储器索引为2处是否已使用，注意到它未被使用，然后将其值置为CHARLIE。假设这消耗了187单位的瓦斯，于是剩余的瓦斯为1150 - 187 = 963。 ６. 向发送者的账户增加963*0.001=0.963个以太币，返回最终状态。 如果没有合约接收交易，那么所有的交易费用就等于GASPRICE乘以交易的字节长度，交易的数据就与交易费用无关了。另外，需要注意的是，合约发起的消息可以对它们产生的计算分配瓦斯限额，如果子计算的瓦斯用完了，它只恢复到消息发出时的状态。因此，就像交易一样，合约也可以通过对它产生的子计算设置严格的限制，保护它们的计算资源。</li>
</ol>
<h3 id="代码执行" tabindex="-1"> 代码执行</h3>
<p>以太坊合约的代码使用低级的基于堆栈的字节码的语言写成的，被称为“以太坊虚拟机代码”或者“EVM代码”。代码由一系列字节构成，每一个字节代表一种操作。一般而言，代码执行是无限循环，程序计数器每增加一（初始值为零）就执行一次操作，直到代码执行完毕或者遇到错误，<code>STOP</code>或者<code>RETURN</code>指令。操作可以访问三种存储数据的空间：</p>
<ul>
<li><strong>堆栈</strong>，一种后进先出的数据存储，32字节的数值可以入栈，出栈。</li>
<li><strong>内存</strong>，可无限扩展的字节队列。</li>
<li><strong>合约的长期存储</strong>，一个秘钥/数值的存储，其中秘钥和数值都是32字节大小，与计算结束即重置的堆栈和内存不同，存储内容将长期保持。</li>
</ul>
<p>代码可以象访问区块头数据一样访问数值，发送者和接受到的消息中的数据，代码还可以返回数据的字节队列作为输出。</p>
<p>EVM代码的正式执行模型令人惊讶地简单。当以太坊虚拟机运行时，它的完整的计算状态可以由元组<code>(block_state, transaction, message, code, memory, stack, pc, gas)</code>来定义，这里<code>block_state</code>是包含所有账户余额和存储的全局状态。每轮执行时，通过调出代码的第<code>pc</code>（程序计数器）个字节，当前指令被找到，每个指令都有定义自己如何影响元组。例如，<code>ADD</code>将两个元素出栈并将它们的和入栈，将<code>gas</code>（瓦斯）减一并将<code>pc</code>加一，<code>SSTORE</code>将顶部的两个元素出栈并将第二个元素插入到由第一个元素定义的合约存储位置，同样减少最多200的gas值并将<code>pc</code>加一，虽然有许多方法通过即时编译去优化以太坊，但以太坊的基础性的实施可以用几百行代码实现。</p>
<h3 id="区块链和挖矿" tabindex="-1"> 区块链和挖矿</h3>
<p><img src="http://upyun-assets.ethfans.org/uploads/photo/image/44d88f61183b4dcca4c490969e2eaddd.png" alt="img"></p>
<p>虽然有一些不同，但以太坊的区块链在很多方面类似于比特币区块链。它们的区块链架构的不同在于，以太坊区块不仅包含交易记录和最近的状态，还包含区块序号和难度值。以太坊中的区块确认算法如下：</p>
<ol>
<li>检查区块引用的上一个区块是否存在和有效。</li>
<li>检查区块的时间戳是否比引用的上一个区块大，而且小于15分钟。</li>
<li>检查区块序号、难度值、 交易根，叔根和瓦斯限额（许多以太坊特有的底层概念）是否有效。</li>
<li>检查区块的工作量证明是否有效。</li>
<li>将<code>S[0]</code>赋值为上一个区块的<code>STATE_ROOT</code>。</li>
<li>将<code>TX</code>赋值为区块的交易列表，一共有<code>n</code>笔交易。对于属于<code>0……n-1</code>的<code>i</code>，进行状态转换<code>S[i+1] = APPLY(S[i],TX[i])</code>。如果任何一个转换发生错误，或者程序执行到此处所花费的瓦斯（gas）超过了<code>GASLIMIT</code>，返回错误。</li>
<li>用<code>S[n]</code>给<code>S_FINAL</code>赋值, 向矿工支付区块奖励。 8 检查<code>S-FINAL</code>是否与<code>STATE_ROOT</code>相同。如果相同，区块是有效的。否则，区块是无效的。</li>
</ol>
<p>这一确认方法乍看起来似乎效率很低，因为它需要存储每个区块的所有状态，但是事实上以太坊的确认效率可以与比特币相提并论。原因是状态存储在树结构中（tree structure），每增加一个区块只需要改变树结构的一小部分。因此，一般而言，两个相邻的区块的树结构的大部分应该是相同的，因此存储一次数据，可以利用指针（即子树哈希）引用两次。一种被称为“帕特里夏树”（“Patricia Tree”）的树结构可以实现这一点，其中包括了对默克尔树概念的修改，不仅允许改变节点，而且还可以插入和删除节点。另外，因为所有的状态信息是最后一个区块的一部分，所以没有必要存储全部的区块历史-这一方法如果能够可以应用到比特币系统中，经计算可以对存储空间有10-20倍的节省。</p>
<h2 id="应用" tabindex="-1"> 应用</h2>
<p>一般来讲，以太坊之上有三种应用。第一类是金融应用，为用户提供更强大的用他们的钱管理和参与合约的方法。包括子货币，金融衍生品，对冲合约，储蓄钱包，遗嘱，甚至一些种类的全面的雇佣合约。第二类是半金融应用，这里有钱的存在但也有很重的非金钱的方面，一个完美的例子是为解决计算问题而设的自我强制悬赏。最后，还有在线投票和去中心化治理这样的完全的非金融应用。</p>
<h3 id="令牌系统" tabindex="-1"> 令牌系统</h3>
<p>链上令牌系统有很多应用，从代表如美元或黄金等资产的子货币到公司股票，单独的令牌代表智能资产，安全的不可伪造的优惠券，甚至与传统价值完全没有联系的用来进行积分奖励的令牌系统。在以太坊中实施令牌系统容易得让人吃惊。关键的一点是理解，所有的货币或者令牌系统，从根本上来说是一个带有如下操作的数据库：从A中减去X单位并把X单位加到B上，前提条件是(1)A在交易之前有至少X单位以及(2)交易被A批准。实施一个令牌系统就是把这样一个逻辑实施到一个合约中去。</p>
<p>用Serpent语言实施一个令牌系统的基本代码如下：</p>
<div><pre><code>def send(to, value):
    if self.storage[from] >= value:
        self.storage[from] = self.storage[from] value
        self.storage[to] = self.storage[to] + value
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>这从本质上来说是本文将要进一步描述的“银行系统”状态转变功能的一个最小化实施。需要增加一些额外的代码以提供在初始和其它一些边缘情况下分发货币的功能，理想情况下会增加一个函数让其它合约来查询一个地址的余额。就足够了。理论上，基于以太坊的充当子货币的令牌系统可能包括一个基于比特币的链上元币所缺乏的重要功能：直接用这种货币支付交易费的能力。实现这种能力的方法是在合约里维护一个以太币账户以用来为发送者支付交易费，通过收集被用来充当交易费用的内部货币并把它们在一个不断运行的拍卖中拍卖掉，合约不断为该以太币账户注资。这样用户需要用以太币“激活”他们的账户，但一旦账户中有以太币它将会被重复使用因为每次合约都会为其充值。</p>
<h3 id="金融衍生品和价值稳定的货币" tabindex="-1"> 金融衍生品和价值稳定的货币</h3>
<p>金融衍生品是“智能合约”的最普遍的应用，也是最易于用代码实现的之一。实现金融合约的主要挑战是它们中的大部分需要参照一个外部的价格发布器；例如，一个需求非常大的应用是一个用来对冲以太币（或其它密码学货币）相对美元价格波动的智能合约，但该合约需要知道以太币相对美元的价格。最简单地方法是通过由某特定机构（例如纳斯达克）维护的“数据提供“合约进行，该合约的设计使得该机构能够根据需要更新合约，并提供一个接口使得其它合约能够通过发送一个消息给该合约以获取包含价格信息的回复。</p>
<p>当这些关键要素都齐备，对冲合约看起来会是下面的样子：</p>
<ol>
<li>等待A输入1000以太币。.</li>
<li>等待B 输入1000以太币。</li>
<li>通过查询数据提供合约，将1000以太币的美元价值，例如，x美元，记录至存储器。</li>
<li>30天后，允许A或B“重新激活“合约以发送价值x美元的以太币（重新查询数据提供合约以获取新价格并计算）给A并将剩余的以太币发送给B。 这样的合约在密码学商务中有非同寻常的潜力。密码学货币经常被诟病的一个问题就是其价格的波动性；虽然大量的用户和商家可能需要密码学资产所带来的安全和便利，可他们不太会乐意面对一天中资产跌去23%价值的情形。直到现在，最为常见的推荐方案是发行者背书资产；思想是发行者创建一种子货币，对此种子货币他们有权发行和赎回，给予（线下）提供给他们一个单位特定相关资产（例如黄金，美元）的人一个单位子货币。发行者承诺当任何人送还一个单位密码学资产时。发还一个单位的相关资产。这种机制能够使任何非密码学资产被“升级“为密码学资产，如果发行者值得信任的话。 然而实践中发行者并非总是值得信任的，并且一些情况下银行体系太脆弱，或者不够诚实守信从而使这样的服务无法存在。金融衍生品提供了一种替代方案。这里将不再有提供储备以支撑一种资产的单独的发行者，取而代之的是一个由赌一种密码学资产的价格会上升的投机者构成的去中心化市场。与发行者不同，投机者一方没有讨价还价的权利，因为对冲合约把他们的储备冻结在了契约中。注意这种方法并非是完全去中心化的，因为依然需要一个可信任的提供价格信息的数据源，尽管依然有争议这依然是在降低基础设施需求（与发行者不同，一个价格发布器不需要牌照并且似乎可归为自由言论一类）和降低潜在欺诈风险方面的一个巨大的进步。</li>
</ol>
<h3 id="身份和信誉系统" tabindex="-1"> 身份和信誉系统</h3>
<p>最早的替代币，域名币，尝试使用一个类比特币块链来提供一个名称注册系统，在那里用户可以将他们的名称和其它数据一起在一个公共数据库注册。最常用的应用案例把象“<a href="http://bitcoin.org" target="_blank" rel="noopener noreferrer">bitcoin.org</a>“（或者再域名币中，”bitcoin.bit“）一样的域名与一个IP地址对应的域名系统。其它的应用案例包括电子邮件验证系统和潜在的更先进的信誉系统。这里是以太坊中提供与域名币类似的的名称注册系统的基础合约：</p>
<div><pre><code>def register(name, value):
    if !self.storage[name]:
        self.storage[name] = value
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>合约非常简单；就是一个以太坊网络中的可以被添加但不能被修改或移除的数据库。任何人都可以把一个名称注册为一个值并永远不变。一个更复杂的名称注册合约将包含允许其他合约查询的“功能条款“，以及一个让一个名称的”拥有者“（即第一个注册者）修改数据或者转让所有权的机制。甚至可以在其上添加信誉和信任网络功能。</p>
<h3 id="去中心化存储" tabindex="-1"> 去中心化存储</h3>
<p>在过去的几年里出现了一些大众化的在线文件存储初创公司，最突出的是Dropbox，它寻求允许用户上传他们的硬盘备份，提供备份存储服务并允许用户访问从而按月向用户收取费用。然而，在这一点上这个文件存储市场有时相对低效；对现存服务的粗略观察表明，特别地在“神秘谷“20-200GB这一既没有免费空间也没有企业级用户折扣的水平上，主流文件存储成本每月的价格意味着支付在一个月里支付整个硬盘的成本。以太坊合约允许去中心化存储生态的开发，这样用户通过将他们自己的硬盘或未用的网络空间租出去以获得少量收益，从而降低了文件存储的成本。</p>
<p>这样的设施的基础性构件就是我们所谓的“去中心化Dropbox合约“。这个合约工作原理如下。首先，某人将需要上传的数据分成快，对每一块数据加密以保护隐私，并且以此构建一个默克尔树。然后创建一个含以下规则的合约，每N个块，合约将从默克尔树中抽取一个随机索引（使用能够被合约代码访问的上一个块的哈希来提供随机性）， 然后给第一个实体X以太以支撑一个带有类似简化验证支付（SPV）的在树中特定索引处的块的所有权证明。当一个用户想重新下载他的文件，他可以使用微支付通道协议（例如每32k字节支付1萨博）恢复文件；从费用上讲最高效的方法是支付者不到最后不发布交易，而是用一个略微更合算的带有同样随机数的交易在每32k字节之后来代替原交易。</p>
<p>这个协议的一个重要特征是，虽然看起来象是一个人信任许多不准备丢失文件的随机节点，但是他可以通过秘密分享把文件分成许多小块，然后通过监视合同得知每个小块都还被某个节点的保存着。如果一个合约依然在付款，那么就提供了某个人依然在保存文件的证据。</p>
<h3 id="去中心化自治组织" tabindex="-1"> 去中心化自治组织</h3>
<p>通常意义上“去中心化自治组织（DAO, decentralized autonomous organization）”的概念指的是一个拥有一定数量成员或股东的虚拟实体，依靠比如67%多数来决定花钱以及修改代码。成员会集体决定组织如何分配资金。分配资金的方法可能是悬赏，工资或者更有吸引力的机制比如用内部货币奖励工作。这仅仅使用密码学块链技术就从根本上复制了传统公司或者非营利组织的法律意义以实现强制执行。至此许多围绕DAO的讨论都是围绕一个带有接受分红的股东和可交易的股份的“去中心化自治公司（DAC，decentralized autonomous corporation）”的“资本家”模式；作为替代者，一个被描述为“去中心化自治社区（decentralized autonomous community）”的实体将使所有成员都在决策上拥有同等的权利并且在增减成员时要求67%多数同意。每个人都只能拥有一个成员资格这一规则需要被群体强制实施。</p>
<p>下面是一个如何用代码实现DO的纲要。最简单地设计就是一段如果三分之二成员同意就可以自我修改的代码。虽然理论上代码是不可更改的，然而通过把代码主干放在一个单独的合约内并且把合约调用的地址指向一个可更改的存储依然可以容易地绕开障碍而使代码变得可修改，在一个这样的DAO合约的简单实现中有三种交易类型，由交易提供的数据区分：</p>
<ul>
<li><code>[0,i,K,V]</code> 注册索引为i 的对存储地址索引为K 至 v 的内容的更改建议。</li>
<li><code>[0,i]</code> 注册对建议i 的投票。</li>
<li><code>[2,i]</code> 如有足够投票则确认建议i。</li>
</ul>
<p>然后合约对每一项都有具体的条款。它将维护一个所有开放存储的更改记录以及一个谁投票表决的表。还有一个所有成员的表。当任何存储内容的更改获得了三分之二多数同意，一个最终的交易将执行这项更改。一个更加复杂的框架会增加内置的选举功能以实现如发送交易，增减成员，甚至提供委任制民主一类的投票代表（即任何人都可以委托另外一个人来代表自己投票，而且这种委托关系是可以传递的，所以如果A委托了B然后B委托了C那么C将决定A的投票）。这种设计将使DAO作为一个去中心化社区有机地成长， 使人们最终能够把挑选合适人选的任务交给专家，与当前系统不同，随着社区成员不断改变他们的站队假以时日专家会容易地出现和消失。 一个替代的模式是去中心化公司，那里任何账户可以拥有0到更多的股份，决策需要三分之二多数的股份同意。一个完整的框架将包括资产管理功能-可以提交买卖股份的订单以及接受这种订单的功能（前提是合约里有订单匹配机制）。代表依然以委任制民主的方式存在，产生了“董事会”的概念。</p>
<p>更先进的组织治理机制可能会在将来实现；现在一个去中心化组织（DO）可以从去中心化自治组织（DAO）开始描述。DO和DAO的区别是模糊的，一个大致的分割线是治理是否可以通过一个类似政治的过程或者一个“自动”过程实现，一个不错的直觉测试是“无通用语言”标准：如果两个成员不说同样的语言组织还能正常运行吗？显然，一个简单的传统的持股式公司会失败，而象比特币协议这样的却很可能成功，罗宾·汉森的“futarchy”，一个通过预测市场实现组织化治理的机制是一个真正的说明“自治”式治理可能是什么样子的好例子。注意一个人无需假设所有DAO比所有DO优越；自治只是一个在一些特定场景下有很大优势的，但在其它地方未必可行的范式，许多半DAO可能存在。</p>
<h3 id="进一步的应用" tabindex="-1"> 进一步的应用</h3>
<p>1.<strong>储蓄钱包</strong>。 假设Alice想确保她的资金安全，但她担心丢失或者被黑客盗走私钥。她把以太币放到和Bob签订的一个合约里，如下所示，这合同是一个银行：</p>
<ul>
<li>Alice单独每天最多可提取1%的资金。</li>
<li>Bob单独每天最多可提取1%的资金，但Alice可以用她的私钥创建一个交易取消Bob的提现权限。</li>
<li>Alice 和 Bob 一起可以任意提取资金。 一般来讲，每天1%对Alice足够了，如果Alice想提现更多她可以联系Bob寻求帮助。如果Alice的私钥被盗，她可以立即找到Bob把她的资金转移到一个新合同里。如果她弄丢了她的私钥，Bob可以慢慢地把钱提出。如果Bob表现出了恶意，她可以关掉他的提现权限。</li>
</ul>
<p>2.<strong>作物保险</strong>。一个人可以很容易地以天气情况而不是任何价格指数作为数据输入来创建一个金融衍生品合约。如果一个爱荷华的农民购买了一个基于爱荷华的降雨情况进行反向赔付的金融衍生品，那么如果遇到干旱，该农民将自动地收到赔付资金而如果有足量的降雨他会很开心因为他的作物收成会很好。</p>
<p>3.<strong>一个去中心化的数据发布器</strong>。 对于基于差异的金融合约，事实上通过过“谢林点”协议将数据发布器去中心化是可能的。谢林点的工作原理如下：N方为某个指定的数据提供输入值到系统（例如ETH/USD价格），所有的值被排序，每个提供25%到75%之间的值的节点都会获得奖励，每个人都有激励去提供他人将提供的答案，大量玩家可以真正同意的答案明显默认就是正确答案，这构造了一个可以在理论上提供很多数值，包括ETH/USD价格，柏林的温度甚至某个特别困难的计算的结果的去中心化协议。</p>
<p>4.<strong>多重签名智能契约</strong>。比特币允许基于多重签名的交易合约，例如，5把私钥里集齐3把就可以使用资金。以太坊可以做得更细化，例如，5把私钥里集齐4把可以花全部资金，如果只3把则每天最多花10%的资金，只有2把就只能每天花0.5%的资金。另外，以太坊里的多重签名是异步的，意思是说，双方可以在不同时间在区块链上注册签名，最后一个签名到位后就会自动发送交易。</p>
<p>5.<strong>云计算</strong>。EVM技术还可被用来创建一个可验证的计算环境，允许用户邀请他人进行计算然后选择性地要求提供在一定的随机选择的检查点上计算被正确完成的证据。这使得创建一个任何用户都可以用他们的台式机，笔记本电脑或者专用服务器参与的云计算市场成为可能，现场检查和安全保证金可以被用来确保系统是值得信任的（即没有节点可以因欺骗获利）。虽然这样一个系统可能并不适用所有任务；例如，需要高级进程间通信的任务就不易在一个大的节点云上完成。然而一些其它的任务就很容易实现并行；SETI@home, folding@home和基因算法这样的项目就很容易在这样的平台上进行。</p>
<p>6.<strong>点对点赌博</strong>。任意数量的点对点赌博协议都可以搬到以太坊的区块链上，例如Frank Stajano和Richard Clayton的Cyberdice。 最简单的赌博协议事实上是这样一个简单的合约，它用来赌下一个区块的哈稀值与猜测值之间的差额, 据此可以创建更复杂的赌博协议，以实现近乎零费用和无欺骗的赌博服务。</p>
<p>7.<strong>预测市场</strong>。 不管是有神谕还是有谢林币，预测市场都会很容易实现，带有谢林币的预测市场可能会被证明是第一个主流的作为去中心化组织管理协议的“futarchy”应用。</p>
<p>8.链上去中心化市场，以身份和信誉系统为基础。</p>
<h2 id="杂项和关注" tabindex="-1"> 杂项和关注</h2>
<h3 id="改进版幽灵协议的实施" tabindex="-1"> 改进版幽灵协议的实施</h3>
<p>“幽灵“协议（&quot;Greedy Heaviest Observed Subtree&quot; (GHOST) protocol）是由Yonatan Sompolinsky 和 Aviv Zohar在2013年12月引入的创新。幽灵协议提出的动机是当前快速确认的块链因为区块的高作废率而受到低安全性困扰；因为区块需要花一定时间（设为t）扩散至全网，如果矿工A挖出了一个区块然后矿工B碰巧在A的区块扩散至B之前挖出了另外一个区块，矿工B的区块就会作废并且没有对网络安全作出贡献。此外，这里还有中心化问题：如果A是一个拥有全网30%算力的矿池而B拥有10%的算力，A将面临70%的时间都在产生作废区块的风险而B在90%的时间里都在产生作废区块。因此，如果作废率高，A将简单地因为更高的算力份额而更有效率，综合这两个因素，区块产生速度快的块链很可能导致一个矿池拥有实际上能够控制挖矿过程的算力份额。</p>
<p>正如Sompolinsky 和 Zohar所描述的，通过在计算哪条链“最长”的时候把废区块也包含进来，幽灵协议解决了降低网络安全性的第一个问题；这就是说，不仅一个区块的父区块和更早的祖先块，祖先块的作废的后代区块（以太坊术语中称之为“叔区块”）也被加进来以计算哪一个区块拥有支持其的最大工作量证明。我们超越了Sompolinsky 和 Zohar所描述的协议以解决第二个问题 – 中心化倾向，以太坊付给以“叔区块”身份为新块确认作出贡献的废区块87.5%的奖励，把它们纳入计算的“侄子区块”将获得奖励的12.5%，不过，交易费用不奖励给叔区块。 以太坊实施了一个只下探到第五层的简化版本的幽灵协议。其特点是，废区块只能以叔区块的身份被其父母的第二代至第五代后辈区块，而不是更远关系的后辈区块（例如父母区块的第六代后辈区块，或祖父区块的第三代后辈区块）纳入计算。这样做有几个原因。首先，无条件的幽灵协议将给计算给定区块的哪一个叔区块合法带来过多的复杂性。其次，带有以太坊所使用的补偿的无条件的幽灵协议剥夺了矿工在主链而不是一个公开攻击者的链上挖矿的激励。最后，计算表明带有激励的五层幽灵协议即使在出块时间为15s的情况下也实现了了95%以上的效率，而拥有25%算力的矿工从中心化得到的益处小于3%。</p>
<h3 id="费用" tabindex="-1"> 费用</h3>
<p>因为每个发布的到区块链的交易都占用了下载和验证的成本，需要有一个包括交易费的规范机制来防范滥发交易。比特币使用的默认方法是纯自愿的交易费用，依靠矿工担当守门人并设定动态的最低费用。因为这种方法是“基于市场的”，使得矿工和交易发送者能够按供需来决定价格，所以这种方法在比特币社区被很顺利地接受了。然而，这个逻辑的问题在于，交易处理并非一个市场；虽然根据直觉把交易处理解释成矿工给发送者提供的服务是很有吸引力的，但事实上一个矿工收录的交易是需要网络中每个节点处理的，所以交易处理中最大部分的成本是由第三方而不是决定是否收录交易的矿工承担的。于是，非常有可能发生公地悲剧。</p>
<p>然而，当给出一个特殊的不够精确的简化假设时，这个基于市场的机制的漏洞很神奇地消除了自己的影响。论证如下。假设：</p>
<ol>
<li>一个交易带来 k 步操作, 提供奖励 kR给任何收录该交易的矿工，这里 R 由交易发布者设定， k 和 R 对于矿工都是事先（大致上）可见的。</li>
<li>每个节点处理每步操作的成本都是 C (即所有节点的效率一致)。</li>
<li>有 N 个挖矿节点，每个算力一致(即全网算力的1/N)。</li>
<li>没有不挖矿的全节点。</li>
</ol>
<p>当预期奖励大于成本时，矿工愿意挖矿。这样，因为矿工有1/N 的机会处理下一个区块，所以预期的收益是 kR/N , 矿工的处理成本简单为 kC. 这样当 kR/N &gt; kC， 即 R &gt; NC时。矿工愿意收录交易。注意 R 是由交易发送者提供的每步费用，是矿工从处理交易中获益的下限。 NC 是全网处理一个操作的成本。所以，矿工仅有动机去收录那些收益大于成本的交易。 然而，这些假设与实际情况有几点重要的偏离：</p>
<ol>
<li>因为额外的验证时间延迟了块的广播因而增加了块成为废块的机会，处理交易的矿工比其它的验证节点付出了更高的成本。</li>
<li>不挖矿的全节点是存在的。</li>
<li>实践中算力分布可能最后是极端不平均的。</li>
<li>以破坏网络为己任的投机者，政敌和疯子确实存在，并且他们能够聪明地设置合同使得他们的成本比其它验证节点低得多。 上面第1点驱使矿工收录更少的交易，第2点增加了 NC; 因此这两点的影响至少部分互相抵消了. 第3点和第4点是主要问题；作为解决方案我们简单地建立了一个浮动的上限：没有区块能够包含比BLK_LIMIT_FACTOR 倍长期指数移动平均值更多的操作数。具体地：</li>
</ol>
<div><pre><code>blk.oplimit = floor((blk.parent.oplimit * (EMAFACTOR - 1) + floor(parent.opcount * BLK_LIMIT_FACTOR)) /EMA_FACTOR)
</code></pre><div aria-hidden="true"><div></div></div></div><p>BLK_LIMIT_FACTOR 和 EMA_FACTOR 是暂且被设为 65536 和 1.5 的常数，但可能会在更深入的分析后调整。 回复</p>
<h3 id="计算和图灵完备" tabindex="-1"> 计算和图灵完备</h3>
<p>需要强调的是以太坊虚拟机是图灵完备的； 这意味着EVM代码可以实现任何可以想象的计算，包括无限循环。EVM代码有两种方式实现循环。首先， JUMP 指令可以让程序跳回至代码前面某处，还有允许如 <code>while x &lt; 27: x = x * 2</code> 一样的条件语句的JUMPI 指令实现条件跳转。其次，合约可以调用其它合约，有通过递归实现循环的潜力。这很自然地导致了一个问题：恶意用户能够通过迫使矿工和全节点进入无限循环而不得不关机吗？ 这问题出现是因为计算机科学中一个叫停机问题的问题：一般意义上没有办法知道，一个给定的程序是否能在有限的时间内结束运行。</p>
<p>正如在状态转换章节所述，我们的方案通过为每一个交易设定运行执行的最大计算步数来解决问题，如果超过则计算被恢复原状但依然要支付费用。消息以同样的方式工作。为显示这一方案背后的动机，请考虑下面的例子：</p>
<ul>
<li>一个攻击者创建了一个运行无限循环的合约，然后发送了一个激活循环的交易给矿工，矿工将处理交易，运行无限循环直到瓦斯耗尽。即使瓦斯耗尽交易半途停止，交易依然正确（回到原处）并且矿工依然从攻击者哪里挣到了每一步计算的费用。</li>
<li>一个攻击者创建一个非常长的无限循环意图迫使矿工长时间内一直计算致使在计算结束前若干区块已经产生于是矿工无法收录交易以赚取费 用。然而，攻击者需要发布一个 STARTGAS 值以限制可执行步数，因而矿工将提前知道计算将耗费过多的步数。</li>
<li>一个攻击者看到一个包含诸如 send(A,self.storage); self.storage = 0格式的合约然后发送带有只够执行第一步的费用的而不够执行第二步的交易（即提现但不减少账户余额）。合约作者无需担心防卫类似攻击，因为如果执行中途停止则所有变更都被回复。</li>
<li>一个金融合约靠提取九个专用数据发布器的中值来工作以最小化风险，一个攻击者接管了其中一个数据提供器，然后把这个按DAO章节所述的可变地址调用机制设计成可更改的数据提供器转为运行一个无限循环，以求尝试逼迫任何从此金融合约索要资金的尝试都会因瓦斯耗尽而中止。然而，该金融合约可以在消息里设置瓦斯限制以防范此类问题。 图灵完备的替代是图灵不完备，这里 JUMP 和 JUMPI 指令不存在并且在某个给定时间每个合约只允许有一个拷贝存在于调用堆栈内。在这样的系统里，上述的费用系统和围绕我们的方案的效率的不确定性可能都是不需要的，因为执行一个合约的成本将被它的大小决定。此外，图灵不完备甚至不是一个大的限制，在我们内部设想的所有合约例子中，至今只有一个需要循环，而且即使这循环也可以被26个单行代码段的重复所代替。考虑到图灵完备带来的严重的麻烦和有限的益处，为什么不简单地使用一种图灵不完备语言呢？事实上图灵不完备远非一个简洁的解决方案。为什么？请考虑下面的合约：</li>
</ul>
<div><pre><code>C0: call(C1); call(C1);
C1: call(C2); call(C2);
C2: call(C3); call(C3);
...
C49: call(C50); call(C50);
C50: (作一个图灵机的步计算和记录结果在合约的长期存储)
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>现在，发送一个这样的交易给A，这样，在51个交易中，我们有了一个需要花费2^50 步计算的合约，矿工可能尝试通过为每一个合约维护一个最高可执行步数并且对于递归调用其它合约的合约计算可能执行步数从而预先检测这样的逻辑炸弹，但是这会使矿工禁止创建其它合约的合约（因为上面26个合约的创建和执行可以很容易地放入一个单独合约内）。另外一个问题点是一个消息的地址字段是一个变量，所以通常来讲可能甚至无法预先知道一个合约将要调用的另外一个合约是哪一个。于是，最终我们有了一个惊人的结论：图灵完备的管理惊人地容易，而在缺乏同样的控制时图灵不完备的管理惊人地困难- 那为什么不让协议图灵完备呢？</p>
<h3 id="货币和发行" tabindex="-1"> 货币和发行</h3>
<p>以太坊网络包含自身的内置货币以太币，以太币扮演双重角色，为各种数字资产交易提供主要的流动性，更重要的是提供了了支付交易费用的一种机制。为便利及避免将来的争议期间（参见当前的mBTC/uBTC/聪的争论），不同面值的名称将被提前设置：</p>
<ul>
<li>1: 伟</li>
<li>10^12: 萨博</li>
<li>10^15: 芬尼</li>
<li>10^18: 以太</li>
</ul>
<p>这应该被当作是“元”和“分”或者“比特币”和“聪”的概念的扩展版，在不远的将来，我们期望“以太”被用作普通交易，“芬尼”用来进行微交易，“萨博”和“伟”用来进行关于费用和协议实施的讨论。</p>
<p>发行模式如下：</p>
<ul>
<li>通过发售活动，以太币将以每BTC 1337-2000以太的价格发售，一个旨在为以太坊组织筹资并且为开发者支付报酬的机制已经在其它一些密码学货币平台上成功使用。早期购买者会享受较大的折扣，发售所得的BTC将完全用来支付开发者和研究者的工资和悬赏，以及投入密码学货币生态系统的项目。</li>
<li>0.099x （x为发售总量）将被分配给BTC融资或其它的确定性融资成功之前参与开发的早期贡献者，另外一个0.099x将分配给长期研究项目。</li>
<li>自上线时起每年都将有0.26x（x为发售总量）被矿工挖出。</li>
</ul>
<h3 id="发行分解" tabindex="-1"> 发行分解</h3>
<p>永久线性增长模型降低了在比特币中出现的财富过于集中的风险，并且给予了活在当下和将来的人公平的机会去获取货币，同时保持了对获取和持有以太币的激励，因为长期来看“货币供应增长率”是趋于零的。我们还推断，随着时间流逝总会发生因为粗心和死亡等原因带来的币的遗失，假设币的遗失是每年货币供应量的一个固定比例，则最终总的流通中的货币供应量会稳定在一个等于年货币发行量除以遗失率的值上（例如，当遗失率为1%时，当供应量达到30x时，每年有0.3x被挖出同时有0.3x丢失，达到一个均衡）。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Group</th>
<th style="text-align:left">At launch</th>
<th style="text-align:left">After 1 year</th>
<th style="text-align:left">After 5 years</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Currency units</td>
<td style="text-align:left">1.198X</td>
<td style="text-align:left">1.458X</td>
<td style="text-align:left">2.498X</td>
</tr>
<tr>
<td style="text-align:left">Purchasers</td>
<td style="text-align:left">83.5%</td>
<td style="text-align:left">68.6%</td>
<td style="text-align:left">40.0%</td>
</tr>
<tr>
<td style="text-align:left">Reserve spent pre-sale</td>
<td style="text-align:left">8.26%</td>
<td style="text-align:left">6.79%</td>
<td style="text-align:left">3.96%</td>
</tr>
<tr>
<td style="text-align:left">Reserve used post-sale</td>
<td style="text-align:left">8.26%</td>
<td style="text-align:left">6.79%</td>
<td style="text-align:left">3.96%</td>
</tr>
<tr>
<td style="text-align:left">Miners</td>
<td style="text-align:left">0%</td>
<td style="text-align:left">17.8%</td>
<td style="text-align:left">52.0%</td>
</tr>
</tbody>
</table>
<p>除了线性的发行方式外，和比特币一样以太币的的供应量增长率长期来看也趋于零。</p>
<p><img src="http://bitcoin8btc.qiniudn.com/wp-content/uploads/2014/10/supply.png" alt="img"></p>
<h3 id="挖矿的中心化" tabindex="-1"> 挖矿的中心化</h3>
<p>比特币挖矿算法基本上是让矿工千万次地轻微改动区块头，直到最终某个节点的改动版本的哈希小于目标值（目前是大约2190）。然而，这种挖矿算法容易被两种形式的中心化攻击。第一种，挖矿生态系统被专门设计的因而在比特币挖矿这一特殊任务上效率提高上千倍的ASICs（专用集成电路）和电脑芯片控制。这意味着比特币挖矿不再是高度去中心化的和追求平等主义的，而是需要巨额资本的有效参与。第二种，大部分比特币矿工事实上不再在本地完成区块验证；而是依赖中心化的矿池提供区块头。这个问题可以说很严重：在本文写作时，最大的两个矿池间接地控制了大约全网50%的算力，虽然当一个矿池或联合体尝试51%攻击时矿工可以转换到其它矿池这一事实减轻了问题的严重性。</p>
<p>以太坊现在的目的是使用一个基于为每1000个随机数随机产生唯一哈希的函数的挖矿算法，用足够宽的计算域，去除专用硬件的优势。这样的策略当然不会使中心化的收益减少为零，但是也不需要。注意每单个用户使用他们的私人笔记本电脑或台式机就可以几乎免费地完成一定量的挖矿活动，但当到了100%的CPU使用率之后更多地挖矿就会需要他们支付电力和硬件成本。ASIC挖矿公司需要从第一个哈希开始就为电力和硬件支付成本。所以，如果中心化收益能够保持在(E + H) /E 以下，那么即使ASICs被制造出来普通矿工依然有生存空间。另外，我们计划将挖矿算法设计成挖矿需要访问整个区块链，迫使矿工存储完成的区块链或者至少能够验证每笔交易。这去除了对中心化矿池的需要；虽然矿池依然可以扮演平滑收益分配的随机性的角色，但这功能可以被没有中心化控制的P2P矿池完成地同样好。这样即使大部分普通用户依然倾向选择轻客户端，通过增加网络中的全节点数量也有助于抵御中心化。</p>
<h3 id="扩展性" tabindex="-1"> 扩展性</h3>
<p>扩展性问题是以太坊常被关注的地方，与比特币一样，以太坊也遭受着每个交易都需要网络中的每个节点处理这一困境的折磨。比特币的当前区块链大小约为20GB，以每小时1MB的速度增长。如果比特币网络处理Visa级的2000tps的交易，它将以每三秒1MB的速度增长（1GB每小时，8TB每年）。以太坊可能也会经历相似的甚至更糟的增长模式，因为在以太坊区块链之上还有很多应用，而不是像比特币只是简单的货币，但以太坊全节点只需存储状态而不是完整的区块链历史这一事实让情况得到了改善。</p>
<p>大区块链的问题是中心化风险。如果块链大小增加至比如100TB，可能的场景将是只有非常小数目的大商家会运行全节点，而常规用户使用轻的SPV节点。这会增加对全节点合伙欺诈牟利（例如更改区块奖励，给他们自己BTC）的风险的担忧。轻节点将没有办法立刻检测到这种欺诈。当然，至少可能存在一个诚实的全节点，并且几个小时之后有关诈骗的信息会通过Reddit这样的渠道泄露，但这时已经太晚：任凭普通用户做出怎样的努力去废除已经产生的区块，他们都会遇到与发动一次成功的51%攻击同等规模的巨大的不可行的协调问题。在比特币这里，现在这是一个问题，但Peter Todd建议的一个改动可以缓解这个问题。</p>
<p>近期，以太坊会使用两个附加的策略以应对此问题。首先，因为基于区块链的挖矿算法，至少每个矿工会被迫成为一个全节点，这保证了一定数量的全节点。其次，更重要的是，处理完每笔交易后，我们会把一个中间状态树的根包含进区块链。即使区块验证是中心化的，只要有一个诚实的验证节点存在，中心化的问题就可以通过一个验证协议避免。如果一个矿工发布了一个不正确的区块，这区块要么是格式错，要么状态S[n]是错的。因为S[0]是正确的，必然有第一个错误状态S[i]但S[i-1]是正确的，验证节点将提供索引i，一起提供的还有处理APPLY(S[i-1],TX[i]) -&gt; S[i]所需的帕特里夏树节点的子集。这些节点将受命进行这部分计算，看产生的S[i]与先前提供的值是否一致。</p>
<p>另外，更复杂的是恶意矿工发布不完整区块进行攻击，造成没有足够的信息去确定区块是否正确。解决方案是质疑-回应协议：验证节点对目标交易索引发起质疑，接受到质疑信息的轻节点会对相应的区块取消信任，直到另外一个矿工或者验证者提供一个帕特里夏节点子集作为正确的证据。</p>
<h2 id="综述-去中心化应用" tabindex="-1"> 综述：去中心化应用</h2>
<p>上述合约机制使得任何一个人能够在一个虚拟机上建立通过全网共识来运行命令行应用（从根本上来说是），它能够更改一个全网可访问的状态作为它的“硬盘”。然而，对于多数人来说，用作交易发送机制的命令行接口缺乏足够的用户友好使得去中心化成为有吸引力的替代方案。最后，一个完整的“去中心化应用”应该包括底层的商业逻辑组件【无论是否在以太坊完整实施，使用以太坊和其它系统组合（如一个P2P消息层，其中一个正在计划放入以太坊客户端）或者仅有其它系统的方式】和上层的图形用户接口组件。以太坊客户端被设计成一个网络浏览器，但包括对“eth” Javascript API对象的支持，可被客户端里看到的特定的网页用来与以太坊区块链交互。从“传统”网页的角度看来，这些网页是完全静态的内容，因为区块链和其它去中心化协议将完全代替服务器来处理用户发起的请求。最后，去中心化协议有希望自己利用某种方式使用以太坊来存储网页。</p>
<h2 id="结论" tabindex="-1"> 结论</h2>
<p>以太坊协议最初是作为一个通过高度通用的语言提供如链上契约，提现限制和金融合约，赌博市场等高级功能的升级版密码学货币来构思的。以太坊协议将不直接“支持”任何应用，但图灵完备编程语言的存在意味着理论上任意的合约都可以为任何交易类型和应用创建出来。然而关于以太坊更有趣的是，以太坊协议比单纯的货币走得更远，围绕去中心化存储，去中心化计算和去中心化预测市场以及数十个类似概念建立的协议和去中心化应用，有潜力从根本上提升计算行业的效率，并通过首次添加经济层为其它的P2P协议提供有力支撑，最终，同样会有大批与金钱毫无关系的应用出现。</p>
<p>以太坊协议实现的任意状态转换概念提供了一个具有独特潜力的平台；与封闭式的，为诸如数据存储，赌博或金融等单一目的设计的协议不同，以太坊从设计上是开放式的，并且我们相信它极其适合作为基础层服务于在将来的年份里出现的极其大量的金融和非金融协议。</p>
<h2 id="注解与进阶阅读" tabindex="-1"> 注解与进阶阅读</h2>
<h3 id="注解" tabindex="-1"> 注解</h3>
<p>1.一个有经验的读者会注意到事实上比特币地址是椭圆曲线公钥的哈希，而非公钥本身，然而事实上从密码学术语角度把公钥哈希称为公钥完全合理。这是因为比特币密码学可以被认为是一个定制的数字签名算法，公钥由椭圆曲线公钥的哈希组成，签名由椭圆曲线签名连接的椭圆曲线公钥组成，而验证算法包括用作为公钥提供的椭圆曲线公钥哈希来检查椭圆曲线公钥，以及之后的用椭圆曲线公钥来验证椭圆曲线签名。</p>
<p>2.技术上来说，前11个区块的中值。</p>
<p>3.在内部，2和“CHARLIE”都是数字，后一个有巨大的base256编码格式，数字可以从0到2^256-1。</p>
<h3 id="进阶阅读" tabindex="-1"> 进阶阅读</h3>
<ol>
<li>Intrinsic value: <a href="https://tinyurl.com/BitcoinMag-IntrinsicValue" target="_blank" rel="noopener noreferrer">https://tinyurl.com/BitcoinMag-IntrinsicValue</a></li>
<li>Smart property: <a href="https://en.bitcoin.it/wiki/Smart_Property" target="_blank" rel="noopener noreferrer">https://en.bitcoin.it/wiki/Smart_Property</a></li>
<li>Smart contracts: <a href="https://en.bitcoin.it/wiki/Contracts" target="_blank" rel="noopener noreferrer">https://en.bitcoin.it/wiki/Contracts</a></li>
<li>B-money: <a href="http://www.weidai.com/bmoney.txt" target="_blank" rel="noopener noreferrer">http://www.weidai.com/bmoney.txt</a></li>
<li>Reusable proofs of work: <a href="http://www.finney.org/~hal/rpow/" target="_blank" rel="noopener noreferrer">http://www.finney.org/~hal/rpow/</a></li>
<li>Secure property titles with owner authority: <a href="http://szabo.best.vwh.net/securetitle.html" target="_blank" rel="noopener noreferrer">http://szabo.best.vwh.net/securetitle.html</a></li>
<li>Bitcoin whitepaper: <a href="http://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener noreferrer">http://bitcoin.org/bitcoin.pdf</a></li>
<li>Namecoin: <a href="https://namecoin.org/" target="_blank" rel="noopener noreferrer">https://namecoin.org/</a></li>
<li>Zooko’s triangle: <a href="http://en.wikipedia.org/wiki/Zooko%E2%80%99s_triangle" target="_blank" rel="noopener noreferrer">http://en.wikipedia.org/wiki/Zooko’s_triangle</a></li>
<li>Colored coins whitepaper: <a href="https://tinyurl.com/coloredcoin-whitepaper" target="_blank" rel="noopener noreferrer">https://tinyurl.com/coloredcoin-whitepaper</a></li>
<li>Mastercoin whitepaper: <a href="https://github.com/mastercoin-MSC/spec" target="_blank" rel="noopener noreferrer">https://github.com/mastercoin-MSC/spec</a></li>
<li>Decentralized autonomous corporations, Bitcoin Magazine: <a href="https://tinyurl.com/Bootstrapping-DACs" target="_blank" rel="noopener noreferrer">https://tinyurl.com/Bootstrapping-DACs</a></li>
<li>Simplified payment verification:<a href="https://en.bitcoin.it/wiki/Scalability#Simplifiedpaymentverification" target="_blank" rel="noopener noreferrer">https://en.bitcoin.it/wiki/Scalability#Simplifiedpaymentverification</a></li>
<li>Merkle trees: <a href="http://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="noopener noreferrer">http://en.wikipedia.org/wiki/Merkle_tree</a></li>
<li>Patricia trees: <a href="http://en.wikipedia.org/wiki/Patricia_tree" target="_blank" rel="noopener noreferrer">http://en.wikipedia.org/wiki/Patricia_tree</a></li>
<li>GHOST: <a href="http://www.cs.huji.ac.il/~avivz/pubs/13/btc_scalability_full.pdf" target="_blank" rel="noopener noreferrer">http://www.cs.huji.ac.il/~avivz/pubs/13/btc_scalability_full.pdf</a></li>
<li>StorJ and Autonomous Agents, Jeff Garzik: <a href="https://tinyurl.com/storj-agents" target="_blank" rel="noopener noreferrer">https://tinyurl.com/storj-agents</a></li>
<li>Mike Hearn on Smart Property at Turing Festival: <a href="http://www.youtube.com/watch?v=Pu4PAMFPo5Y" target="_blank" rel="noopener noreferrer">http://www.youtube.com/watch?v=Pu4PAMFPo5Y</a></li>
<li>Ethereum RLP: <a href="https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP" target="_blank" rel="noopener noreferrer">https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP</a></li>
<li>Ethereum Merkle Patricia trees: <a href="https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-Patricia-Tree" target="_blank" rel="noopener noreferrer">https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-Patricia-Tree</a></li>
<li>Peter Todd on Merkle sum trees:<a href="http://sourceforge.net/p/bitcoin/mailman/message/31709140/" target="_blank" rel="noopener noreferrer">http://sourceforge.net/p/bitcoin/mailman/message/31709140/</a></li>
</ol>
]]></content:encoded>
      <enclosure url="http://upyun-assets.ethfans.org/uploads/photo/image/ed77a88675204904984a696a55e2254e.png" type="image/png"/>
    </item>
    <item>
      <title>主流区块链研究</title>
      <link>https://bytecodes.tech/blockchain/male-chain-research/</link>
      <guid>https://bytecodes.tech/blockchain/male-chain-research/</guid>
      <source url="https://bytecodes.tech/rss.xml">主流区块链研究</source>
      <category>区块链学习</category>
      <pubDate>Sun, 25 Dec 2022 02:12:30 GMT</pubDate>
    </item>
  </channel>
</rss>