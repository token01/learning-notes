import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as s,c as d,a as e,d as l,w as h,b as a,e as i,r}from"./app.63c04501.js";const c={},u=i('<h2 id="缓存-cache" tabindex="-1"><a class="header-anchor" href="#缓存-cache" aria-hidden="true">#</a> 缓存 cache</h2><h2 id="cache-aside-pattern" tabindex="-1"><a class="header-anchor" href="#cache-aside-pattern" aria-hidden="true">#</a> Cache Aside Pattern</h2><p>缓存+数据库读写的模式</p><ul><li>读数据：先查缓存，不过不存在，查数据库，并更新缓存。</li><li>更新数据：先更新数据库，再删除缓存。 <blockquote><p>1 . 直接删除就行，不要更新缓存。缓存的数据可能是数据库取出后需要进行业务整合的，应该在查数据的时候再做此操作，提高更新性能。<br> 还有可能此数据更新比较频繁，更新了10次，却只查了2次。那么如果你每次更新数据的时候都重新更新缓存，则非常浪费资源。hibernate的lazy加载有点类似，只要需要的时候才去加载。<br> 2 . 顺序不应颠倒。在高并发下可能会发生缓存了旧数据的情况，导致数据不一致。 一个更新操作过来后，如果先删除缓存，在执行更新数据库逻辑时，另一个线程来查询，发现缓存没数据，去数据库取出了还未更新的旧数据，然后放置缓存，就发生了数据不一致问题。</p></blockquote></li></ul><h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透" aria-hidden="true">#</a> 缓存穿透</h2><p>大多情况下缓存key是以ID为基础设置的，那么黑客故意删除他的一条数据，并记住这个ID，或者使用任意方式查询一个不存在的ID，比如，自增ID，使用负数取查询等等。那么他使用这个ID去查数据，缓存为空，导致查数据库，还是空，缓存不更新，那么他每次请求都能穿透缓存进入数据库。导致所有流量全部打入数据库，导致数据库重压甚至奔溃。<br> 当然整体的系统设计还会加上API网关进行限流，熔断，黑名单，参数合法验证等保护措施，不一致压垮，但必定还是会受到影响。<br><strong>解决方案：</strong></p>',6),_=e("li",null,"对查询出来为空的数据也设置缓存。设置一个常量，标志是空数据，并设置过期时间，在未过期之前，不用担心被穿透的问题。这种方法非常简单，高效，但存在一棒子打死全部的问题，缓存的过期时间设置也是非常难判断，时间短导致穿透次数的增加，数据库压力的增加；时间长，可能会影响正常数据的查询。所以还是推荐上面的那种解决方案。",-1),b=i('<h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h2><h3 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h3><ul><li>基本数据类型：字符串String、字典Hash、列表List、集合Set、有序集合SortedSet</li><li>HyperLogLog、Geo、Pub/Sub</li><li>Redis Module ： BloomFilter, RedisSearch, Redis-ML, BitMap</li></ul><h3 id="淘汰策略" tabindex="-1"><a class="header-anchor" href="#淘汰策略" aria-hidden="true">#</a> 淘汰策略</h3><p>当 Redis 用于缓存的内存不足时，需要怎么处理。就是根据淘汰策略决定的</p><ul><li><strong>noeviction</strong>：新写入操作会报错。</li><li><strong>allkeys-lru</strong>：在键空间中，移除最近最少使用 (less recently used ,LRU) 的key。</li><li><strong>allkeys-random</strong>：在键空间中，随机移除某个key。</li><li><strong>allkeys-lfu</strong> ： LFU （Least Frequently Used）最不常用的</li><li><strong>volatile-lfu</strong> ：在设置了过期时间的键空间中，移除最不常用的</li><li><strong>volatile-lru</strong>：在设置了过期时间的键空间中，移除最近最少使用的key。</li><li><strong>volatile-random</strong>：在设置了过期时间的键空间中，随机移除某个key。</li><li><strong>volatile-ttl</strong>：在设置了过期时间的键空间中，有更早过期时间(time to live,TTL) 的key优先移除。</li></ul>',6),g={href:"https://github.com/antirez/redis/blob/unstable/redis.conf#L841",target:"_blank",rel:"noopener noreferrer"},m=e("code",null,"redis.cnf",-1),p=i(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>maxmemory-policy noeviction
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="持久化机制" tabindex="-1"><a class="header-anchor" href="#持久化机制" aria-hidden="true">#</a> 持久化机制</h3><ul><li>RDB：快照形式是直接把内存中的数据保存到一个 dump 的文件中，定时保存。（默认机制）</li><li>AOF：把所有的对 Redis 的服务器进行修改的命令都存到一个文件里。</li><li>混合模式：since Redis4.0</li></ul><h3 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h3><ul><li>分布式锁</li></ul>`,5);function f(k,x){const t=r("RouterLink"),n=r("ExternalLinkIcon");return s(),d("div",null,[u,e("ul",null,[e("li",null,[l(t,{to:"/algorithm/BloomFilter.html"},{default:h(()=>[a("BloomFilter")]),_:1}),a("，BitMap")]),_]),b,e("p",null,[a("默认是抛出异常 "),e("a",g,[m,l(n)])]),p])}const L=o(c,[["render",f],["__file","缓存.html.vue"]]);export{L as default};
