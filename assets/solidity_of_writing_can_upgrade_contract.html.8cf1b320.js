import{_ as t}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as l,c as i,a as e,b as r,d as n,e as s,r as o}from"./app.c2a49a29.js";const c={},d=s(`<p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h7kse3u0fkj31g80t012r.jpg" alt="image-20221028102022991" loading="lazy"></p><h2 id="为什么要编写可升级合约" tabindex="-1"><a class="header-anchor" href="#为什么要编写可升级合约" aria-hidden="true">#</a> 为什么要编写可升级合约</h2><p>默认情况下，以太坊中的智能合约是不可变的。但是一旦项目方提前发现合约漏洞或者想升级功能，是需要合约可以变动的，因此一开始编写可升级的合约是重要的。因此我们使用OpenZeppelin Upgrades插件来实现我们可升级合约的目的。</p><h2 id="合约升级原理" tabindex="-1"><a class="header-anchor" href="#合约升级原理" aria-hidden="true">#</a> 合约升级原理</h2><p>当您创建一个新的可升级合约实例时， 实际上部署了三个合约：</p><ol><li>您编写的合约，称为包含逻辑的实现合约</li><li>代理的管理员合约</li><li>代理合约，实际和用户交互的、</li></ol><p>代理合约会把所有的调用委托给实现合约，代理持有状态数据，而实现合约提供代码。同时它还允许我们通过将代理委托给不同的实现合约来更改代码。从而实现了状态数据和实现的解耦。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h7kuengsfrj313s04yaa9.jpg" alt="image-20221028113002214" loading="lazy"></p><p>代理需要解决的最直接的问题是代理如何公开逻辑合约的整个接口，而不需要对整个逻辑合约的接口进行一对一的映射。这将难以维护，容易出错，并且会使接口本身无法升级。因此，需要动态转发机制。下面的代码介绍了这种机制的基础知识：</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>assembly {
  let ptr := mload(0x40)
  // (1) copy incoming call data
  calldatacopy(ptr, 0, calldatasize)
  // (2) forward call to logic contract
  let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
  let size := returndatasize
  // (3) retrieve return data
  returndatacopy(ptr, 0, size)
  // (4) forward return data back to caller
  switch result
  case 0 { revert(ptr, size) }
  default { return(ptr, size) }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此代码可以放在代理的回退函数中，并将对具有任何参数集的任何函数的任何调用转发到逻辑合约，而无需知道任何特别是逻辑合约的接口。本质上，（1） calldata复制到内存，（2）调用被转发到逻辑合约，（3）从调用到逻辑合约的返回数据被检索，以及（4）返回的数据被转发回来给来电者。</p><p>需要注意的一件非常重要的事情是，代码使用了 EVM 的 操作码，该操作码在调用者状态的上下文中执行被调用者的代码。也就是 说，逻辑合约控制着代理的状态，逻辑合约的状态是没有意义的。因此，代理不仅在逻辑合约之间转发交易，而且还代表交易对的状态。状态在代理中，逻辑在代理指向的特定实现中，详细的说明请参考官方文档。</p><h2 id="透明代理" tabindex="-1"><a class="header-anchor" href="#透明代理" aria-hidden="true">#</a> 透明代理</h2><h2 id="uups" tabindex="-1"><a class="header-anchor" href="#uups" aria-hidden="true">#</a> UUPS</h2>`,14),p={href:"https://mshk.top/2022/06/solidity-hardhot-erc721-erc1822-erc1976-openzeppelin/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://learnblockchain.cn/article/4534",target:"_blank",rel:"noopener noreferrer"},u={href:"https://mirror.xyz/xyyme.eth/kM9ld2u0D1BpHAfXTiaSPGPtDnOd6vrxJ5_tW4wZVBk",target:"_blank",rel:"noopener noreferrer"},_=e("h2",{id:"参考",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考","aria-hidden":"true"},"#"),r(" 参考")],-1),g={href:"https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies#the-constructor-caveat",target:"_blank",rel:"noopener noreferrer"},m={href:"https://blog.csdn.net/Tesla_Zhou/article/details/111743243",target:"_blank",rel:"noopener noreferrer"},v={href:"https://learnblockchain.cn/article/4282",target:"_blank",rel:"noopener noreferrer"},b={href:"https://docs.openzeppelin.com/upgrades-plugins/1.x/api-hardhat-upgrades",target:"_blank",rel:"noopener noreferrer"},f={href:"https://xiaozhuanlan.com/topic/1762043598",target:"_blank",rel:"noopener noreferrer"},x={href:"https://blog.gnosis.pm/solidity-delegateproxy-contracts-e09957d0f201",target:"_blank",rel:"noopener noreferrer"},k={href:"https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/",target:"_blank",rel:"noopener noreferrer"};function y(z,w){const a=o("ExternalLinkIcon");return l(),i("div",null,[d,e("p",null,[e("a",p,[r("https://mshk.top/2022/06/solidity-hardhot-erc721-erc1822-erc1976-openzeppelin/"),n(a)])]),e("p",null,[e("a",h,[r("https://learnblockchain.cn/article/4534"),n(a)])]),e("p",null,[e("a",u,[r("https://mirror.xyz/xyyme.eth/kM9ld2u0D1BpHAfXTiaSPGPtDnOd6vrxJ5_tW4wZVBk"),n(a)])]),_,e("blockquote",null,[e("p",null,[e("a",g,[r("https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies#the-constructor-caveat"),n(a)])]),e("p",null,[e("a",m,[r("https://blog.csdn.net/Tesla_Zhou/article/details/111743243"),n(a)])]),e("p",null,[e("a",v,[r("https://learnblockchain.cn/article/4282"),n(a)])]),e("p",null,[e("a",b,[r("https://docs.openzeppelin.com/upgrades-plugins/1.x/api-hardhat-upgrades"),n(a)])]),e("p",null,[e("a",f,[r("https://xiaozhuanlan.com/topic/1762043598"),n(a)]),r(" 大概的对所有的代理模式进行一个总结")]),e("p",null,[e("a",x,[r("https://blog.gnosis.pm/solidity-delegateproxy-contracts-e09957d0f201"),n(a)]),r(" 委托代理的深入理解")]),e("p",null,[e("a",k,[r("https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/"),n(a)])])])])}const P=t(c,[["render",y],["__file","solidity_of_writing_can_upgrade_contract.html.vue"]]);export{P as default};
