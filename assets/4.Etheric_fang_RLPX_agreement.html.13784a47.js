import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as p,c,a as n,b as a,d as e,e as t,r}from"./app.1ee57811.js";const i={},l=n("blockquote",null,[n("p",null,"浅谈以太坊源码分析之rlpx协议")],-1),d={href:"https://github.com/blockchainGuide",target:"_blank",rel:"noopener noreferrer"},u=t('<h2 id="符号" tabindex="-1"><a class="header-anchor" href="#符号" aria-hidden="true">#</a> 符号</h2><ul><li><code>X || Y</code>：表示X和Y的串联</li><li><code>X ^ Y</code>： X和Y按位异或</li><li><code>X[:N]</code>：X的前N个字节</li><li><code>[X, Y, Z, ...]</code>：[X, Y, Z, ...]的RLP递归编码</li><li><code>keccak256(MESSAGE)</code>：以太坊使用的keccak256哈希算法</li><li><code>ecies.encrypt(PUBKEY, MESSAGE, AUTHDATA)</code>：RLPx使用的非对称身份验证加密函数 AUTHDATA是身份认证的数据，并非密文的一部分 但是AUTHDATA会在生成消息tag前，写入HMAC-256哈希函数</li><li><code>ecdh.agree(PRIVKEY, PUBKEY)</code>：是PRIVKEY和PUBKEY之间的椭圆曲线Diffie-Hellman协商函数</li></ul><hr><h2 id="ecies加密" tabindex="-1"><a class="header-anchor" href="#ecies加密" aria-hidden="true">#</a> ECIES加密</h2><p>ECIES (Elliptic Curve Integrated Encryption Scheme) 非对称加密用于RLPx握手。RLPx使用的加密系统：</p><ul><li>椭圆曲线secp256k1基点<code>G</code></li><li><code>KDF(k, len)</code>：密钥推导函数 NIST SP 800-56 Concatenation</li><li><code>MAC(k, m)</code>：HMAC函数，使用了SHA-256哈希</li><li><code>AES(k, iv, m)</code>：AES-128对称加密函数，CTR模式</li></ul><p>假设Alice想发送加密消息给Bob，并且希望Bob可以用他的静态私钥<code>kB</code>解密。Alice知道Bob的静态公钥<code>KB</code>。</p><p>Alice为了对消息<code>m</code>进行加密：</p><ol><li>生成一个随机数<code>r</code>并生成对应的椭圆曲线公钥<code>R = r * G</code></li><li>计算共享密码<code>S = Px</code>，其中 <code>(Px, Py) = r * KB</code></li><li>推导加密及认证所需的密钥<code>kE || kM = KDF(S, 32)</code>以及随机向量<code>iv</code></li><li>使用AES加密 <code>c = AES(kE, iv, m)</code></li><li>计算MAC校验 <code>d = MAC(keccak256(kM), iv || c)</code></li><li>发送完整密文<code>R || iv || c || d</code>给Bob</li></ol><p>Bob对密文<code>R || iv || c || d</code>进行解密：</p><ol><li>推导共享密码<code>S = Px</code>, 其中<code>(Px, Py) = r * KB = kB * R</code></li><li>推导加密认证用的密钥<code>kE || kM = KDF(S, 32)</code></li><li>验证MAC<code>d = MAC(keccak256(kM), iv || c)</code></li><li>获得明文<code>m = AES(kE, iv || c)</code></li></ol><hr><h2 id="节点身份" tabindex="-1"><a class="header-anchor" href="#节点身份" aria-hidden="true">#</a> 节点身份</h2><p>所有的加密操作都基于<strong>secp256k1</strong>椭圆曲线。每个节点维护一个静态的<strong>secp256k1</strong>私钥。建议该私钥只能进行手动重置（例如删除文件或数据库条目）。</p><hr><h2 id="握手流程" tabindex="-1"><a class="header-anchor" href="#握手流程" aria-hidden="true">#</a> 握手流程</h2><p>RLPx连接基于TCP通信，并且每次通信都会生成随机的临时密钥用于加密和验证。生成临时密钥的过程被称作“握手” (handshake)，握手在发起端（initiator, 发起TCP连接请求的节点）和接收端（recipient, 接受连接的节点）之间进行。</p>',17),k=t("<li>发起端向接收端发起TCP连接，发送<code>auth</code>消息</li><li>接收端接受连接，解密、验证<code>auth</code>消息（检查recovery of signature == <code>keccak256(ephemeral-pubk)</code>）</li><li>接收端通过<code>remote-ephemeral-pubk</code> 和 <code>nonce</code>生成<code>auth-ack</code>消息</li>",3),h={href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00",target:"_blank",rel:"noopener noreferrer"},m=n("li",null,[a("发起端接收到"),n("code",null,"auth-ack"),a("消息，导出密钥")],-1),v={href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00",target:"_blank",rel:"noopener noreferrer"},b=n("li",null,"接收端接收并验证首个加密后的数据帧",-1),g=n("li",null,"发起端接收并验证首个加密后的数据帧",-1),x=n("li",null,"如果两边的首个加密数据帧的MAC都验证通过，则加密握手完成",-1),f=t(`<p>如果首个数据帧的验证失败，则任意一方都可以断开连接。</p><h3 id="握手消息" tabindex="-1"><a class="header-anchor" href="#握手消息" aria-hidden="true">#</a> 握手消息</h3><p><strong>发送端：</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>auth <span class="token operator">=</span> auth<span class="token operator">-</span>size <span class="token operator">||</span> enc<span class="token operator">-</span>auth<span class="token operator">-</span>body
auth<span class="token operator">-</span>size <span class="token operator">=</span> size of enc<span class="token operator">-</span>auth<span class="token operator">-</span>body<span class="token punctuation">,</span> encoded as a big<span class="token operator">-</span>endian <span class="token number">16</span><span class="token operator">-</span>bit integer
auth<span class="token operator">-</span>vsn <span class="token operator">=</span> <span class="token number">4</span>
auth<span class="token operator">-</span>body <span class="token operator">=</span> <span class="token punctuation">[</span>sig<span class="token punctuation">,</span> initiator<span class="token operator">-</span>pubk<span class="token punctuation">,</span> initiator<span class="token operator">-</span>nonce<span class="token punctuation">,</span> auth<span class="token operator">-</span>vsn<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">]</span>
enc<span class="token operator">-</span>auth<span class="token operator">-</span>body <span class="token operator">=</span> ecies<span class="token punctuation">.</span><span class="token function">encrypt</span><span class="token punctuation">(</span>recipient<span class="token operator">-</span>pubk<span class="token punctuation">,</span> auth<span class="token operator">-</span>body <span class="token operator">||</span> auth<span class="token operator">-</span>padding<span class="token punctuation">,</span> auth<span class="token operator">-</span>size<span class="token punctuation">)</span>
auth<span class="token operator">-</span>padding <span class="token operator">=</span> arbitrary data
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>接收端：</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>ack <span class="token operator">=</span> ack<span class="token operator">-</span>size <span class="token operator">||</span> enc<span class="token operator">-</span>ack<span class="token operator">-</span>body
ack<span class="token operator">-</span>size <span class="token operator">=</span> size of enc<span class="token operator">-</span>ack<span class="token operator">-</span>body<span class="token punctuation">,</span> encoded as a big<span class="token operator">-</span>endian <span class="token number">16</span><span class="token operator">-</span>bit integer
ack<span class="token operator">-</span>vsn <span class="token operator">=</span> <span class="token number">4</span>
ack<span class="token operator">-</span>body <span class="token operator">=</span> <span class="token punctuation">[</span>recipient<span class="token operator">-</span>ephemeral<span class="token operator">-</span>pubk<span class="token punctuation">,</span> recipient<span class="token operator">-</span>nonce<span class="token punctuation">,</span> ack<span class="token operator">-</span>vsn<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">]</span>
enc<span class="token operator">-</span>ack<span class="token operator">-</span>body <span class="token operator">=</span> ecies<span class="token punctuation">.</span><span class="token function">encrypt</span><span class="token punctuation">(</span>initiator<span class="token operator">-</span>pubk<span class="token punctuation">,</span> ack<span class="token operator">-</span>body <span class="token operator">||</span> ack<span class="token operator">-</span>padding<span class="token punctuation">,</span> ack<span class="token operator">-</span>size<span class="token punctuation">)</span>
ack<span class="token operator">-</span>padding <span class="token operator">=</span> arbitrary data
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现必须忽略<code>auth-vsn</code> 和 <code>ack-vsn</code>中的所有不匹配。</p><p>实现必须忽略<code>auth-body</code> 和 <code>ack-body</code>中的所有额外列表元素。</p><p>握手消息互换后，密钥生成：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>static<span class="token operator">-</span>shared<span class="token operator">-</span>secret <span class="token operator">=</span> ecdh<span class="token punctuation">.</span><span class="token function">agree</span><span class="token punctuation">(</span>privkey<span class="token punctuation">,</span> remote<span class="token operator">-</span>pubk<span class="token punctuation">)</span>
ephemeral<span class="token operator">-</span>key <span class="token operator">=</span> ecdh<span class="token punctuation">.</span><span class="token function">agree</span><span class="token punctuation">(</span>ephemeral<span class="token operator">-</span>privkey<span class="token punctuation">,</span> remote<span class="token operator">-</span>ephemeral<span class="token operator">-</span>pubk<span class="token punctuation">)</span>
shared<span class="token operator">-</span>secret <span class="token operator">=</span> <span class="token function">keccak256</span><span class="token punctuation">(</span>ephemeral<span class="token operator">-</span>key <span class="token operator">||</span> <span class="token function">keccak256</span><span class="token punctuation">(</span>nonce <span class="token operator">||</span> initiator<span class="token operator">-</span>nonce<span class="token punctuation">)</span><span class="token punctuation">)</span>
aes<span class="token operator">-</span>secret <span class="token operator">=</span> <span class="token function">keccak256</span><span class="token punctuation">(</span>ephemeral<span class="token operator">-</span>key <span class="token operator">||</span> shared<span class="token operator">-</span>secret<span class="token punctuation">)</span>
mac<span class="token operator">-</span>secret <span class="token operator">=</span> <span class="token function">keccak256</span><span class="token punctuation">(</span>ephemeral<span class="token operator">-</span>key <span class="token operator">||</span> aes<span class="token operator">-</span>secret<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="帧结构" tabindex="-1"><a class="header-anchor" href="#帧结构" aria-hidden="true">#</a> 帧结构</h2><p>握手后所有的消息都按帧 (frame) 传输。一帧数据携带属于某一功能的一条加密消息。</p><p>分帧传输的主要目的是在单一连接上实现可靠的支持多路复用协议。其次，因数据包分帧，为消息认证码产生了适当的分界点，使得加密流变得简单了。通过握手生成的密钥对数据帧进行加密和验证。</p><p>帧头提供关于消息大小和消息源功能的信息。填充字节用于防止缓存区不足，使得帧组件按指定区块字节大小对齐。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>frame <span class="token operator">=</span> header<span class="token operator">-</span>ciphertext <span class="token operator">||</span> header<span class="token operator">-</span>mac <span class="token operator">||</span> frame<span class="token operator">-</span>ciphertext <span class="token operator">||</span> frame<span class="token operator">-</span>mac
header<span class="token operator">-</span>ciphertext <span class="token operator">=</span> <span class="token function">aes</span><span class="token punctuation">(</span>aes<span class="token operator">-</span>secret<span class="token punctuation">,</span> header<span class="token punctuation">)</span>
header <span class="token operator">=</span> frame<span class="token operator">-</span>size <span class="token operator">||</span> header<span class="token operator">-</span>data <span class="token operator">||</span> header<span class="token operator">-</span>padding
header<span class="token operator">-</span>data <span class="token operator">=</span> <span class="token punctuation">[</span>capability<span class="token operator">-</span>id<span class="token punctuation">,</span> context<span class="token operator">-</span>id<span class="token punctuation">]</span>
capability<span class="token operator">-</span>id <span class="token operator">=</span> integer<span class="token punctuation">,</span> always zero
context<span class="token operator">-</span>id <span class="token operator">=</span> integer<span class="token punctuation">,</span> always zero
header<span class="token operator">-</span>padding <span class="token operator">=</span> zero<span class="token operator">-</span>fill header to <span class="token number">16</span><span class="token operator">-</span><span class="token builtin">byte</span> boundary
frame<span class="token operator">-</span>ciphertext <span class="token operator">=</span> <span class="token function">aes</span><span class="token punctuation">(</span>aes<span class="token operator">-</span>secret<span class="token punctuation">,</span> frame<span class="token operator">-</span>data <span class="token operator">||</span> frame<span class="token operator">-</span>padding<span class="token punctuation">)</span>
frame<span class="token operator">-</span>padding <span class="token operator">=</span> zero<span class="token operator">-</span>fill frame<span class="token operator">-</span>data to <span class="token number">16</span><span class="token operator">-</span><span class="token builtin">byte</span> boundary
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="mac" tabindex="-1"><a class="header-anchor" href="#mac" aria-hidden="true">#</a> MAC</h2><p>RLPx中的消息认证 (Message authentication) 使用了两个keccak256状态，分别用于两个传输方向。<code>egress-mac</code>和<code>ingress-mac</code>分别代表发送和接收状态，每次发送或者接收密文，其状态都会更新。初始握手后，MAC状态初始化如下:</p><p><strong>发送端：</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>egress<span class="token operator">-</span>mac <span class="token operator">=</span> keccak256<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mac<span class="token operator">-</span>secret <span class="token operator">^</span> recipient<span class="token operator">-</span>nonce<span class="token punctuation">)</span> <span class="token operator">||</span> auth<span class="token punctuation">)</span>
ingress<span class="token operator">-</span>mac <span class="token operator">=</span> keccak256<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mac<span class="token operator">-</span>secret <span class="token operator">^</span> initiator<span class="token operator">-</span>nonce<span class="token punctuation">)</span> <span class="token operator">||</span> ack<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>接收端：</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>egress<span class="token operator">-</span>mac <span class="token operator">=</span> keccak256<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mac<span class="token operator">-</span>secret <span class="token operator">^</span> initiator<span class="token operator">-</span>nonce<span class="token punctuation">)</span> <span class="token operator">||</span> ack<span class="token punctuation">)</span>
ingress<span class="token operator">-</span>mac <span class="token operator">=</span> keccak256<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mac<span class="token operator">-</span>secret <span class="token operator">^</span> recipient<span class="token operator">-</span>nonce<span class="token punctuation">)</span> <span class="token operator">||</span> auth<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当发送一帧数据时，通过即将发送的数据更新<code>egress-mac</code>状态，然后计算相应的MAC值。通过将帧头与其对应MAC值的加密输出异或来进行更新。这样做是为了确保对明文MAC和密文执行统一操作。所有的MAC值都以明文发送。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>header-mac-seed = aes(mac-secret, keccak256.digest(egress-mac)[:16]) ^ header-ciphertext
egress-mac = keccak256.update(egress-mac, header-mac-seed)
header-mac = keccak256.digest(egress-mac)[:16]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>计算 <code>frame-mac</code></strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>egress-mac = keccak256.update(egress-mac, frame-ciphertext)
frame-mac-seed = aes(mac-secret, keccak256.digest(egress-mac)[:16]) ^ keccak256.digest(egress-mac)[:16]
egress-mac = keccak256.update(egress-mac, frame-mac-seed)
frame-mac = keccak256.digest(egress-mac)[:16]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只要发送者和接受者按相同方式更新<code>egress-mac</code>和<code>ingress-mac</code>，并且在ingress帧中比对<code>header-mac</code> 和 <code>frame-mac</code>的值，就能对ingress帧中的MAC值进行校验。这一步应当在解密<code>header-ciphertext</code> 和 <code>frame-ciphertext</code>之前完成。</p><hr><h2 id="功能消息" tabindex="-1"><a class="header-anchor" href="#功能消息" aria-hidden="true">#</a> 功能消息</h2><p>初始握手后的所有消息均与“功能”相关。单个RLPx连接上就可以同时使用任何数量的功能。</p>`,30),_={href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00",target:"_blank",rel:"noopener noreferrer"},y=t(`<h3 id="消息编码" tabindex="-1"><a class="header-anchor" href="#消息编码" aria-hidden="true">#</a> 消息编码</h3><p>初始Hello消息编码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>frame-data = msg-id || msg-data
frame-size = length of frame-data, encoded as a 24bit big-endian integer
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>msg-id</code>是标识消息的由RLP编码的整数，<code>msg-data</code>是包含消息数据的RLP列表。</p><p>Hello之后的所有消息均使用Snappy算法压缩。请注意，压缩消息的<code>frame-size</code>指<code>msg-data</code>压缩前的大小。消息的压缩编码为:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>frame-data = msg-id || snappyCompress(msg-data)
frame-size = length of (msg-id || msg-data) encoded as a 24bit big-endian integer
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="基于msg-id的复用" tabindex="-1"><a class="header-anchor" href="#基于msg-id的复用" aria-hidden="true">#</a> 基于<code>msg-id</code>的复用</h2><p>frame中虽然支持<code>capability-id</code>，但是在本RLPx版本中并没有将该字段用于不同功能之间的复用（当前版本仅使用msg-id来实现复用）。</p>`,8),P={href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00",target:"_blank",rel:"noopener noreferrer"},R=n("p",null,"msg-id应当大于0x11(0x00-0x10保留用于“ p2p”功能）。",-1),A=n("hr",null,null,-1),E=n("h2",{id:"p2p功能",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#p2p功能","aria-hidden":"true"},"#"),a(" p2p功能")],-1),M={href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00",target:"_blank",rel:"noopener noreferrer"},C={href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md#disconnect-0x01",target:"_blank",rel:"noopener noreferrer"},S={href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md#disconnect-0x01",target:"_blank",rel:"noopener noreferrer"},H=t(`<h3 id="hello-0x00" tabindex="-1"><a class="header-anchor" href="#hello-0x00" aria-hidden="true">#</a> Hello (0x00)</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[protocolVersion: P, clientId: B, capabilities, listenPort: P, nodeKey: B_64, ...]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>握手完成后，双方发送的第一包数据。在收到Hello消息前，不能发送任何其他消息。实现必须忽略Hello消息中所有其他列表元素，因为可能会在未来版本中用到。</p><ul><li><code>protocolVersion</code>当前p2p功能版本为第5版</li><li><code>clientId</code>表示客户端软件身份，人类可读字符串, 比如&quot;Ethereum(++)/1.0.0“</li><li><code>capabilities</code>支持的子协议列表，名称及其版本：<code>[[cap1, capVersion1], [cap2, capVersion2], ...]</code></li><li><code>listenPort</code>节点的收听端口 (位于当前连接路径的接口)，0表示没有收听</li><li><code>nodeId</code>secp256k1的公钥，对应节点私钥</li></ul><h3 id="disconnect-0x01" tabindex="-1"><a class="header-anchor" href="#disconnect-0x01" aria-hidden="true">#</a> Disconnect (0x01)</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[reason: P]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通知节点断开连接。收到该消息后，节点应当立即断开连接。如果是发送，正常的主机会给节点2秒钟读取时间，使其主动断开连接。</p><p><code>reason</code> 一个可选整数，表示断开连接的原因：</p><table><thead><tr><th>Reason</th><th>Meaning</th></tr></thead><tbody><tr><td><code>0x00</code></td><td>Disconnect requested</td></tr><tr><td><code>0x01</code></td><td>TCP sub-system error</td></tr><tr><td><code>0x02</code></td><td>Breach of protocol, e.g. a malformed message, bad RLP, ...</td></tr><tr><td><code>0x03</code></td><td>Useless peer</td></tr><tr><td><code>0x04</code></td><td>Too many peers</td></tr><tr><td><code>0x05</code></td><td>Already connected</td></tr><tr><td><code>0x06</code></td><td>Incompatible P2P protocol version</td></tr><tr><td><code>0x07</code></td><td>Null node identity received - this is automatically invalid</td></tr><tr><td><code>0x08</code></td><td>Client quitting</td></tr><tr><td><code>0x09</code></td><td>Unexpected identity in handshake</td></tr><tr><td><code>0x0a</code></td><td>Identity is the same as this node (i.e. connected to itself)</td></tr><tr><td><code>0x0b</code></td><td>Ping timeout</td></tr><tr><td><code>0x10</code></td><td>Some other reason specific to a subprotocol</td></tr></tbody></table><h3 id="ping-0x02" tabindex="-1"><a class="header-anchor" href="#ping-0x02" aria-hidden="true">#</a> Ping (0x02)</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,11),G={href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md#pong-0x03",target:"_blank",rel:"noopener noreferrer"},L=t(`<h3 id="pong-0x03" tabindex="-1"><a class="header-anchor" href="#pong-0x03" aria-hidden="true">#</a> Pong (0x03)</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,2),B={href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md#ping-0x02",target:"_blank",rel:"noopener noreferrer"},K=t(`<hr><h2 id="源码分析" tabindex="-1"><a class="header-anchor" href="#源码分析" aria-hidden="true">#</a> 源码分析</h2><h3 id="主要功能" tabindex="-1"><a class="header-anchor" href="#主要功能" aria-hidden="true">#</a> 主要功能</h3><h4 id="返回传输对象" tabindex="-1"><a class="header-anchor" href="#返回传输对象" aria-hidden="true">#</a> 返回传输对象</h4><blockquote><p>返回一个transport对象,连接持续5秒</p></blockquote><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// handshakeTimeout 5</span>
<span class="token keyword">func</span> <span class="token function">newRLPX</span><span class="token punctuation">(</span>fd net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> transport <span class="token punctuation">{</span>
<span class="token operator">...</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="读取消息" tabindex="-1"><a class="header-anchor" href="#读取消息" aria-hidden="true">#</a> 读取消息</h4><blockquote><p>返回Msg对象,调用读写器的ReadMsg,连接持续30秒</p></blockquote><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>rlpx<span class="token punctuation">)</span> <span class="token function">ReadMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Msg<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span>
 t<span class="token punctuation">.</span>fd<span class="token punctuation">.</span><span class="token function">SetReadDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>frameReadTimeout<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="写入消息" tabindex="-1"><a class="header-anchor" href="#写入消息" aria-hidden="true">#</a> 写入消息</h4><blockquote><p>调用读写器的WriteMsg写信息,连接持续20秒</p></blockquote><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>rlpx<span class="token punctuation">)</span> <span class="token function">WriteMsg</span><span class="token punctuation">(</span>msg Msg<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
 t<span class="token punctuation">.</span>fd<span class="token punctuation">.</span><span class="token function">SetWriteDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>frameWriteTimeout<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="协议版本握手" tabindex="-1"><a class="header-anchor" href="#协议版本握手" aria-hidden="true">#</a> 协议版本握手</h4><blockquote><p>协议握手,输入输出均是protoHandshake对象,包含了版本号、名称、容量、端口号、ID和一个扩展属性,握手时会对这些信息进行验证</p></blockquote><h4 id="加密握手" tabindex="-1"><a class="header-anchor" href="#加密握手" aria-hidden="true">#</a> 加密握手</h4><blockquote><p>握手时主动发起者叫<strong>initiator</strong></p><p>接收方叫<strong>receiver</strong></p><p>分别对应两种处理方式<strong>initiatorEncHandshake</strong>和receiverEncHandshake</p><p>两种处理方式成功以后都会得到一个<strong>secrets</strong>对象,保存了共享密钥信息,它会跟原有的<strong>net.Conn</strong>对象一起生成一个帧处理器:<strong>rlpxFrameRW</strong></p><p>握手双方使用到的信息有:各自的公私钥地址对**(iPrv,iPub,rPrv,rPub)<strong>、各自生成的随机公私钥对</strong>(iRandPrv,iRandPub,rRandPrv,rRandPub)<strong>、各自生成的临时随机数</strong>(initNonce,respNonce).** 其中i开头的表示发起方**(initiator)<strong>信息,r开头的表示接收方</strong>(receiver)**信息.</p></blockquote><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>rlpx<span class="token punctuation">)</span> <span class="token function">doEncHandshake</span><span class="token punctuation">(</span>prv <span class="token operator">*</span>ecdsa<span class="token punctuation">.</span>PrivateKey<span class="token punctuation">,</span> dial <span class="token operator">*</span>ecdsa<span class="token punctuation">.</span>PublicKey<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>ecdsa<span class="token punctuation">.</span>PublicKey<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">var</span> <span class="token punctuation">(</span>
  sec secrets
  err <span class="token builtin">error</span>
 <span class="token punctuation">)</span>
 <span class="token keyword">if</span> dial <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
  sec<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">receiverEncHandshake</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> prv<span class="token punctuation">)</span> <span class="token comment">// 接收者</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  sec<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">initiatorEncHandshake</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> prv<span class="token punctuation">,</span> dial<span class="token punctuation">)</span> <span class="token comment">//主动发起者</span>
 <span class="token punctuation">}</span>
<span class="token operator">...</span>
 t<span class="token punctuation">.</span>rw <span class="token operator">=</span> <span class="token function">newRLPXFrameRW</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> sec<span class="token punctuation">)</span>
 t<span class="token punctuation">.</span>wmu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token keyword">return</span> sec<span class="token punctuation">.</span>Remote<span class="token punctuation">.</span><span class="token function">ExportECDSA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们就讲解一下主动握手部分源码<code>initiatorEncHandshake</code>：</p><p>①：初始化握手对象</p><div class="language-GO line-numbers-mode" data-ext="GO"><pre class="language-GO"><code>h := &amp;encHandshake{initiator: true, remote: ecies.ImportECDSAPublic(remote)}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>②：生成验证信息</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>authMsg<span class="token punctuation">,</span> err <span class="token operator">:=</span> h<span class="token punctuation">.</span><span class="token function">makeAuthMsg</span><span class="token punctuation">(</span>prv<span class="token punctuation">)</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-GO line-numbers-mode" data-ext="GO"><pre class="language-GO"><code>func (h *encHandshake) makeAuthMsg(prv *ecdsa.PrivateKey) (*authMsgV4, error) {
 // 生成己方随机数initNonce
 h.initNonce = make([]byte, shaLen)
 _, err := rand.Read(h.initNonce)
...
 }
// 生成随机的一组公私钥对
 h.randomPrivKey, err = ecies.GenerateKey(rand.Reader, crypto.S256(), nil)
...
 }
 // 生成静态共享秘密token(用己方私钥和对方公钥进行有限域乘法)
 token, err := h.staticSharedSecret(prv)
 ...
 }
//  和己方随机数异或后用随机生成的私钥签名
 signed := xor(token, h.initNonce)
 signature, err := crypto.Sign(signed, h.randomPrivKey.ExportECDSA())
...
 }
...
 return msg, nil
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>③：封包,将验证信息和握手进行rlp编码并拼接前缀信息</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>authPacket<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">sealEIP8</span><span class="token punctuation">(</span>authMsg<span class="token punctuation">,</span> h<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>④：通过conn发送消息</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>authPacket<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>⑤：处理接收的信息,得到响应包</p><blockquote><p><code>readHandshakeMsg</code>比较简单。 首先用一种格式尝试解码。如果不行就换另外一种。应该是一种兼容性的设置。 基本上就是使用自己的私钥进行解码然后调用rlp解码成结构体。</p><p>结构体的描述就是下面的authRespV4,里面最重要的就是对端的随机公钥。 双方通过自己的私钥和对端的随机公钥可以得到一样的共享秘密。 而这个共享秘密是第三方拿不到的</p></blockquote><div class="language-GO line-numbers-mode" data-ext="GO"><pre class="language-GO"><code> authRespMsg := new(authRespV4)
 authRespPacket, err := readHandshakeMsg(authRespMsg, encAuthRespLen, prv, conn)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>⑥：填充响应的respNonce(对方随机数,生成共享私钥用)和remoteRandomPub(对方的随机公钥)</p><div class="language-GO line-numbers-mode" data-ext="GO"><pre class="language-GO"><code> h.handleAuthResp(authRespMsg)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>⑦：将请求包和响应包封装成共享秘密(secrets)</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>h<span class="token punctuation">.</span><span class="token function">secrets</span><span class="token punctuation">(</span>authPacket<span class="token punctuation">,</span> authRespPacket<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>到此RLPX 相关的比较重要的内容就解读差不多了。</p><hr><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>`,37),I={href:"https://github.com/blockchainGuide/blockchainguide",target:"_blank",rel:"noopener noreferrer"},q={href:"https://mindcarver.cn/",target:"_blank",rel:"noopener noreferrer"},w={href:"https://github.com/ethereum/devp2p/blob/master/rlpx.md",target:"_blank",rel:"noopener noreferrer"};function D(N,T){const s=r("ExternalLinkIcon");return p(),c("div",null,[l,n("p",null,[a("本文主要参考自eth官方文档："),n("a",d,[a("rlpx协议"),e(s)])]),u,n("ol",null,[k,n("li",null,[a("接收端推导密钥，发送首个包含"),n("a",h,[a("Hello"),e(s)]),a("消息的数据帧 (frame)")]),m,n("li",null,[a("发起端发送首个加密后的数据帧，包含发起端"),n("a",v,[a("Hello"),e(s)]),a("消息")]),b,g,x]),f,n("p",null,[a("功能由简短的ASCII名称和版本号标识。连接两端都支持的功能在隶属于“ p2p”功能的"),n("a",_,[a("Hello"),e(s)]),a("消息中进行交换，p2p功能需要在所有连接中都可用。")]),y,n("p",null,[a("每种功能都会根据需要分配尽可能多的msg-id空间。所有这些功能所需的msg-id空间都必须通过静态指定。在连接和接收"),n("a",P,[a("Hello"),e(s)]),a("消息时，两端都具有共享功能（包括版本）的对等信息，并且能够就msg-id空间达成共识。")]),R,A,E,n("p",null,[a("所有连接都具有“p2p”功能。初始握手后，连接的两端都必须发送"),n("a",M,[a("Hello"),e(s)]),a("或"),n("a",C,[a("Disconnect"),e(s)]),a("消息。在接收到Hello消息后，会话就进入激活状态，并且可以开始发送其他消息。由于前向兼容性，实现必须忽略协议版本中的所有差异。与处于较低版本的节点通信时，实现应尝试靠近该版本。")]),n("p",null,[a("任何时候都可能会收到"),n("a",S,[a("Disconnect"),e(s)]),a("消息。")]),H,n("p",null,[a("要求节点立即进行"),n("a",G,[a("Pong"),e(s)]),a("回复。")]),L,n("p",null,[a("回复节点的"),n("a",B,[a("Ping"),e(s)]),a("包。")]),K,n("blockquote",null,[n("p",null,[n("a",I,[a("https://github.com/blockchainGuide/blockchainguide"),e(s)]),a(" ☆ ☆ ☆ ☆ ☆")]),n("p",null,[n("a",q,[a("https://mindcarver.cn/"),e(s)]),a(" ☆ ☆ ☆ ☆ ☆")]),n("p",null,[n("a",w,[a("https://github.com/ethereum/devp2p/blob/master/rlpx.md"),e(s)])])])])}const X=o(i,[["render",D],["__file","4.Etheric_fang_RLPX_agreement.html.vue"]]);export{X as default};
