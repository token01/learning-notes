import{_ as i}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as r,c as n,a as e,b as l,d as t,e as d,r as h}from"./app.7b6c8628.js";const s={},o=d('<h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h2><p>Zksync 是 zkrollup, 使用加密有效性证明在以太坊上提供可扩展和低成本交易的无信任协议。</p><h2 id="zksync-概述" tabindex="-1"><a class="header-anchor" href="#zksync-概述" aria-hidden="true">#</a> zksync 概述</h2><p>Rollup 需要 operator 将交易汇总在一起，计算出正确状态状态的零知识证明，再和 roullup 合约交互来影响状态转换。</p><p>zksync 的 rollup 操作如下：</p><ul><li>用户创建交易或者优先级操作</li><li>处理此请求后，Operator 创建 rollup 操作并将其添加到L2块中</li><li>一旦L2区块完成，运营商区块证明作为区块承诺提交给 zksync 合约，合约将会校验 rollup的部分逻辑，验证成功则看做最终状态</li></ul><p>L2 区块的生命周期 ：</p><ul><li>Pending :operator 接收到交易</li><li>Processed ：交易被 operator 执行并确认包含在下个区块中</li><li>Committed ：表明该区块的交易数据已发布在以太坊上。它不能证明它是以有效的方式执行的，但它确保了块数据的可用性。</li><li>Finalized ：这表明交易的SNARK有效性证明已提交并由智能合约验证（一笔笔的交易由L1打包）。在这一步骤之后，交易被认为是最终的</li></ul><p>从 Processed 到 Finalized 要经历几个小时。</p><p>zksync2.0 支持的功能如下：</p><ul><li>ECDSA签名的本机支持：任何帐户都可以在 L2 中使用与 L1 相同的私钥进行管理</li><li>支持 solidity 0.8.x</li><li>Web3 API与以太坊完全兼容。这允许与现有的索引器、浏览器等无缝集成。</li><li>支持 keccak256、 sha256 和 ecrecover通过预编译</li><li>hardhat 插件支持在 zksync 上简单测试和开发</li><li>支持 从以太坊上传递数据到 zksync 上的合约</li></ul><h2 id="了解zksync" tabindex="-1"><a class="header-anchor" href="#了解zksync" aria-hidden="true">#</a> 了解zksync</h2><h3 id="收费机制" tabindex="-1"><a class="header-anchor" href="#收费机制" aria-hidden="true">#</a> 收费机制</h3><h3 id="跨链桥" tabindex="-1"><a class="header-anchor" href="#跨链桥" aria-hidden="true">#</a> 跨链桥</h3><p>L1和L2各部署一个合约，来作为桥接。开发人员可以自由为任何代币建造自己的桥梁。但是，我们提供默认的桥梁（一个用于ETH，另一个用于ERC20代币），可用于基本桥接。</p><h4 id="存钱到l2" tabindex="-1"><a class="header-anchor" href="#存钱到l2" aria-hidden="true">#</a> 存钱到L2</h4><p>用户调用 L1 bradge合约的 存款方法，将会触发以下事件：</p><ul><li>用户在L1 上的token会被发送到 L1 bridge 并被锁住</li><li>L1 bridge 合约会启动一笔交易发送到 L2 bridge 通过 L1-&gt;L2 (这是个什么)</li><li>在L2交易中，token 将被 mint 并发送到L2上的指定地址 <ul><li>如果zkSync上还不存在令牌，则会为其部署新的合约。假设L2令牌地址是确定性的（基于原始L1地址、名称和符号），不管谁是第一个桥接它的人，新的L2地址都是相同的。</li><li>对于每个执行的L1-&gt;L2交易，都会有一条L2-&gt;L1日志消息确认其执行。</li></ul></li></ul><p>warning：</p><p>如果此交易出于任何原因失败（例如，提供的费用太低），则日志消息将陈述其故障。在这种情况下，可以在L1桥上证明包含日志，以通过调用Moded sopairfailedDeposit将存入资金退还给原始发件人</p><h4 id="提款到l1" tabindex="-1"><a class="header-anchor" href="#提款到l1" aria-hidden="true">#</a> 提款到L1</h4><p>用户调用取款操作在 L2 bradge 合约上，将会触发以下动作：</p><ul><li>L2的token会被burn掉</li><li>一个 L2-&gt;L1 的消息关于提款的 会被发送</li><li>之后，撤回操作将可由L1 bradge 中的任何人最终完成（通过证明包含L2-&gt;L1消息，这是在调用L1 网桥中的的finlizeWithdraw方法时完成的）</li><li>调用方法后，资金从L1 bradge 解锁并发送给提款接收者</li></ul><p>warning ：</p><p>在测试网环境上，我们会自动确定所有提款，即，对于每次提款，我们将通过进行L1交易来照顾它，以证明每条消息包含在内。</p><h3 id="l1-l2互操作性" tabindex="-1"><a class="header-anchor" href="#l1-l2互操作性" aria-hidden="true">#</a> L1/L2互操作性</h3><h4 id="优先级队列" tabindex="-1"><a class="header-anchor" href="#优先级队列" aria-hidden="true">#</a> 优先级队列</h4><h4 id="l2-l1-消息传递" tabindex="-1"><a class="header-anchor" href="#l2-l1-消息传递" aria-hidden="true">#</a> L2-&gt;L1 消息传递</h4><p>与 L1 -&gt; L2 通信相反，仅基于传输信息，而不是基于 L1 上的事务执行。它是一个内置功能，由两部分组成：从 L2 发送消息和在 L1 上读取消息。第一个是作为对 L2 系统智能合约的调用来实现的。第二个是在 zkSync L1 智能合约上作为 getter 函数实现的。</p><p>发送消息：</p><p>从 L2 发送到 L1 的每条消息都包含发送者的地址和消息本身。消息的长度可以任意大，但是消息越长，发送的成本就越高。操作员必须包括相应 merkle 根的所有消息（见下一段）。因此，所有消息都是公开可用的，不必依赖运营商来披露它们</p><p>阅读消息</p>',32),c={href:"https://v2-docs.zksync.io/api/api.html#zksgetl2tol1msgproof",target:"_blank",rel:"noopener noreferrer"},L=e("p",null,"总结：",-1),p=e("ul",null,[e("li",null,"L2 -> L1 通信需要 L2 上的一个事务和 L1 上的一个事务。"),e("li",null,"消息可以是任意长度。"),e("li",null,"证明消息包含在 L2 块中所需的所有数据始终可以从以太坊恢复。但是，最简单的方法是通过 API 向运营商请求证明。")],-1),u=e("h2",{id:"l1-l2-交流",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#l1-l2-交流","aria-hidden":"true"},"#"),l(" L1->L2 交流")],-1),k=e("p",null,"交易有 base fee, 基于交易的ergslimit 和L1上的gas price 得出的，目前来说L1-> L2的交易都是先进先出方式。",-1);function _(f,b){const a=h("ExternalLinkIcon");return r(),n("div",null,[o,e("p",null,[l("发送的每条消息都可以在链上读取。此外，可以证明消息已在特定的 L2 块中发送。为了使这种证明对用户和运营商都尽可能便宜，我们将每个 L2 块的所有消息存储在 merkle 树中。因此，任何 L1 智能合约都可以通过提供包含在某个 L2 块中的证明来使用发送的消息。只能基于运营商发送给 zkSync L1 智能合约的数据生成证明。也可以通过"),e("a",c,[l("API"),t(a)]),l("获得证明")]),L,p,u,k])}const y=i(s,[["render",_],["__file","zksync2.0.html.vue"]]);export{y as default};
