import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o,c,a as n,b as a,d as p,e as t,r}from"./app.e2c76996.js";const l={},i=t(`<p>现在生活已经离不开微信/支付宝电子支付，平常出去吃饭、购物只要带个手机，就可以解决一切，以致于现在已经好久没摸过真💰了。</p><p>有一次出去吃饭，排着队付钱，等着过程非常无聊，准备拔出手机来把荒野乱斗，却发现这个地方竟然连不上网 。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084258108-174125349.jpg" alt="" loading="lazy"></p><p>看着手机明明信号满格，但是就是显示网络无连接，苹果手机用户痛，谁用谁知道。</p><blockquote><p>画外音:真的要 Diss 一下使用英特尔基带的 Iphone，📶好差，没事网络就会闪断~</p></blockquote><p>说回正题，由于没有网络，而我又没带钱，所以就怕付钱的时候因为手机没网，没办法使用支付宝扣款。正想着时，已经排到了我，不管三七二十一，先用下支付宝试试，实在不行爷不吃了。</p><p>不过没想到，当商家用扫码抢扫描支付宝上付款码支付以后，虽然我的手机最终没有弹出支付成功的页面，但是商家端显示支付成功，并成功打印出了小票，过了一会，我的手机收到支付宝扣款短信。</p><p>因为我最近的工作对都是与微信/支付宝有关，整体支付流程还是比较清楚，但是付款码为什么能离线支付确实不是很清楚，所以研究了一番，于是有了今天的文章。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084258265-1975570204.jpg" alt="" loading="lazy"></p><h2 id="科普支付方式" tabindex="-1"><a class="header-anchor" href="#科普支付方式" aria-hidden="true">#</a> 科普支付方式</h2><p>在聊付款码离线原理之前，我们先给不熟悉支付宝/微信支付方式同学先科普一下常见的两种支付方式。</p><p>微信、支付宝线下支付常用支付方式有两种，一种是我们打开手机，主动扫描商家提供码牌，这种支付方式一般称为主扫支付（用户主动扫码）。</p><p>以支付宝为例，付款流程如图所示：</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084258471-1092312591.jpg" alt="图片来自支付宝官网" loading="lazy"></p><p>第二种则是我们打开手机，展示我们的付款码，然后商家使用扫码枪等工具获取付款码完成支付，这种支付方式一般称为被扫支付（用户被扫码）。</p><p>以支付宝为例，付款流程如图所示：</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084258757-1945687815.jpg" alt="图片来自支付宝官网" loading="lazy"></p><p>对于第一种方式，需要手机端 APP 扫码，然后弹窗确认付款，这种方式是没有办法在手机没有网络的情况完成支付，所以我们上文说的没有网络的情况特指付款码支付的场景。</p><h2 id="付款码付款流程" tabindex="-1"><a class="header-anchor" href="#付款码付款流程" aria-hidden="true">#</a> 付款码付款流程</h2><p>在聊付款码离线支付的前提前，我们先来来看下付款码的整体流程，以超市购物为例，一次付款码的支付信息流如图所示：</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084259038-399486180.jpg" alt="参考知乎@天顺" loading="lazy"></p><p>这个过程商家后台系统是需要调用的支付宝条码支付的接口，完成支付。</p><p><strong>由于商家后台需要在线联网与支付宝后台通讯，所以说付款码的离线支付，指的是客户端没有的网络的情况，商家端其实必须实时联网在线。</strong></p><p>一次付款码接口调用流程如图所示：</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084259392-963235151.jpg" alt="来自支付宝官网" loading="lazy"></p><p>通过上面两张图，我们整体了解付款码交互流程。</p><p>付款码的技术方案其实可以分为客户端在线与离线的两种情况，下面我们来看下两种方案具体实现方式。</p><h2 id="在线码方案" tabindex="-1"><a class="header-anchor" href="#在线码方案" aria-hidden="true">#</a> 在线码方案</h2><p>客户端在线码的方案，这个应该比较容易想到，只要支付宝/微信在登录的情况下，点击付款按钮，客户端调用后台系统的申请付款码接口。</p><p>后台系统受到请求之后，生成一个付款码，然后在数据库保存付款码与用户的关系，并且返回给客户端。</p><p>只要客户端在有效期内展示该付款码，就可以完成支付，否则该二维码就将会过期。</p><p>使用这种方案，相对来说比较安全，因为每次都是服务端生成码，服务端可以控制幂等，没有客户端伪造的风险的。</p><p>另外即使需要对付款码规则调整，比如付款码位数增加一位，我们只要调整服务端代码即可，客户端都无需升级。</p><p><strong>不过这种方案缺点也比较明显，客户端必须实时在线联网，没有网络则无法获取付款码。</strong></p><p>另外，现在有一些智能设备也开始支持支付宝支付，这些设备中很大一部分是没有联网的功能（<em>比如小米手环四</em>），那这种情况是没办法使用在线码方案。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084259568-1378830885.jpg" alt="" loading="lazy"></p><p>基于这种情况，所以开始有了离线码方案。</p><h2 id="离线码方案" tabindex="-1"><a class="header-anchor" href="#离线码方案" aria-hidden="true">#</a> 离线码方案</h2><p>说起离线码大家可能比较陌生，但是实际上你如果仔细观察，其实很多场景都用到了离线码。</p><p>比如说以前去黑网吧玩梦幻西游的时候，账号总是被盗。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084259736-1623577831.jpg" alt="" loading="lazy"></p><p>没办法，花了一笔重资买了一个网易将军令，每次登录的时候，除了输入用户名与密码以外，还需要输入动态口令。从此账号就很少被盗了。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084259872-97493341.jpg" alt="" loading="lazy"></p><p>又比如说每次网易支付的时候，我们除了输入银行卡密码以外，还需要输入网银盾上动态码，这样才能完成支付。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084300001-909222687.jpg" alt="" loading="lazy"></p><blockquote><p>画外音：</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084300156-503110690.jpg" alt="" loading="lazy"></p><p>这里又要吐槽一下，网银盾以前真的超难用，动不动就驱动不兼容。还记得当初用网银充值黄钻，搞了一下午都没有成功--！</p></blockquote><p>当然上面这些可能已经是<em>老古董</em>了，很多人都可能没用过，现在比较流行是<strong>手机验证器APP</strong>，比如 <strong>Google Authenticator</strong> 等。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084300339-900696701.jpg" alt="" loading="lazy"></p><p>这种令牌器，动态产生一次性口令（<strong>OTP, One-time Password</strong>），可以防止密码被盗用引发的安全风险。</p><p>其实付款码离线方案技术原型就是基于这种方案，所以下面我们就基于 Google Authenticator，来了解一下这其中的原理。</p><h3 id="动态口令技术原理" tabindex="-1"><a class="header-anchor" href="#动态口令技术原理" aria-hidden="true">#</a> 动态口令技术原理</h3><p>首先如果我们需要使用 <strong>Google Authenticator</strong>，我们需要在网站上开启二次验证功能，以 Google 账号为例，在设置两步验证的地方可以找到如下设置：</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084300560-1624461624.jpg" alt="" loading="lazy"></p><p>当我们点击设置，将会弹出一个二维码，然后使用 <strong>Google Authenticator</strong> APP 扫码绑定。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084300775-1871222912.jpg" alt="" loading="lazy"></p><p>当我们绑定之后， <strong>Google Authenticator</strong> APP 将会展示动态码。</p><p>我们来解析一下这个二维码，对应下面这个字符串：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>otpauth://totp/Google%3Ayourname@gmail.com?secret=xxxx&amp;issuer=Google
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的字符串中，最重要就是这一串密钥 <code>secret</code>，这个是一个经过 <strong>BASE32</strong> 编码之后的字符串，真正使用时需要将其使用<strong>BASE32</strong> 解码，处理伪码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>original_secret <span class="token operator">=</span> xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
secret <span class="token operator">=</span> <span class="token function">BASE32_DECODE</span><span class="token punctuation">(</span><span class="token function">TO_UPPERCASE</span><span class="token punctuation">(</span><span class="token function">REMOVE_SPACES</span><span class="token punctuation">(</span>original_secret<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>这个密钥客户端与服务端将会同时保存一份，两端将会同样的算法计算，以此用来比较动态码的正确性。</strong></p><p>我们以客户端为例，生成一个动态码，首先我们需要经过一个签名函数，这里 **Google Authenticator **采用的 <strong>HMAC-SHA1</strong>，这是一种基于哈希的消息验证码，可以用比较安全的单向哈希函数（如 SHA1）来产生签名。</p><p>签名函数伪码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>hmac <span class="token operator">=</span> <span class="token function">SHA1</span><span class="token punctuation">(</span>secret <span class="token operator">+</span> <span class="token function">SHA1</span><span class="token punctuation">(</span>secret <span class="token operator">+</span> input<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面函数中的，<code>input</code> 使用当前时间整除 30 的值。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>input <span class="token operator">=</span> <span class="token function">CURRENT_UNIX_TIME</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">30</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里时间就充当一个动态变参，这样可以源源不断产生动态码。</p><p><strong>另外这里整除 30，是为了赋予验证码一个 30 秒的有效期。</strong></p><p>这样对于用户输入来讲，可以有充足时间准备输入这个动态码，另外一点客户端与服务端可能存在时间偏差，30 秒的间隔可以很大概率的屏蔽这种差异。</p><blockquote><p>画外音：这个有效时间其实很考量，如果比较长，安全性就差。</p><p>如果比较短，用户体验就很差，不容易输入准备。</p></blockquote><p>经过 <strong>HMAC-SHA1</strong> 签名函数以后，我们得到一个长度为 40 的字符串，我们还需要将其转化为 6 位数字，方便用户输入。处理的伪码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>four_bytes <span class="token operator">=</span> hmac<span class="token punctuation">[</span><span class="token function">LAST_BYTE</span><span class="token punctuation">(</span>hmac<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">LAST_BYTE</span><span class="token punctuation">(</span>hmac<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span>
large_integer <span class="token operator">=</span> <span class="token function">INT</span><span class="token punctuation">(</span>four_bytes<span class="token punctuation">)</span>
small_integer <span class="token operator">=</span> large_integer <span class="token operator">%</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">000</span><span class="token punctuation">,</span><span class="token number">000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完整的算法伪码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>original_secret <span class="token operator">=</span> xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
secret <span class="token operator">=</span> <span class="token function">BASE32_DECODE</span><span class="token punctuation">(</span><span class="token function">TO_UPPERCASE</span><span class="token punctuation">(</span><span class="token function">REMOVE_SPACES</span><span class="token punctuation">(</span>original_secret<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
input <span class="token operator">=</span> <span class="token function">CURRENT_UNIX_TIME</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">30</span>
hmac <span class="token operator">=</span> <span class="token function">SHA1</span><span class="token punctuation">(</span>secret <span class="token operator">+</span> <span class="token function">SHA1</span><span class="token punctuation">(</span>secret <span class="token operator">+</span> input<span class="token punctuation">)</span><span class="token punctuation">)</span>
four_bytes <span class="token operator">=</span> hmac<span class="token punctuation">[</span><span class="token function">LAST_BYTE</span><span class="token punctuation">(</span>hmac<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">LAST_BYTE</span><span class="token punctuation">(</span>hmac<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span>
large_integer <span class="token operator">=</span> <span class="token function">INT</span><span class="token punctuation">(</span>four_bytes<span class="token punctuation">)</span>
small_integer <span class="token operator">=</span> large_integer <span class="token operator">%</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">000</span><span class="token punctuation">,</span><span class="token number">000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当客户端将动态码上传给服务端，服务端查询数据库获取到用户对应的密钥，然后使用同样的算法进行处理生成一个动态码，最后比较客户端上传动态码与服务端生成是否一致。</p><h3 id="付款码离线方案" tabindex="-1"><a class="header-anchor" href="#付款码离线方案" aria-hidden="true">#</a> 付款码离线方案</h3><p>上面我们了解了动态口令的实现方案，付款码生成原理其实也大致如此。</p><p>不过付款码离线方案采用动态密钥的方式(<strong>全局唯一</strong>)，定时请求服务端更换密钥，以此保证更高的安全性。</p><p>另外在一次性动态口令方案，需要双方基于同样的秘钥，所以服务端需要明确知道这<strong>背后正确用户</strong>。以上面的登录场景为例，登录过程输入用户名,服务端就可以根据这个在数据库中查询相应的密钥。</p><p>但是在付款码的支付场景中，支付过程仅仅传递一个付款码，就可以向相应的用户扣款。不用想，这个付款码这串数字一定包含相应的用户信息。</p><p>所以付款码的相应的算法相比动态码会更加复杂，这样才可以有效保证安全性。</p><p>看到这里，不知道你们是否想了解这套算法那？</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084300952-579485567.jpg" alt="" loading="lazy"></p><p>哈哈，开个玩笑，这种算法岂能是我们能掌握的。</p><p>支付宝核心算法咱不知道，但是我们可以从其他人公开设计方案了解一个皮毛。</p>`,85),u={href:"https://www.zhihu.com/question/49811134/answer/135886638",target:"_blank",rel:"noopener noreferrer"},g=t('<p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084301103-1719620198.png" alt="来自：https://www.zhihu.com/question/49811134/answer/135886638" loading="lazy"></p><h3 id="付款码离线码的劣势" tabindex="-1"><a class="header-anchor" href="#付款码离线码的劣势" aria-hidden="true">#</a> 付款码离线码的劣势</h3><p>最后我们来看下付款码离线方案的劣势：</p><p>第一，算法调整不灵活，如果相关算法较大的调整，可能需要升级客户端,并且这个期间服务端还需要兼容新老算法产生的付款码。</p><p>第二，安全性问题，正常的情况相关密钥无法被普通用户获取，但是架不住有有心之人。他们可能通过获取手机用户 Root 权限或者越狱手机，利用恶意程序获取密钥，然后随意生成付款码。</p><p>看到这一点，大家可能会担心自己的钱包安全了。不过这一点，我觉得不过过分担心，蚂蚁集团这么多大神，不是吃干饭的，他们肯定有很多措施保证支付安全。</p><p>第三数据碰撞问题，A 用户生成付款码算出来与 B 用户一致，这就 Hash 算法一样，再怎么优秀的算法，也有概率才生一样的额 Hash 值。</p><p>这就导致原本是扣用户 A 的钱，最后却扣了 B 用户。这样一来，确实很乌龙，对于 B 用户来讲，莫名其妙被扣钱了。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202009/1419561-20200903084301259-857416869.jpg" alt="" loading="lazy"></p><p>不过放心，这种事放到放到现在，我觉得还是比买彩票中奖低，所以这种事还是不用过分担心了。</p><p>即使真被误扣了，放心，支付宝这么大体量肯定会跟客户赔钱的。</p><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后" aria-hidden="true">#</a> 最后</h2><p>最后总结一下，我们平常使用付款码支付，其实原理就是商家端获取我们手机 APP 付款码（<strong>其实就是一串数字</strong>），然后后台调用支付宝支付接口完成扣款。</p><p>这个流程商家端后台程序必须联网在线，但是对于我们客户端来讲可以在线，也可以离线。</p><p>如果我们客户端在线，那就可以通过服务端向客户端发送付款码，这种方式更加安全，灵活，但是对于弱网环境下，体验就很差。</p><p>如果我们客户端没网，那就通过客户端通过一定算法生成付款码，服务端收到经过相关校验，确认是哪个用户，确认码有效性，并且完成扣款。这种方式，适合客户端没有网络的情况，不过相对不灵活，且安全性稍差。</p><p>嘿嘿，了解原理，有没有觉得还是挺有意思的~</p><p>下次排队付款钱,如果手机没网，不要担心尴尬，放心拿出手机付钱~</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',19),d={href:"https://www.zhihu.com/question/49811134/answer/135886638",target:"_blank",rel:"noopener noreferrer"},h={href:"https://garbagecollected.org/2014/09/14/how-google-authenticator-works/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://studyidea.cn",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.cnblogs.com/goodAndyxublog/p/13605601.html",target:"_blank",rel:"noopener noreferrer"};function x(b,v){const s=r("ExternalLinkIcon");return o(),c("div",null,[i,n("p",null,[a("这里小黑哥给你一个知乎网友"),n("a",u,[a("@反方向的钟回答"),p(s)]),a("的离线二维码实现方式，给你 look look。")]),g,n("ol",null,[n("li",null,[n("a",d,[a("https://www.zhihu.com/question/49811134/answer/135886638"),p(s)])]),n("li",null,[n("a",h,[a("https://garbagecollected.org/2014/09/14/how-google-authenticator-works/"),p(s)])])]),n("blockquote",null,[n("p",null,[a("欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客："),n("a",m,[a("studyidea.cn"),p(s)])])]),n("blockquote",null,[n("p",null,[a("参考链接："),n("a",k,[a("https://www.cnblogs.com/goodAndyxublog/p/13605601.html"),p(s)]),a("，整理：musk")])])])}const A=e(l,[["render",x],["__file","shoujmwlqhnzfzssmyl.html.vue"]]);export{A as default};
