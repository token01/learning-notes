import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as l,e as n}from"./app.8c636bb6.js";const i={},s=n(`<h2 id="handler-go-处理消息" tabindex="-1"><a class="header-anchor" href="#handler-go-处理消息" aria-hidden="true">#</a> handler.go （处理消息）</h2><h3 id="start" tabindex="-1"><a class="header-anchor" href="#start" aria-hidden="true">#</a> start</h3><ol><li>startNewRound(common.Big0)</li><li>subscribeEvents()</li><li>handleEvents() <ul><li>istanbul.RequestEvent{}</li><li>istanbul.MessageEvent{}</li><li>backlogEvent{}</li><li>timeoutEvent{}</li><li>istanbul.FinalCommittedEvent{}</li></ul></li></ol><h3 id="stop" tabindex="-1"><a class="header-anchor" href="#stop" aria-hidden="true">#</a> stop</h3><ol><li>roundChangeTimer.Stop()</li><li>unsubscribeEvents() <ul><li>events.Unsubscribe()timeoutSub.Unsubscribe()</li><li>finalCommittedSub.Unsubscribe()</li></ul></li><li>使得handler处于wait状态</li></ol><h3 id="handlemsg-handletimeoutmsg" tabindex="-1"><a class="header-anchor" href="#handlemsg-handletimeoutmsg" aria-hidden="true">#</a> handleMsg&amp;handleTimeoutMsg</h3><ol><li>先进行msg的check</li><li>如果是futureMsg，直接存储并returnErr</li><li>接下来处理4个msg</li></ol><h2 id="startnewround" tabindex="-1"><a class="header-anchor" href="#startnewround" aria-hidden="true">#</a> startNewRound</h2><ol><li><p>首先设置roundChange 为false，如果最新的proposer和proposal不存在，直接return</p></li><li><p>第二个步骤有几个if else 需要拆解（TODO）</p></li><li><p>如果roundChange为true，新建一个View，如果为false，sequence加1</p></li><li><p>选出proposer（CalcProposer），根据valset、lastprotser、round进行选择</p></li><li><p>设置状态为接收请求c.setState(StateAcceptRequest)。</p><ul><li><p>发送istanbul.RequestEvent（把proposal扔出去）</p></li><li><p>处理积压消息（Preprepare）</p></li><li><p>发送backlogEvent事件</p></li><li><p>endPreprepare：</p></li><li><p>如果自己是proposer并且和proposal有着相同的sequence，那就广播preprepare消息</p></li><li><p>广播途中将消息转换成payload 并返回</p></li></ul></li></ol><h2 id="handlepreprepare" tabindex="-1"><a class="header-anchor" href="#handlepreprepare" aria-hidden="true">#</a> handlePreprepare</h2><ul><li>校验message ，如果是老的prepare消息，要commit 这个proposal,直接会到广播comiit消息</li><li>校验消息来自当前的proposer</li><li>校验我们接收到的proposal <ul><li>check 坏块</li><li>check block body(rehash)</li><li>verifyHeader (TODO,重点了解)</li></ul></li><li>校验之后，（TODO，逻辑？）</li></ul><p>6.如果锁定的proposal和接收到的proposal不一致就sendNextRoundChange，如果一样，就接收prepare消息并设置状态为StatePreprepared并且发送commit消息</p><h2 id="handlecommit" tabindex="-1"><a class="header-anchor" href="#handlecommit" aria-hidden="true">#</a> handleCommit</h2><ol><li>checkMessage</li><li>verifyCommit</li><li>acceptCommit(添加到commits中)</li><li>有了足够的commit messages并且不是comiited状态将commit proposal</li><li>Commit <ul><li>设置状态为comitted</li><li>创建commitSeals</li><li>进入最终的commit代码 <ul><li>校验proposal是一个有效块</li><li>seals写入到extra-data中（writeCommittedSeals 关键代码）</li><li>更新block的header</li><li>如果proposedBlockHash == commitedBlockHash ,那么就把block 扔到commitCh中去seal并且等待seal结果（这是proposer才会走的通道），直接返回；如果不一样，直接塞入到enqueue中（sb.broadcaster.Enqueue(fetcherID, block)）</li></ul></li></ul></li></ol><h2 id="handleroundchange" tabindex="-1"><a class="header-anchor" href="#handleroundchange" aria-hidden="true">#</a> handleRoundChange</h2><ol><li>checkMessage</li><li>roundChangeSet 添加消息</li><li>只要达到了F+1个roundChange就构成了一个weak proof ,就可以检查此时的round是否比我们的round小，如果小就CatchUp,然后startNewRound（需要2F+1）</li></ol><h2 id="engine-go" tabindex="-1"><a class="header-anchor" href="#engine-go" aria-hidden="true">#</a> engine.go</h2><h3 id="prepare" tabindex="-1"><a class="header-anchor" href="#prepare" aria-hidden="true">#</a> prepare</h3><p>准备header</p><ol><li><p>sb.snapshot</p></li><li><p>从candidates中随机设置coinbase</p></li><li><p>prepareExtra（将快照中的validators添加到extraData的validators中），payload 数据就是编码后的IstanbulExtra，作为extra</p><blockquote><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>types<span class="token punctuation">.</span>IstanbulExtra<span class="token punctuation">{</span>
   Validators<span class="token punctuation">:</span>    vals<span class="token punctuation">,</span>
   Seal<span class="token punctuation">:</span>          <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
   CommittedSeal<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote></li></ol><h3 id="finalizeandassemble" tabindex="-1"><a class="header-anchor" href="#finalizeandassemble" aria-hidden="true">#</a> FinalizeAndAssemble</h3><p>运行交易后状态更改，组装成最终的block</p><h3 id="seal" tabindex="-1"><a class="header-anchor" href="#seal" aria-hidden="true">#</a> seal</h3><p>生成一个新块放入给定通道</p><ol><li>主块判断是否是validator，子链还必须判断是不是子validator</li><li>更新块（updateBlock），proposer用自己的私钥给块签名生成seal，并写入IstanbulExtra的seal中，包括自己的签名的标记和其他人签名的标记，其实就是返回带签名的块</li><li>把块丢到共识引擎中，通过事件istanbul.RequestEvent传播，从而进入到handleRequest，开启sendPrepeare，result等待的就是sb.commitCh中的数据</li></ol>`,25),t=[s];function o(r,p){return a(),l("div",null,t)}const u=e(i,[["render",o],["__file","11.Istanbul_consensus_source_analysis.html.vue"]]);export{u as default};
