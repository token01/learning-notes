import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o,c as r,a as e,b as n,d as t,e as i,r as l}from"./app.9fe353dd.js";const c={},d=e("h2",{id:"github-security-bug-bounty",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#github-security-bug-bounty","aria-hidden":"true"},"#"),n(" GitHub Security Bug Bounty")],-1),u={href:"https://bounty.github.com/",target:"_blank",rel:"noopener noreferrer"},p=e("p",null,"记录 GitHub 历史 bug 。",-1),h=e("blockquote",null,[e("p",null,[n("与成功学一样，一味地学习他人怎么成功是不可取的方法。成功路上的坎坷、失败、经验、教学更值得大家学习。"),e("br"),n(" 学习他人的错误，避免自己再犯错")])],-1),b=e("h2",{id:"绕开-github-oauth",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#绕开-github-oauth","aria-hidden":"true"},"#"),n(" 绕开 GitHub OAuth")],-1),m={href:"https://enterprise.github.com/releases/2.17.3/notes",target:"_blank",rel:"noopener noreferrer"},k=e("h3",{id:"滥用-http-head-请求",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#滥用-http-head-请求","aria-hidden":"true"},"#"),n(" 滥用 HTTP HEAD 请求")],-1),g={href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD",target:"_blank",rel:"noopener noreferrer"},_=e("br",null,null,-1),v=e("code",null,"Rails",-1),T=i(`<p>非常巧 github 认证正好符合这一点。GET 返回 html 认证页面，POST 请求授权应用，参考代码：</p><div class="language-ruby line-numbers-mode" data-ext="rb"><pre class="language-ruby"><code><span class="token comment"># In the router</span>

match <span class="token string-literal"><span class="token string">&quot;/login/oauth/authorize&quot;</span></span><span class="token punctuation">,</span> <span class="token comment"># For every request with this path...</span>
  <span class="token symbol">:to</span> <span class="token operator">=&gt;</span> <span class="token string-literal"><span class="token string">&quot;[the controller]&quot;</span></span><span class="token punctuation">,</span> <span class="token comment"># ...send it to the controller...</span>
  <span class="token symbol">:via</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token symbol">:get</span><span class="token punctuation">,</span> <span class="token symbol">:post</span><span class="token punctuation">]</span> <span class="token comment"># ... as long as it&#39;s a GET or a POST request.</span>


<span class="token comment"># In the controller</span>

<span class="token keyword">if</span> request<span class="token punctuation">.</span>get<span class="token operator">?</span>
  <span class="token comment"># serve authorization page HTML</span>
<span class="token keyword">else</span>
  <span class="token comment"># grant permissions to app</span>
<span class="token keyword">end</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>控制器根据 HTTP 请求 分别处理 GET 与 POST 看似并没有什么问题。<br> 但是如果我们向 <code>https://github.com/login/oauth/authorize</code> 发出 <code>HEAD</code> 已认证请求，通过上面的分析，我们可以得知路由会将它当成 <code>GET</code> 请求来处理，但到了控制器时，他终究不是个 <code>GET</code> 所以他将执行本应 POST 执行的代码段，那么这个经过认证的假 POST 请求， GITHUB 将授权请求中指定应用并给与用户数据。在这里 <code>CSRF</code> 为什么没有起作用，因为 <code>HEAD</code> 请求没有这个限制。因此我们可以发送一个跨站并进过身份认证的 <code>HEAD</code> 请求，这个请求将授权任意 OAuth 权限，而不需要向用户展示确认页面。</p><h3 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h3>`,4),f={href:"https://blog.teddykatz.com/2019/11/05/github-oauth-bypass.html",target:"_blank",rel:"noopener noreferrer"},y={href:"https://hackerone.com/hacktivity",target:"_blank",rel:"noopener noreferrer"};function H(E,G){const s=l("ExternalLinkIcon");return o(),r("div",null,[d,e("p",null,[e("a",u,[n("Github 安全漏洞赏金计划"),t(s)])]),p,h,b,e("p",null,[e("a",m,[n("GitHub enterprise 2.17.3修复了此 bug"),t(s)])]),k,e("p",null,[e("a",g,[n("HTTP HEAD"),t(s)]),n(" 自 HTTP 最初创建就一直存在，但好像开发者们对他使用的并不多。简单讲它只请求页面的首部，它与 GET 方法几乎是一样的，对于 HEAD 请求的回应部分来说，它的HTTP头部中包含的信息与通过 GET 请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到 Request-URI 所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新，检查大文件大小（使用 Content-Length 响应头）"),_,n(" 大多情况开发者不需要特意的处理它，因为像 "),v,n(" 以及其他的 web 框架一样，他们已经帮我们处理了，它们尝试将 HEAD 请求路由到一个地址一样的 GET 请求那里去处理，然后省略响应体。这确实是一个聪明的做法，并符合 HTTP HEAD 规范。")]),T,e("ul",null,[e("li",null,[e("a",f,[n("https://blog.teddykatz.com/2019/11/05/github-oauth-bypass.html"),t(s)])]),e("li",null,[e("a",y,[n("https://hackerone.com/hacktivity"),t(s)])])])])}const A=a(c,[["render",H],["__file","github-bug.html.vue"]]);export{A as default};
