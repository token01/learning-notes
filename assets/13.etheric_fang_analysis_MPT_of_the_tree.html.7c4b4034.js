import{_ as s}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as l,c as o,a as e,b as t,d as a,e as i,r as p}from"./app.8c636bb6.js";const c={},r=i(`<blockquote><p>浅谈以太坊源码分析之MPT树-上</p></blockquote><h2 id="前缀树trie" tabindex="-1"><a class="header-anchor" href="#前缀树trie" aria-hidden="true">#</a> 前缀树Trie</h2><p>前缀树（又称字典树），通常来说，一个前缀树是用来<code>存储字符串</code>的。前缀树的每一个节点代表一个<code>字符串</code>（<code>前缀</code>）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的<code>原始字符串</code>，以及<code>通往该子节点路径上所有的字符</code>组成的。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm73i6xursj31820qq789.jpg" alt="image-20201231160000592" loading="lazy"></p><p>Trie的结点看上去是这样子的：</p><blockquote><p>[ [Ia, Ib, … I*], value]</p></blockquote><p>其中 <code>[Ia, Ib, ... I*]</code> 在本文中我们将其称为结点的 <em>索引数组</em> ，它以 key 中的下一个字符为索引，每个元素<code>I*</code>指向对应的子结点。 <code>value</code> 则代表从根节点到当前结点的路径组成的key所对应的值。如果不存在这样一个 key，则 value 的值为空。</p><p>前缀树的性质：</p><ol><li><p>每一层节点上面的值都不相同；</p></li><li><p>根节点不存储值；除根节点外每一个节点都<strong>只包含一个字符</strong>，代表的字符串是由节点本身的<code>原始字符串</code>，以及<code>通往该子节点路径上所有的字符</code>。</p></li><li><p>前缀树的查找效率是$O(m)$，$m$为所查找节点的长度，而哈希表的查找效率为$O(1)$。且一次查找会有 m 次 <code>IO</code>开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。</p></li><li><p>当存在一个节点，其内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。</p></li></ol><h2 id="压缩前缀树patricia-tree" tabindex="-1"><a class="header-anchor" href="#压缩前缀树patricia-tree" aria-hidden="true">#</a> 压缩前缀树Patricia Tree</h2><p><strong>基数树</strong>（也叫<strong>基数特里树</strong>或<strong>压缩前缀树</strong>）是一种数据结构，是一种更节省空间的<strong>前缀树</strong>，其中作为唯一子节点的每个节点都与其父节点合并，边既可以表示为元素序列又可以表示为单个元素。 因此每个内部节点的子节点数最多为基数树的基数 <em>r</em> ，其中 <em>r</em> 为正整数， <em>x</em> 为 2 的幂， <em>x</em>≥1 ，这使得基数树更适用于对于较小的集合（尤其是字符串很长的情况下）和有很长相同前缀的字符串集合。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm70dwcmgdj31780kkqae.jpg" alt="image-20201231133805927" loading="lazy"></p><p>图中可以很容易看出数中所存储的键值对：</p><ul><li>6c0a5c71ec20bq3w =&gt; 5</li><li>6c0a5c71ec20CX7j =&gt; 27</li><li>6c0a5c71781a1FXq =&gt; 18</li><li>6c0a5c71781a9Dog =&gt; 64</li><li>6c0a8f743b95zUfe =&gt; 30</li><li>6c0a8f743b95jx5R =&gt; 2</li><li>6c0a8f740d16y03G =&gt; 43</li><li>6c0a8f740d16vcc1 =&gt; 48</li></ul><h2 id="默克尔树merkle-tree" tabindex="-1"><a class="header-anchor" href="#默克尔树merkle-tree" aria-hidden="true">#</a> 默克尔树Merkle Tree</h2><p>Merkle树看起来非常像二叉树，其叶子节点上的值通常为数据块的哈希值，而非叶子节点上的值，所以有时候Merkle tree也表示为Hash tree，如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm69qu5vh8j31ba0ragpn.jpg" alt="image-20201230225028932" loading="lazy"></p><p>在构造<code>Merkle</code>树时，首先要计算数据块的哈希值，通常，选用<code>SHA-256</code>等哈希算法。但如果仅仅防止数据不是蓄意的损坏或篡改，可以改用一些安全性低但效率高的校验和算法，如<code>CRC</code>。然后将数据块计算的哈希值两两配对（如果是奇数个数，最后一个自己与自己配对），计算上一层哈希，再重复这个步骤，一直到计算出根哈希值。</p><p>所以我们可以简单总结出<strong>merkle Tree</strong> 有以下几个性质：</p><ul><li>校验整体数据的正确性</li><li>快速定位错误</li><li>快速校验部分数据是否在原始的数据中</li><li>存储空间开销大（<strong>大量中间哈希</strong>）</li></ul><h2 id="以太坊的改进方案" tabindex="-1"><a class="header-anchor" href="#以太坊的改进方案" aria-hidden="true">#</a> 以太坊的改进方案</h2><h3 id="使用-byte作为key类型" tabindex="-1"><a class="header-anchor" href="#使用-byte作为key类型" aria-hidden="true">#</a> 使用[]byte作为key类型</h3><p>在以太坊的Trie模块中，key和value都是[]byte类型。如果要使用其它类型，需要将其转换成[]byte类型（比如使用<strong>rlp</strong>进行转换）。</p><p><strong>Nibble</strong> ：是 key 的基本单元，是一个四元组（四个 bit 位的组合例如二进制表达的 0010 就是一个四元组）</p><p>在Trie模块对外提供的接口中，key类型是[]byte。但在内部实现里，将key中的每个字节按高4位和低4位拆分成了两个字节。比如你传入的key是：</p><blockquote><p>[0x1a, 0x2b, 0x3c, 0x4d]</p></blockquote><p>Trie内部将这个key拆分成：</p><blockquote><p>[0x1, 0xa, 0x2, 0xb, 0x3, 0xc, 0x4, 0xd]</p></blockquote><p>Trie内部的编码中将拆分后的<strong>每一个字节</strong>称为 <strong>nibble</strong></p><p>如果使用一个完整的 byte 作为 key 的最小单位，那么前文提到的索引数组的大小应该是 256（byte作为数组的索引，最大值为255，最小值为0）。而索引数组的每个元素都是一个 32 字节的哈希,这样每个结点要占用大量的空间。并且索引数组中的元素多数情况下是空的，不指向任何结点。因此这种实现方法占用大量空间而不使用。以太坊的改进方法，可以将索引数组的大小降为 16（4个bit的最大值为0xF，最小值为 0），因此大大减少空间的浪费。</p><h3 id="新增类型节点" tabindex="-1"><a class="header-anchor" href="#新增类型节点" aria-hidden="true">#</a> 新增类型节点</h3><p>前缀树和<code>merkle</code>树存在明显的局限性，所以以太坊为<code>MPT</code>树新增了几种不同类型的树节点，通过针对不同节点不同操作来解决效率以及存储上的问题。</p><ol><li><strong>shortNode</strong>: 叶子节点或者扩展节点，当 <code>shortNode.Key</code>的末尾字节是终止符 <code>16</code> 时表示为叶子节点。当 <code>shortNode</code> 是叶子节点是，<code>Val</code> 是 valueNode。</li><li><strong>fullNode</strong>: 分支节点，<code>fullNode[16]</code>的类型是 <code>valueNode</code>。前 16 个元素对应键中可能存在的一个十六进制字符。如果键<code>[key,value]</code>在对应的分支处结束，则在列表末尾存储 <code>value</code> 。</li><li><strong>hashNode</strong>: 应该取名为 <code>collapsedNode</code> 折叠节点更合适些，但因为其值是一个哈希值当做指针使用，所以取名 <code>hashNode</code>。使用这个哈希值可以从数据库读取节点数据展开节点。</li><li><strong>valueNode</strong>: 数据节点，实际的业务数据值，严格来说他不属于树中的节点，它只存在于 <code>fullNode.Children</code> 或者 shortNode.Val 中。</li></ol><p>简单先看个例子，假设有3个键值对，看一下在以太坊中是怎么以MPT的形式存储的：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmg6d40u15j31hu0o0jzy.jpg" alt="image-20210108122909361" loading="lazy"></p><h3 id="以太坊中使用到的mpt树结构" tabindex="-1"><a class="header-anchor" href="#以太坊中使用到的mpt树结构" aria-hidden="true">#</a> 以太坊中使用到的MPT树结构</h3><ul><li><code>State Trie</code> 区块头中的状态树 <ul><li>key =&gt; sha3(以太坊账户地址 address)</li><li>value =&gt; rlp(账号内容信息 account)</li></ul></li><li>Transactions Trie 区块头中的交易树 <ul><li>key =&gt; rlp(交易的偏移量 transaction index)</li><li>每个块都有各自的交易树，且不可更改</li></ul></li><li><code>Receipts Trie</code> 区块头中的收据树 <ul><li>key = rlp(交易的偏移量 transaction index)</li><li>每个块都有各自的交易树，且不可更改</li></ul></li><li><code>Storage Trie</code> 存储树 <ul><li>存储只能合约状态</li><li>每个账号有自己的 Storage Trie</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm70f77s2dj319g0lymyz.jpg" alt="image-20201231141329137" loading="lazy"></p><p>这两个区块头中，<code>state root</code>、<code>tx root</code>、 <code>receipt root</code>分别存储了这三棵树的树根，第二个区块显示了当账号 17 5的数据变更(<strong>27 -&gt; 45</strong>)的时候，只需要存储跟这个账号相关的部分数据，而且老的区块中的数据还是可以正常访问。</p><h3 id="key编码规则" tabindex="-1"><a class="header-anchor" href="#key编码规则" aria-hidden="true">#</a> key编码规则</h3><p>三种编码方式分别为：</p><ol><li><strong>Raw</strong>编码（原生的字符）；</li><li><strong>Hex</strong>编码（扩展的16进制编码）；</li><li><strong>Hex-Prefix</strong>编码（16进制前缀编码）；</li></ol><p><strong>Raw编码</strong></p><p><strong>Raw</strong>编码就是原生的<strong>key</strong>值，不做任何改变。这种编码方式的<strong>key</strong>，<em>是<strong>MPT</strong>对外提供接口的默认编码方式</em>。</p><blockquote><p>例如一条key为“cat”，value为“dog”的数据项，其Raw编码就是[&#39;c&#39;, &#39;a&#39;, &#39;t&#39;]，换成ASCII表示方式就是[63, 61, 74]</p></blockquote><p><strong>Hex编码</strong></p><p><em>Hex编码用于对内存中MPT树节点key进行编码</em>.</p><p>为了减少分支节点孩子的个数，将数据 key 进行半字节拆解而成。即依次将 key[0],key[1],…,key[n] 分别进行半字节拆分成两个数，再依次存放在长度为 len(key)+1 的数组中。 并在数组末尾写入终止符 <code>16</code>。算法如下：</p><blockquote><p>半字节，在计算机中，通常将8位二进制数称为字节，而把4位二进制数称为半字节。 高四位和低四位，这里的“位”是针对二进制来说的。比如数字 250 的二进制数为 11111010，则高四位是左边的 1111，低四位是右边的 1010。</p></blockquote><p>从<strong>Raw</strong>编码向<strong>Hex</strong>编码的转换规则是：</p><ul><li><strong>Raw</strong>编码输入的每个字符分解为高 4 位和低 4 位</li><li>如果是叶子节点，则在最后加上<strong>Hex</strong>值<code>0x10</code>表示结束</li><li>如果是分支节点不附加任何<strong>Hex</strong>值</li></ul><p>例如：字符串 “romane” 的 bytes 是 <code>[114 111 109 97 110 101]</code>，在 HEX 编码时将其依次处理：</p><table><thead><tr><th style="text-align:left;">i</th><th style="text-align:left;">key[i]</th><th style="text-align:left;">key[i]二进制</th><th style="text-align:left;">nibbles[i*2]=高四位</th><th style="text-align:left;">nibbles[i*2+1]=低四位</th></tr></thead><tbody><tr><td style="text-align:left;">0</td><td style="text-align:left;">114</td><td style="text-align:left;">01110010</td><td style="text-align:left;">0111= 7</td><td style="text-align:left;">0010= 2</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">111</td><td style="text-align:left;">01101111</td><td style="text-align:left;">0110=6</td><td style="text-align:left;">1111=15</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">109</td><td style="text-align:left;">01101101</td><td style="text-align:left;">0110=6</td><td style="text-align:left;">1101=13</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:left;">97</td><td style="text-align:left;">01100001</td><td style="text-align:left;">0110=6</td><td style="text-align:left;">0001=1</td></tr><tr><td style="text-align:left;">4</td><td style="text-align:left;">110</td><td style="text-align:left;">01101110</td><td style="text-align:left;">0110=6</td><td style="text-align:left;">1110=14</td></tr><tr><td style="text-align:left;">5</td><td style="text-align:left;">101</td><td style="text-align:left;">01100101</td><td style="text-align:left;">0110=6</td><td style="text-align:left;">0101=5</td></tr></tbody></table><p>最终得到 Hex(“romane”) = <code>[7 2 6 15 6 13 6 1 6 14 6 5 16]</code></p><div class="language-GO line-numbers-mode" data-ext="GO"><pre class="language-GO"><code>// 源码实现
func keybytesToHex(str []byte) []byte {
	l := len(str)*2 + 1
	var nibbles = make([]byte, l)
	for i, b := range str {
		nibbles[i*2] = b / 16   // 高四位
		nibbles[i*2+1] = b % 16 // 低四位
	}
	nibbles[l-1] = 16 // 最后一位存入标示符 代表是hex编码
	return nibbles
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Hex-Prefix</strong>编码</p><p><strong>数学公式定义：</strong></p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm75cvok4yj318s07iwfg.jpg" alt="image-20201231170415071" loading="lazy"></p><p>Hex-Prefix 编码是一种任意量的半字节转换为数组的有效方式，还可以在存入一个标识符来区分不同节点类型。 因此 HP 编码是在由一个标识符前缀和半字节转换为数组的两部分组成。存入到数据库中存在节点 Key 的只有扩展节点和叶子节点，因此 HP 只用于区分扩展节点和叶子节点，不涉及无节点 key 的分支节点。其编码规则如下图：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm74pxxc7yj31ju0cm41o.jpg" alt="image-20201231164209626" loading="lazy"></p><p>前缀标识符由两部分组成：节点类型和奇偶标识，并存储在编码后字节的第一个半字节中。 0 表示扩展节点类型，1 表示叶子节点，偶为 0，奇为 1。最终可以得到唯一标识的前缀标识：</p><ul><li>0：偶长度的扩展节点</li><li>1：奇长度的扩展节点</li><li>2：偶长度的叶子节点</li><li>3：奇长度的叶子节点</li></ul><p>当偶长度时，第一个字节的低四位用<code>0</code>填充，当是奇长度时，则将 key[0] 存放在第一个字节的低四位中，这样 HP 编码结果始终是偶长度。 这里为什么要区分节点 key 长度的奇偶呢？这是因为，半字节 <code>1</code> 和 <code>01</code> 在转换为 bytes 格式时都成为<code>&lt;01&gt;</code>，无法区分两者。</p><p>例如，上图 “以太坊 MPT 树的哈希计算”中的控制节点1的key 为 <code>[ 7 2 6 f 6 d]</code>，因为是偶长度，则 HP[0]= (00000000) =0，H[1:]= 解码半字节(key)。 而节点 3 的 key 为 <code>[1 6 e 6 5]</code>，为奇长度，则 HP[0]= (0001 0001)=17。</p><p><strong>HP</strong>编码的规则如下：</p><ul><li>key结尾为<strong>0x10</strong>，则去掉这个终止符</li><li>key之前补一个四元组这个Byte第0位区分奇偶信息，第 1 位区分节点类型</li><li>如果输入<strong>key</strong>的长度是偶数，则再添加一个四元组0x0在flag四元组后</li><li>将原来的key内容压缩，将分离的两个byte以高四位低四位进行合并</li></ul><blockquote><p>十六进制前缀编码相当于一个逆向的过程，比如输入的是[6 2 6 15 6 2 16]，</p><p>根据第一个规则去掉终止符16。根据第二个规则key前补一个四元组，从右往左第一位为1表示叶子节点，</p><p>从右往左第0位如果后面key的长度为偶数设置为0，奇数长度设置为1，那么四元组0010就是2。</p><p>根据第三个规则，添加一个全0的补在后面，那么就是20.根据第三个规则内容压缩合并，那么结果就是[0x20 0x62 0x6f 0x62]</p></blockquote><p><strong>HP 编码源码实现:</strong></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">hexToCompact</span><span class="token punctuation">(</span>hex <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{</span>
	terminator <span class="token operator">:=</span> <span class="token function">byte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//初始化一个值为0的byte，它就是我们上面公式中提到的t</span>
	<span class="token keyword">if</span> <span class="token function">hasTerm</span><span class="token punctuation">(</span>hex<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">//验证hex有后缀编码，</span>
		terminator <span class="token operator">=</span> <span class="token number">1</span>         <span class="token comment">//hex编码有后缀，则t=1</span>
		hex <span class="token operator">=</span> hex<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>hex<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">//此处只是去掉后缀部分的hex编码</span>
	<span class="token punctuation">}</span>
	<span class="token comment">////Compact开辟的空间长度为hex编码的一半再加1，这个1对应的空间是Compact的前缀</span>
	buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>hex<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token comment">////这一阶段的buf[0]可以理解为公式中的16*f(t)</span>
	buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> terminator <span class="token operator">&lt;&lt;</span> <span class="token number">5</span> <span class="token comment">// the flag byte</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>hex<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>     <span class="token comment">//hex 长度为奇数，则逻辑上说明hex有前缀</span>
		buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span> <span class="token comment">////这一阶段的buf[0]可以理解为公式中的16*（f(t)+1）</span>
		buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">|=</span> hex<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// first nibble is contained in the first byte</span>
		hex <span class="token operator">=</span> hex<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token comment">//此时获取的hex编码无前缀无后缀</span>
	<span class="token punctuation">}</span>
	<span class="token function">decodeNibbles</span><span class="token punctuation">(</span>hex<span class="token punctuation">,</span> buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//将hex编码映射到compact编码中</span>
	<span class="token keyword">return</span> buf                  <span class="token comment">//返回compact编码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上三种编码方式的转换关系为：</p><ul><li>Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；</li><li>Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；</li><li>HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；</li></ul><p>如下图：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm71rsyyekj319w05ygml.jpg" alt="image-20201231150011417" loading="lazy"></p><p>以上介绍的MPT树，可以用来存储内容为任何长度的<code>key-value</code>数据项。倘若数据项的<code>key</code>长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：</p><ul><li>查询一个节点可能会需要许多次 IO 读取，效率低下；</li><li>系统易遭受 Dos 攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用<code>SLOAD</code>指令读取该树节点的内容，造成系统执行效率极度下降；</li><li>所有的 key 其实是一种明文的形式进行存储；</li></ul><p>为了解决以上问题，以太坊对<strong>MPT</strong>再进行了一次封装，对数据项的<strong>key</strong>进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是<code>(sha3(key), value)</code></p><p><strong>优势</strong>：</p><ul><li>传入MPT接口的 key 是固定长度的（32字节），可以避免出现树中出现长度很长的路径；</li></ul><p><strong>劣势</strong>：</p><ul><li>每次树操作需要增加一次哈希计算；</li><li>需要在数据库中存储额外的<code>sha3(key)</code>与<code>key</code>之间的对应关系；</li></ul><p>完整的编码流程如图：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm71x5i5djj31by07275g.jpg" alt="image-20201231150520220" loading="lazy"></p><h2 id="mpt轻节点" tabindex="-1"><a class="header-anchor" href="#mpt轻节点" aria-hidden="true">#</a> MPT轻节点</h2><p>上面的MPT树，有两个问题：</p><ul><li>每个节点都包含有大量信息，并且叶子节点中还包含有完整的数据信息。如果该MPT树并没有发生任何变化，并且没有被使用，则会白白占用一大片空间，想象一个以太坊，有多少个MPT树，都在内存中，那还了得。</li><li>并不是任何的客户端都对所有的MPT树都感兴趣，若每次都把完整的节点信息都下载下，下载时间长不说，并且会占用大量的磁盘空间。</li></ul><h3 id="解决方式" tabindex="-1"><a class="header-anchor" href="#解决方式" aria-hidden="true">#</a> 解决方式</h3><p>为了解决上述问题，以太坊使用了一种缓存机制，可以称为是轻节点机制，大体如下：</p><ul><li>若某节点数据一直没有发生变化，则仅仅保留该节点的32位hash值，剩下的内容全部释放</li><li>若需要插入或者删除某节点，先通过该hash值db中查找对应的节点，并加载到内存，之后再进行删除插入操作</li></ul><h4 id="轻节点中添加数据" tabindex="-1"><a class="header-anchor" href="#轻节点中添加数据" aria-hidden="true">#</a> 轻节点中添加数据</h4><p>内存中只有这么一个轻节点，但是我要添加一个数据，也就是要给完整的MPT树中添加一个叶子节点，怎么添加？大体如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm8hgf9f3ij319a0pcgqh.jpg" alt="image-20210101204824090" loading="lazy"></p><p>到此以太坊的MPT树的基础讲解结束。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>`,93),d={href:"https://mindcarver.cn",target:"_blank",rel:"noopener noreferrer"},u={href:"https://github.com/blockchainGuide",target:"_blank",rel:"noopener noreferrer"},g={href:"https://eth.wiki/en/fundamentals/patricia-tree",target:"_blank",rel:"noopener noreferrer"},k={href:"https://ethereum.github.io/yellowpaper/paper.pdf#appendix.D",target:"_blank",rel:"noopener noreferrer"},h={href:"https://ethfans.org/toya/articles/588",target:"_blank",rel:"noopener noreferrer"},m={href:"https://learnblockchain.cn/books/geth/part3/mpt.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/",target:"_blank",rel:"noopener noreferrer"},y={href:"https://arxiv.org/pdf/1909.11590.pdf",target:"_blank",rel:"noopener noreferrer"},f={href:"https://learnblockchain.cn/books/geth/part3/mpt.html",target:"_blank",rel:"noopener noreferrer"};function x(v,_){const n=p("ExternalLinkIcon");return l(),o("div",null,[r,e("blockquote",null,[e("p",null,[e("a",d,[t("https://mindcarver.cn"),a(n)])]),e("p",null,[e("a",u,[t("https://github.com/blockchainGuide"),a(n)]),t(" 文章及视频学习资料")]),e("p",null,[e("a",g,[t("https://eth.wiki/en/fundamentals/patricia-tree"),a(n)])]),e("p",null,[e("a",k,[t("https://ethereum.github.io/yellowpaper/paper.pdf#appendix.D"),a(n)])]),e("p",null,[e("a",h,[t("https://ethfans.org/toya/articles/588"),a(n)])]),e("p",null,[e("a",m,[t("https://learnblockchain.cn/books/geth/part3/mpt.html"),a(n)])]),e("p",null,[e("a",b,[t("https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/"),a(n)])]),e("p",null,[e("a",y,[t("https://arxiv.org/pdf/1909.11590.pdf"),a(n)])]),e("p",null,[e("a",f,[t("https://learnblockchain.cn/books/geth/part3/mpt.html"),a(n)])])])])}const w=s(c,[["render",x],["__file","13.etheric_fang_analysis_MPT_of_the_tree.html.vue"]]);export{w as default};
